<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapid Telemetry Viewer</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #007bff;
            --accent-color: #ffc107;
            --header-bg: #2c2c2c;
            --sidebar-bg: #252526;
            --chart-bg: #2a2a2a;
            --text-color: #f0f0f0;
            --text-color-light: #ccc;
            --border-color: #444;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: var(--header-bg);
            padding: 10px 20px;
            border-bottom: 2px solid var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        h1 { margin: 0; font-size: 1.5em; }

        .controls { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }

        .import-button, button {
            background-color: var(--primary-color);
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .import-button:hover, button:hover { background-color: #0056b3; }

        main {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        #sidebar {
            width: 350px;
            background-color: var(--sidebar-bg);
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #sidebar h2 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            font-size: 1.1em;
            color: var(--text-color-light);
        }

        #lap-selector { max-height: 250px; overflow-y: auto; }
        .lap-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            padding: 6px;
            border-radius: 3px;
            background: #333;
            font-size: 0.85em;
            border-left: 3px solid transparent;
        }
        .lap-item:hover { background-color: #444; }
        .lap-item.is-reference { border-left-color: var(--accent-color); background-color: #3a3a3a; }
        
        .lap-file-label { font-size: 0.8em; color: #888; display: block; width: 100px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .lap-status { font-size: 0.7em; margin-left: auto; text-align: right; color: #aaa; }
        .lap-status span { padding: 2px 5px; border-radius: 3px; }
        .lap-status .invalid { background-color: rgba(220, 53, 69, 0.2); color: #ff8089; }
        .lap-status .outin { background-color: rgba(255, 193, 7, 0.2); color: #ffc107; }
        .lap-status .complete { background-color: rgba(40, 167, 69, 0.2); color: #80ff97; }

        input[type="radio"].ref-radio {
            appearance: none;
            width: 12px;
            height: 12px;
            border: 2px solid #666;
            border-radius: 50%;
            cursor: pointer;
            outline: none;
        }
        input[type="radio"].ref-radio:checked {
            border-color: var(--accent-color);
            background-color: var(--accent-color);
            box-shadow: 0 0 5px var(--accent-color);
        }

        .sector-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }
        .sector-table th { text-align: left; color: #aaa; padding: 4px; }
        .sector-table td { padding: 4px; border-bottom: 1px solid #333; cursor: pointer; }
        .sector-table tr:hover { background-color: #333; }

        #track-map-wrapper {
            height: 250px;
            background-color: var(--chart-bg);
            border-radius: 6px;
            padding: 5px;
            margin-bottom: 10px;
        }

        #chart-container {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            background-color: #222;
        }

#import-coffee, #buy-coffee, #buy-coffee-btn { 
  margin-left: 1px;
  text-decoration: none; /* Removes underline if using anchor */
  display: inline-flex; /* Aligns items horizontally */
  align-items: center; /* Vertically centers content */
  gap: 6px; /* Space between icon and text */
  padding: 6px 10px; /* Reduced padding for a smaller height */
  border: none; /* Removes border */
  border-radius: 4px; /* Matches button corners */
  background-color: #007bff; /* Matches existing button styles */
  color: white; /* Text color */
  font-size: 14px; /* Ensure font size matches others */
  cursor: pointer; /* Show pointer on hover */
  transition: background-color 0.2s; /* Smooth hover effect */
}

#buy-coffee-btn:hover {
  background-color: #0056b3; /* Darkens background on hover */
}


        /* New styles for fullscreen chart toggle */
        #chart-container {
            position: relative; /* Needed for absolute positioning of fullscreen charts */
        }

        .chart-wrapper {
            position: relative; /* Needed for absolute positioning of the fullscreen button */
        }

        .fullscreen-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 3px;
            color: white;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1; /* Prevents extra line height causing vertical misalignment */
            z-index: 10; /* Ensure button is above chart */
            transition: background-color 0.2s;
        }

        .fullscreen-btn:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }

        /* Styles for the chart in fullscreen mode */
        .chart-wrapper.is-fullscreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100; /* Ensure it's on top of other elements in #chart-container */
            background-color: var(--chart-bg); /* Ensure background covers hidden charts */
            padding: 20px; /* Adjust padding for fullscreen view */
            box-sizing: border-box; /* Include padding in width/height calculation */
            border-radius: 0; /* Remove rounded corners in fullscreen */
        }

        /* Hide other charts when one is fullscreen */
        #chart-container.fullscreen-active .chart-wrapper:not(.is-fullscreen) {
            display: none;
        }



        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
            flex-shrink: 0;
            background-color: var(--chart-bg);
            border-radius: 6px;
            padding: 10px;
            box-sizing: border-box;
        }

        canvas { width: 100% !important; height: 100% !important; }

        .status { padding: 10px; border-radius: 4px; font-size: 0.9em; }
        .info { background-color: rgba(0, 123, 255, 0.2); color: #80bdff; }
        .error { background-color: rgba(220, 53, 69, 0.2); color: #ff8089; }
        .success { background-color: rgba(40, 167, 69, 0.2); color: #80ff97; }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

        .chartjs-tooltip {
            pointer-events: none;
        }

.chart-help-icon {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.5);
    color: #fff;
    font-size: 11px;
    line-height: 18px;
    text-align: center;
    cursor: help;
    z-index: 6;
    user-select: none;
}

.chart-help-icon:hover {
    background-color: rgba(0, 0, 0, 0.8);
}

.header-brand {
    display: flex;
    align-items: center;
    gap: 0;              /* remove flex gap */
}

.header-brand h1 {
    margin: 0;
    margin-left: 0px;    /* tiny manual spacing between logo and text */
    font-size: 1.4em;
}


@media (max-width: 768px) {
    /* Layout: stack sidebar above charts instead of side-by-side */
    main {
        flex-direction: column;
    }

    #sidebar {
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
        max-height: 40vh; /* let it scroll but not take the whole screen */
        overflow-y: auto;
    }

    #chart-container {
        padding: 10px;            /* less padding on small screens */
        gap: 10px;
    }

    /* Make charts taller so they’re easier to read on a narrow screen */
    .chart-wrapper {
        height: 260px;            /* was 200px */
        padding: 8px;
    }

    /* Header: title on top, controls below */
    header {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
    }

    header h1 {
        font-size: 1.2em;
        text-align: left;
        margin-bottom: 4px;
    }

    /* Controls in a 2-column grid on phones */
    header .controls {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
    }

    /* Make each control fill its grid cell */
    header .controls > * {
        width: 100%;
        justify-content: center;
    }

    /* Compact the toggle labels (Show Tooltip, Show ABS) */
    header .controls label {
        font-size: 0.8rem;
        padding: 4px 6px;
        background-color: #333;
        border-radius: 4px;
        box-sizing: border-box;
        display: flex;
        align-items: center;
    }

    header .controls label input[type="checkbox"] {
        margin-right: 4px;
    }

    /* Smaller buttons on mobile */
    .import-button,
    button {
        padding: 6px 8px;
        font-size: 0.8rem;
    }

    /* Keep Import button blue and center its text */
    header .controls .import-button {
        background-color: #007bff;
        color: #fff;
        display: flex;
        align-items: center;    /* vertical centering */
        justify-content: center;/* horizontal centering */
        text-align: center;
    }
}

@media (max-width: 480px) {
    /* On very small phones, stack controls in a single column */
    header .controls {
        grid-template-columns: 1fr;
    }
}




    </style>
</head>
<body>
<header>
<div class="header-brand">
  <svg
    viewBox="0 0 130 40"
    width="90"
    height="28"
    xmlns="http://www.w3.org/2000/svg"
  >
    <!-- Telemetry waveform line (shifted left and scaled down vertically) -->
    <polyline
      points="0,28 13,24 26,30 39,20 52,22 65,15 78,18 91,14 104,17"
      fill="none"
      stroke="#007bff"
      stroke-width="2.5"
      stroke-linecap="round"
      stroke-linejoin="round"
    />

    <!-- Stylized car silhouette (shifted and scaled for new viewBox) -->
    <path
      d="M5 24
         C 12 14, 33 12, 45 14
         L 57 15
         C 64 16, 70 19, 74 23
         L 72 24
         C 68 20, 63 18, 57 19
         L 44 20
         C 33 17, 18 17, 9 24
         Z"
      fill="none"
      stroke="#ffc107"
      stroke-width="1.8"
      stroke-linecap="round"
      stroke-linejoin="round"
    />

    <!-- Wheels -->
    <circle cx="18" cy="26" r="3" fill="#1a1a1a" stroke="#888" stroke-width="1.6"/>
    <circle cx="40" cy="26" r="3" fill="#1a1a1a" stroke="#888" stroke-width="1.6"/>
  </svg>

  <h1>Rapid Telemetry Viewer</h1>
</div>

  <div class="controls">
            <label for="file-import" class="import-button">Import .ibt File(s)</label>
            <input type="file" id="file-import" accept=".ibt" multiple hidden>
            
            <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color: var(--text-color-light);">
                <input type="checkbox" id="toggle-tooltips" style="margin:0;">
                Show Tooltip Details
            </label>
            <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color: var(--text-color-light);">
                <input type="checkbox" id="toggle-abs-areas" style="margin:0;">
                Show ABS Areas
            </label>

            <button id="reset-zoom">Reset Zoom</button>
            <button id="print-placemat">Placemat Report</button>
<button id="buy-coffee-btn" class="import-button" title="Buy me a coffee">☕ Buy Me a Coffee</button>
        </div>
    </header>
    <main>
        <aside id="sidebar">
            <div>
                <h2>Status</h2>
                <div id="status-container">
                    <div class="status info">Ready to import .ibt files</div>
                </div>
            </div>

            <div>
                <h2>Track Map</h2>
                <div id="track-map-wrapper">
                    <canvas id="track-map-chart"></canvas>
                </div>
                <div style="font-size: 0.8em; color: #888; margin-top:5px; text-align: center;">
                    Hover over charts to see position<br>
                    Drag to zoom, <-|-> to pan
                </div>
            </div>
            
            <div>
                <h2>Laps</h2>
                <div style="font-size: 0.8em; color: #aaa; margin-bottom: 5px; display: flex; justify-content: space-between; padding: 0 5px;">
                    <span>Vis | Ref</span>
                    <span>Lap Info</span>
                    <span>Color</span>
                </div>
                <div id="lap-selector">
                    <p style="color: #888; font-style: italic;">No laps loaded.</p>
                </div>
            </div>

            <div>
                <h2>Sector Analysis</h2>
                <div id="sector-container">
                    <table class="sector-table">
                        <thead>
                            <tr>
                                <th>Sector</th>
                                <th>Time</th>
                                <th>Delta (vs Ref)</th>
                            </tr>
                        </thead>
                        <tbody id="sector-body"></tbody>
                    </table>
                </div>
            </div>
<div>
    <h2>Session Summary</h2>
    <div id="summary-container" style="font-size:0.8em; color:#aaa;">
        <span style="color:#888;">No summary available.</span>
    </div>
</div>
            <div>
                <h2>Contact</h2>
                <p style="font-size: 0.8em; color: #888;">
                    Questions or feedback? Email us at: <br>
                    <a href="mailto:hello@rapidtelem.com" style="color: var(--primary-color); text-decoration: none;">hello@rapidtelem.com</a>
                </p>
            </div>
        </aside>

        <section id="chart-container">
             <div class="chart-wrapper">
                <canvas id="delta-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="speed-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="throttle-brake-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="steering-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="rpm-gear-chart"></canvas>
            </div>
<div class="chart-wrapper">
    <div class="chart-help-icon"
         title="Suspension Velocity Histogram:
- X axis: damper shaft velocity in mm/s (negative = bump/compression, positive = rebound/extension).
- Y axis: number of samples at that speed.
- A smooth, roughly symmetric shape around 0 mm/s usually indicates a well-balanced damper.
- Tall bars near 0 mm/s → damper spends most time at low speed (stiffer feel).
- Significant bars far from 0 mm/s → frequent high-speed movement (softer or heavily worked corner).">
        ?
    </div>
    <canvas id="suspension-velocity-chart"></canvas>
</div>

<div class="chart-wrapper" id="damper-rec-wrapper" style="height:auto; padding:10px;">
<h3
  style="margin:0 0 8px; font-size:0.95rem; color:#ccc; cursor:help;"
  title="Each corner shows mean and σ (sigma) for damper velocity:
- mean (mm/s): average shaft speed. Near 0 → balanced bump/rebound. Negative → bump bias, positive → rebound bias.
- σ (mm/s): how wide the velocity spread is. Low σ → stiffer / less movement. High σ → softer / more movement.
Use these with the text below to decide whether to soften or stiffen bump/rebound at each corner."
>
  Damper Recommendations
</h3>

    <div id="damper-rec-content" style="font-size:0.8rem; color:#aaa;"></div>
</div>
<div class="chart-wrapper">
    <div class="chart-help-icon"
         title="Combined G-Forces Scatter:
- Each point is one moment on track: X = Longitudinal G (braking/throttle), Y = Lateral G (cornering).
- Negative X: braking, positive X: acceleration.
- Negative Y: left-hand cornering load, positive Y: right-hand cornering load.
- The outer ‘cloud’ shape shows the maximum combined grip you’re using.
- Compare laps: denser outer points for one lap often mean better use of available grip, if the car is still stable.">
        ?
    </div>
    <canvas id="gforce-scatter-chart"></canvas>
</div>

        </section>
    </main>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

<script>
        // --- Global State ---
        let telemetryData = []; // Stores ALL laps (valid, invalid, out/in)
        let charts = {};
        let currentFullscreenChartWrapper = null;
        let referenceLapId = null; // ID of the lap selected as reference
        const defaultVisibleLapIds = new Set(); // IDs of laps checked visible by default
        const defaultColors = ['#007bff', '#ff4500', '#28a745', '#ffc107', '#17a2b8', '#6f42c1', '#e83e8c'];
        
        // Variables to track last hovered point for cursor stability
        let lastHoveredMapCoords = null; 
        
        // NEW: Toggle state for ABS shaded areas
        let showAbsAreas = false;

        // --- NEW: Minimum time for a lap to be considered valid/complete ---
        const MIN_VALID_LAP_TIME = 10; // seconds.


// SVG icons for the button
const fullscreenIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3m-18 0V19a2 2 0 0 0 2 2h3"></path></svg>`;
const exitFullscreenIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 4H5a2 2 0 0 0-2 2v3m18 0V6a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3m-18 0V18a2 2 0 0 0 2 2h3"></path></svg>`;

function addFullscreenButton(chartWrapper, chartInstance) {
    const btn = document.createElement('button');
    btn.className = 'fullscreen-btn';
    btn.innerHTML = fullscreenIcon; // Initial icon
    btn.title = 'Toggle Fullscreen';

    btn.addEventListener('click', () => {
        toggleChartFullscreen(chartWrapper, chartInstance, btn);
    });
    chartWrapper.appendChild(btn);
}

function toggleChartFullscreen(targetWrapper, chartInstance, buttonElement) {
    const chartContainer = document.getElementById('chart-container');

    // Store references to all potentially affected charts
    const allCharts = Object.values(charts).filter(c => c && c.canvas && c.canvas.id !== 'suspension-velocity-chart' && c.canvas.id !== 'gforce-scatter-chart');


    // If this chart is already fullscreen, exit fullscreen
    if (targetWrapper.classList.contains('is-fullscreen')) {
        targetWrapper.classList.remove('is-fullscreen');
        chartContainer.classList.remove('fullscreen-active');
        buttonElement.innerHTML = fullscreenIcon;
        currentFullscreenChartWrapper = null;
    } else {
        // If another chart is fullscreen, exit that one first
        if (currentFullscreenChartWrapper && currentFullscreenChartWrapper !== targetWrapper) {
            currentFullscreenChartWrapper.classList.remove('is-fullscreen');
            const otherBtn = currentFullscreenChartWrapper.querySelector('.fullscreen-btn');
            if (otherBtn) otherBtn.innerHTML = fullscreenIcon;
        }

        // Enter fullscreen for the target chart
        targetWrapper.classList.add('is-fullscreen');
        chartContainer.classList.add('fullscreen-active');
        buttonElement.innerHTML = exitFullscreenIcon;
        currentFullscreenChartWrapper = targetWrapper;
    }

    // Crucially, trigger Chart.js to resize itself after DOM manipulation
    // Use a small delay to ensure CSS transitions/layout changes are complete
    // We now resize ALL relevant charts to ensure they pick up their correct container dimensions
    setTimeout(() => {
        allCharts.forEach(chart => {
            // Check if the chart's wrapper is currently visible
            const chartElement = chart.canvas;
            const chartWrapper = chartElement.closest('.chart-wrapper');
            if (chartWrapper && chartWrapper.offsetParent !== null) { // offsetParent is null if display: none
                chart.resize();
            } else {
                // If the chart is hidden, we explicitly ensure its internal state is prepared for when it becomes visible
                // Forcing an update can sometimes help it wake up correctly when display:block
                chart.update('none'); 
            }
        });
    }, 50); // Small delay to let CSS apply
}



        // --- Utility function for debouncing ---
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        // Helper function to interpolate Y value based on X (distance)
        function getInterpolatedMapCoords(lapData, distance) {
            if (!lapData || lapData.distance.length === 0) return null;

            const distances = lapData.distance;
            const mapX = lapData.mapX;
            const mapY = lapData.mapY;

            let i = 0;
            while (i < distances.length && distances[i] < distance) {
                i++;
            }

            if (i === 0) return { x: mapX[0], y: mapY[0] }; 
            if (i >= distances.length) return { x: mapX[distances.length - 1], y: mapY[distances.length - 1] };

            const x1 = distances[i - 1];
            const y1_mapX = mapX[i - 1];
            const y1_mapY = mapY[i - 1];

            const x2 = distances[i];
            const y2_mapX = mapX[i];
            const y2_mapY = mapY[i];

            if (x1 === x2) return { x: y1_mapX, y: y1_mapY }; 

            const ratio = (distance - x1) / (x2 - x1);
            const interpolatedMapX = y1_mapX + (y2_mapX - y1_mapX) * ratio;
            const interpolatedMapY = y1_mapY + (y2_mapY - y1_mapY) * ratio;

            return { x: interpolatedMapX, y: interpolatedMapY };
        }


// --- IBT Parser (Now including LapInvalid, BrakeABSactive, G-Forces, SessionInfo) ---
class IBTParser {
    constructor(buffer) {
        this.buffer = buffer;
        this.view = new DataView(buffer);
        this.header = {};
        this.vars = [];
    }

    readHeader() {
        // Based on irsdk_header layout
        this.header.version          = this.view.getInt32(0,  true);  // irsdk_ver
        this.header.sessionInfoLen   = this.view.getInt32(8,  true);  // irsdk_sessionInfoLen
        this.header.sessionInfoOffset= this.view.getInt32(12, true);  // irsdk_sessionInfoOffset
        this.header.numVars          = this.view.getInt32(24, true);  // irsdk_numVars
        this.header.varHeaderOffset  = this.view.getInt32(28, true);  // irsdk_varHeaderOffset
        this.header.bufLen           = this.view.getInt32(36, true);  // irsdk_bufLen
        this.header.bufOffset        = this.view.getInt32(52, true);  // irsdk_bufOffset
    this.header.sessionInfoLen    = this.view.getInt32(16, true); // sessionInfoLen
    this.header.sessionInfoOffset = this.view.getInt32(20, true); // sessionInfoOffset
}

    readVarHeaders() {
        const decoder = new TextDecoder('windows-1252');
        const VAR_HEADER_SIZE = 144;
        for (let i = 0; i < this.header.numVars; i++) {
            const offset = this.header.varHeaderOffset + (i * VAR_HEADER_SIZE);
            const type = this.view.getInt32(offset, true);
            const varOffset = this.view.getInt32(offset + 4, true);
            const name = decoder.decode(new Uint8Array(this.buffer, offset + 16, 32)).replace(/\0/g, '');
            this.vars.push({ name, type, offset: varOffset });
        }
    }

    parse() {
        try {
            this.readHeader();
            this.readVarHeaders();

            const varMap = new Map();
            this.vars.forEach(v => varMap.set(v.name, v));

            // --- Read SessionInfo text (YAML/INI-style) ---
            let sessionInfoStr = '';
            if (this.header.sessionInfoLen > 0 && this.header.sessionInfoOffset > 0) {
                const bytes = new Uint8Array(
                    this.buffer,
                    this.header.sessionInfoOffset,
                    this.header.sessionInfoLen
                );
                sessionInfoStr = new TextDecoder('utf-8')
                    .decode(bytes)
                    .replace(/\0+$/, ''); // trim trailing nulls
            }
            this.header.sessionInfoStr = sessionInfoStr;

            // --- Variable mapping (your existing requiredVars) ---
            const requiredVars = {
                'Lap': 'Lap',
                'LapDist': 'LapDist',
                'Speed': 'Speed',
                'RPM': 'RPM',
                'Gear': 'Gear',
                'Throttle': 'Throttle',
                'Brake': 'Brake',
                'Steering': 'SteeringWheelAngle',
                'SessionTime': 'SessionTime',
                'Lat': 'Lat',
                'Lon': 'Lon',
                'LapInvalid': 'LapInvalid',
                'BrakeABSactive': 'BrakeABSactive',
                'FuelLevel': 'FuelLevel', // ADDED: FuelLevel for consumption calculation
                'LFshockVel': 'LFshockVel',
                'RFshockVel': 'RFshockVel',
                'LRshockVel': 'LRshockVel',
                'RRshockVel': 'RRshockVel',
                'gForceLat': 'LatAccel',
                'gForceLong': 'LongAccel'
            };

            const targetVars = {};
            for (const [key, ibtName] of Object.entries(requiredVars)) {
                if (varMap.has(ibtName)) {
                    targetVars[key] = varMap.get(ibtName);
                }
            }

            const parsed = this.readDataBuffer(targetVars);
            parsed.sessionInfoStr = sessionInfoStr; // attach for summary
            return parsed;
        } catch (e) {
            throw new Error("Failed to parse IBT: " + e.message);
        }
    }

    readDataBuffer(targetVars) {
        const dataStart = this.header.bufOffset;
        const totalBytes = this.buffer.byteLength;
        const rowCount = Math.floor((totalBytes - dataStart) / this.header.bufLen);
        const result = { laps: [] };

        let currentLap = -1;
        let currentLapData = null; 

        const getValue = (rowOffset, varDef) => {
            if (!varDef) return 0;
            const pos = rowOffset + varDef.offset;
            switch (varDef.type) { 
                case 0: return this.view.getInt8(pos); 
                case 1: return this.view.getUint8(pos); 
                case 2: return this.view.getInt32(pos, true); 
                case 3: return this.view.getUint32(pos, true); 
                case 4: return this.view.getFloat32(pos, true); 
                case 5: return this.view.getFloat64(pos, true); 
                default: return 0; 
            }
        };

        const MS2_TO_G = 1 / 9.80665;

        for (let i = 0; i < rowCount; i++) {
            const rowOffset = dataStart + (i * this.header.bufLen);
            const lapNum = getValue(rowOffset, targetVars.Lap);

            if (lapNum !== currentLap) {
                if (currentLapData && currentLapData.data.distance.length > 50) {
                    currentLapData.lapTime =
                        currentLapData.data.time[currentLapData.data.time.length - 1] -
                        currentLapData.data.time[0];
                    result.laps.push(currentLapData);
                }
                currentLap = lapNum;
                currentLapData = this.createLapData(lapNum);
            }

            if (currentLapData) {
                const lat = getValue(rowOffset, targetVars.Lat); 
                const lon = getValue(rowOffset, targetVars.Lon); 
                const lapInvalid = getValue(rowOffset, targetVars.LapInvalid); 
                const brakeABSactive = getValue(rowOffset, targetVars.BrakeABSactive); 
                
                currentLapData.data.distance.push(getValue(rowOffset, targetVars.LapDist));
                currentLapData.data.speed.push(getValue(rowOffset, targetVars.Speed) * 3.6);
                currentLapData.data.rpm.push(getValue(rowOffset, targetVars.RPM));
                currentLapData.data.gear.push(getValue(rowOffset, targetVars.Gear));
                currentLapData.data.throttle.push(getValue(rowOffset, targetVars.Throttle) * 100);
                currentLapData.data.brake.push(getValue(rowOffset, targetVars.Brake) * 100);
                currentLapData.data.steering.push(getValue(rowOffset, targetVars.Steering));
                currentLapData.data.time.push(getValue(rowOffset, targetVars.SessionTime));
                currentLapData.data.rawLat.push(lat);
                currentLapData.data.rawLon.push(lon);
                currentLapData.data.brakeABSactive.push(brakeABSactive);

                if (targetVars.FuelLevel) {
                    currentLapData.data.fuelLevel.push(getValue(rowOffset, targetVars.FuelLevel));
                }

                if (targetVars.LFshockVel) currentLapData.data.shockVelLF.push(getValue(rowOffset, targetVars.LFshockVel));
                if (targetVars.RFshockVel) currentLapData.data.shockVelRF.push(getValue(rowOffset, targetVars.RFshockVel));
                if (targetVars.LRshockVel) currentLapData.data.shockVelLR.push(getValue(rowOffset, targetVars.LRshockVel));
                if (targetVars.RRshockVel) currentLapData.data.shockVelRR.push(getValue(rowOffset, targetVars.RRshockVel));

                // G-forces in G
                if (targetVars.gForceLat) {
                    const latMs2 = getValue(rowOffset, targetVars.gForceLat);
                    currentLapData.data.gForceLat.push(latMs2 * MS2_TO_G);
                }
                if (targetVars.gForceLong) {
                    const longMs2 = getValue(rowOffset, targetVars.gForceLong);
                    currentLapData.data.gForceLong.push(longMs2 * MS2_TO_G);
                }

                if (lapInvalid > 0) {
                    currentLapData.lapMetadata.isValidByFlag = false;
                }
            }
        }

        if (currentLapData && currentLapData.data.distance.length > 50) {
            currentLapData.lapTime =
                currentLapData.data.time[currentLapData.data.time.length - 1] -
                currentLapData.data.time[0];
            result.laps.push(currentLapData);
        }

        return result;
    }

    createLapData(lapNum) {
        return { 
            lapNumber: lapNum, 
            lapTime: 0, 
            data: { 
                distance: [], speed: [], rpm: [], gear: [], throttle: [], brake: [], 
                steering: [], time: [], 
                rawLat: [], rawLon: [],
                mapX: [], mapY: [],
                brakeABSactive: [],
                fuelLevel: [],
                shockVelLF: [], shockVelRF: [], shockVelLR: [], shockVelRR: [],
                gForceLat: [], gForceLong: []
            },
            lapMetadata: { 
                isValidByFlag: true, 
                isOutlap: false,
                isInlap: false,
                isComplete: false,
                isFastestInFile: false,
                isConsideredValid: false 
            },
            avgSpeed: 0,
            maxSpeed: 0,
            fuelUsed: null
        };
    }
}


function updateSummary() {
    const el = document.getElementById('summary-container');
    if (!el) return;

    if (telemetryData.length === 0) {
        el.innerHTML = '<span style="color:#888;">No data loaded.</span>';
        return;
    }

    // Group laps by filename
    const byFile = {};
    telemetryData.forEach(lap => {
        if (!byFile[lap.filename]) byFile[lap.filename] = [];
        byFile[lap.filename].push(lap);
    });

    const blocks = [];

    Object.keys(byFile).forEach(filename => {
        const laps = byFile[filename];

        // Use first lap from this file for SessionInfo
        const firstLap = laps[0];
        const si = firstLap.sessionInfoStr || '';
        const info = parseSessionInfo(si);

        // Best valid lap in this file
        const bestLap = laps.reduce((best, l) =>
            (l.lapMetadata && l.lapMetadata.isConsideredValid && l.lapTime < best.lapTime ? l : best),
            { lapTime: Infinity }
        );

        const trackName   = info.trackName   || 'Unknown';
        const trackLength = info.trackLength || 'n/a';
        const sessionName = info.sessionName || 'n/a';

        const airTemp     = info.airTemp     || 'n/a';
        const trackTemp   = info.trackTemp   || 'n/a';
        const skies       = info.skies       || 'n/a';
        const wind        = info.windVel     || 'n/a';
        const humidity    = info.humidity    || 'n/a';

        const bestLapStr = bestLap.lapTime !== Infinity
            ? `L${bestLap.lapNumber} – ${formatTime(bestLap.lapTime)}`
            : 'n/a';

        blocks.push(`
            <div style="margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #333;">
                <div><strong>File:</strong> ${filename}</div>
                <div><strong>Track:</strong> ${trackName}</div>
                <div><strong>Length:</strong> ${trackLength}</div>
                <div><strong>Session:</strong> ${sessionName}</div>
                <div style="margin-top:4px;"><strong>Air Temp:</strong> ${airTemp}</div>
                <div><strong>Track Temp:</strong> ${trackTemp}</div>
                <div><strong>Skies:</strong> ${skies}</div>
                <div><strong>Wind:</strong> ${wind}</div>
                <div><strong>Humidity:</strong> ${humidity}</div>
                <div style="margin-top:4px;"><strong>Laps Loaded (this file):</strong> ${laps.length}</div>
                <div><strong>Best Lap (this file):</strong> ${bestLapStr}</div>
            </div>
        `);
    });

    el.innerHTML = blocks.join('');
}


        // --- Application Logic ---
        function updateStatus(msg, type) {
            const el = document.getElementById('status-container');
            el.innerHTML = `<div class="status ${type}">${msg}</div>`;
        }

        // Helper function to get sector time for a specific lap and sector definition
        const getSectorTimeForLap = (lap, sectorStartDistance, sectorEndDistance) => {
            if (!lap || !lap.data || lap.data.distance.length === 0) return 0;

            let sIdx = lap.data.distance.findIndex(d => d >= sectorStartDistance);
            if (sIdx === -1) sIdx = 0; 
            
            let eIdx = lap.data.distance.findIndex(d => d >= sectorEndDistance);

            if (eIdx === -1 || eIdx <= sIdx) { 
                return 0; 
            }
            
            return lap.data.time[eIdx] - lap.data.time[sIdx];
        };

function parseSessionInfo(sessionInfoStr) {
    if (!sessionInfoStr) return {};

    // Helper to get the first regex group match or null (case-insensitive)
    function match(re) {
        const m = sessionInfoStr.match(re);
        return m && m[1] ? m[1].trim() : null;
    }

    const info = {};

    // Track info (try several common keys)
    info.trackName =
        match(/TrackDisplayName:\s*([^\r\n]+)/i) ||
        match(/TrackName:\s*([^\r\n]+)/i);

    info.trackLength =
        match(/TrackLength:\s*([^\r\n]+)/i);

    info.sessionName =
        match(/SessionName:\s*([^\r\n]+)/i) ||
        match(/SessionType:\s*([^\r\n]+)/i);

    info.sessionTimeOfDay =
        match(/SessionTimeOfDay:\s*([^\r\n]+)/i);

    // Weather – prefer *Crew variants, then fall back
    info.airTemp =
        match(/AirTempCrew:\s*([^\r\n]+)/i) ||
        match(/AirTemp:\s*([^\r\n]+)/i);

    info.trackTemp =
        match(/TrackTempCrew:\s*([^\r\n]+)/i) ||
        match(/TrackTemp:\s*([^\r\n]+)/i);

    info.skies =
        match(/Skies:\s*([^\r\n]+)/i);

    info.windVel =
        match(/WindVel:\s*([^\r\n]+)/i) ||
        match(/WindSpeed:\s*([^\r\n]+)/i);

    info.humidity =
        match(/RelativeHumidity:\s*([^\r\n]+)/i) ||
        match(/Humidity:\s*([^\r\n]+)/i);

    return info;
}




        // Handle Multiple Files
        document.getElementById('file-import').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            updateStatus(`Reading ${files.length} file(s)...`, 'info');
            
            telemetryData = []; 
            defaultVisibleLapIds.clear(); 
            lastHoveredMapCoords = null; 

            // NEW: Clear zoom history on new file import
            zoomHistory = []; 

            let allRawLaps = []; 

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const buffer = await file.arrayBuffer();
                    const parser = new IBTParser(buffer);
const parsedData = parser.parse();
const sessionInfoStr = parsedData.sessionInfoStr || '';

parsedData.laps.forEach(lap => {
    lap.filename = file.name;
    const dotIndex = file.name.lastIndexOf('.');
    lap.filenameWithoutExt = dotIndex > 0 ? file.name.substring(0, dotIndex) : file.name;
    lap.sessionInfoStr = sessionInfoStr; // attach SessionInfo to each lap from this file
    allRawLaps.push(lap);
});


                } catch (err) { 
                    console.error(`Error parsing ${file.name}:`, err); 
                    updateStatus(`Error parsing ${file.name}`, 'error'); 
                }
            }

            if (allRawLaps.length === 0) {
                updateStatus('No laps found in imported files.', 'error');
                updateLapList();
                updateCharts();
                return;
            }

            // --- GLOBAL MAP COORDINATE CALCULATION ---
            const EARTH_RADIUS = 6371000; 
            let globalOriginLat = null;
            let globalOriginLon = null;

            for (const lap of allRawLaps) {
                for (let i = 0; i < lap.data.rawLat.length; i++) {
                    if (lap.data.rawLat[i] !== 0 && lap.data.rawLon[i] !== 0) {
                        globalOriginLat = lap.data.rawLat[i];
                        globalOriginLon = lap.data.rawLon[i];
                        break;
                    }
                }
                if (globalOriginLat !== null) break;
            }
            
            // Calculate mapX and mapY for all laps using the global origin
            allRawLaps.forEach(lap => {
                lap.data.mapX = [];
                lap.data.mapY = [];
                for (let i = 0; i < lap.data.rawLat.length; i++) {
                    const lat = lap.data.rawLat[i];
                    const lon = lap.data.rawLon[i];
                    
                    let x = 0, y = 0;
                    if (globalOriginLat !== null) { 
                        x = (lon - globalOriginLon) * (Math.PI/180) * EARTH_RADIUS * Math.cos(globalOriginLat * Math.PI/180);
                        y = (lat - globalOriginLat) * (Math.PI/180) * EARTH_RADIUS;
                    }
                    lap.data.mapX.push(x);
                    lap.data.mapY.push(y);
                }
                delete lap.data.rawLat;
                delete lap.data.rawLon;
            });
            // --- END GLOBAL MAP COORDINATE CALCULATION ---

            const lapsByFilename = {};
            allRawLaps.forEach((lap, index) => {
                lap.id = index; 
                lap.color = defaultColors[index % defaultColors.length]; 
                if (!lapsByFilename[lap.filename]) {
                    lapsByFilename[lap.filename] = [];
                }
                lapsByFilename[lap.filename].push(lap);
                telemetryData.push(lap); 
            });

            // ADDED: Calculate average speed, max speed, and fuel used for each lap
            telemetryData.forEach(lap => {
                // Calculate average and max speed
                if (lap.data.speed.length > 0) {
                    lap.avgSpeed = lap.data.speed.reduce((sum, s) => sum + s, 0) / lap.data.speed.length;
                    lap.maxSpeed = Math.max(...lap.data.speed);
                } else {
                    lap.avgSpeed = 0;
                    lap.maxSpeed = 0;
                }

                // Calculate fuel used (if data is available and meaningful)
                if (lap.data.fuelLevel && lap.data.fuelLevel.length > 1) {
                    const startFuel = lap.data.fuelLevel[0];
                    const endFuel = lap.data.fuelLevel[lap.data.fuelLevel.length - 1];
                    // Only calculate if fuel is actually consumed (fuel level decreased)
                    if (startFuel > endFuel) {
                        lap.fuelUsed = startFuel - endFuel;
                    } else {
                        lap.fuelUsed = null; // No meaningful consumption or bad data
                    }
                } else {
                    lap.fuelUsed = null; // No fuel level data available
                }
            });


            let maxTrackDistance = 0;
            telemetryData.forEach(lap => {
                if (lap.lapMetadata.isValidByFlag && lap.data.distance.length > 100 && lap.lapTime > MIN_VALID_LAP_TIME) { 
                    maxTrackDistance = Math.max(maxTrackDistance, lap.data.distance[lap.data.distance.length - 1]);
                }
            });
            if (maxTrackDistance < 100) maxTrackDistance = 1000;

            const firstSectorEndDistance = maxTrackDistance / 3;

            telemetryData.forEach(lap => {
                const isFullDistance = lap.data.distance.length > 100 && lap.data.distance[lap.data.distance.length - 1] > (maxTrackDistance * 0.9);
                const firstSectorTime = getSectorTimeForLap(lap, 0, firstSectorEndDistance);
                lap.lapMetadata.isComplete = isFullDistance && (firstSectorTime > 0.5); 
            });

            for (const filename in lapsByFilename) {
                const fileLaps = lapsByFilename[filename].sort((a, b) => a.lapNumber - b.lapNumber);
                if (fileLaps.length > 0) {
                    fileLaps[0].lapMetadata.isOutlap = !fileLaps[0].lapMetadata.isComplete || fileLaps[0].lapTime < MIN_VALID_LAP_TIME;
                    if (fileLaps.length > 1) { 
                         fileLaps[fileLaps.length - 1].lapMetadata.isInlap = !fileLaps[fileLaps.length - 1].lapMetadata.isComplete || fileLaps[fileLaps.length - 1].lapTime < MIN_VALID_LAP_TIME;
                    }
                }
            }

            telemetryData.forEach(lap => {
                lap.lapMetadata.isConsideredValid = 
                    lap.lapTime >= MIN_VALID_LAP_TIME &&
                    lap.lapMetadata.isComplete &&
                    !lap.lapMetadata.isOutlap &&
                    !lap.lapMetadata.isInlap &&
                    lap.lapMetadata.isValidByFlag;
            });

            const lap11 = telemetryData.find(l => l.lapNumber === 11);
            if (lap11) {
                console.log(`[DEBUG_VALIDITY] Lap 11 (ID: ${lap11.id}) - isConsideredValid: ${lap11.lapMetadata.isConsideredValid}`);
                console.log(`[DEBUG_VALIDITY]   isComplete: ${lap11.lapMetadata.isComplete}`);
                console.log(`[DEBUG_VALIDITY]   isOutlap: ${lap11.lapMetadata.isOutlap}`);
                console.log(`[DEBUG_VALIDITY]   isInlap: ${lap11.lapMetadata.isInlap}`);
                console.log(`[DEBUG_VALIDITY]   isValidByFlag: ${lap11.lapMetadata.isValidByFlag}`);
                console.log(`[DEBUG_VALIDITY]   lapTime: ${lap11.lapTime}, distance.length: ${lap11.data.distance.length}`);

                // Also check maxTrackDistance which influences isComplete
                let currentMaxTrackDistance = 0;
                telemetryData.forEach(l => {
                    if (l.lapMetadata.isValidByFlag && l.data.distance.length > 100 && l.lapTime > MIN_VALID_LAP_TIME) {
                        currentMaxTrackDistance = Math.max(currentMaxTrackDistance, l.data.distance[l.data.distance.length - 1]);
                    }
                });
                console.log(`[DEBUG_VALIDITY]   Calculated maxTrackDistance (influencing isComplete): ${currentMaxTrackDistance}`);
                const isFullDistanceCheck = lap11.data.distance.length > 100 && lap11.data.distance[lap11.data.distance.length - 1] > (currentMaxTrackDistance * 0.9);
                console.log(`[DEBUG_VALIDITY]   isFullDistance check for Lap 11: ${isFullDistanceCheck}`);
            }


            let fastestOverallValidLap = null;

            for (const filename in lapsByFilename) {
                const validCandidateLapsInFile = lapsByFilename[filename].filter(l => l.lapMetadata.isConsideredValid);
                
                if (validCandidateLapsInFile.length > 0) {
                    const fastestInFile = validCandidateLapsInFile.reduce((prev, curr) => 
                        (curr.lapTime < prev.lapTime ? curr : prev),
                        { lapTime: Infinity }); 

                    if (fastestInFile.lapTime !== Infinity) { 
                        fastestInFile.lapMetadata.isFastestInFile = true; 
                        defaultVisibleLapIds.add(fastestInFile.id); 
                        if (!fastestOverallValidLap || fastestInFile.lapTime < fastestOverallValidLap.lapTime) {
                            fastestOverallValidLap = fastestInFile;
                        }
                    }
                }
            }
            
            referenceLapId = fastestOverallValidLap ? fastestOverallValidLap.id : null;

updateLapList(); 
updateStatus(`Loaded ${telemetryData.length} laps from ${files.length} files.`, 'success');

defaultVisibleLapIds.forEach(lapId => {
    const checkbox = document.querySelector(`#lap-selector input[type="checkbox"][value="${lapId}"]`);
    if (checkbox) checkbox.checked = true; 
});

updateCharts(); 
saveCurrentMasterZoom();
updateSummary();

        });

        function formatTime(seconds) {
            if(!seconds || isNaN(seconds) || seconds === Infinity) return "--:--.--";
            const m = Math.floor(seconds / 60);
            const s = (seconds % 60).toFixed(3);
            return `${m}:${s.padStart(6, '0')}`;
        }

        function updateLapList() {
            const container = document.getElementById('lap-selector');
            container.innerHTML = '';
            if (telemetryData.length === 0) {
                container.innerHTML = '<p style="color: #888; font-style: italic;">No laps loaded.</p>';
                return;
            }

            telemetryData.forEach((lap) => {
                const isRef = lap.id === referenceLapId;
                const isChecked = defaultVisibleLapIds.has(lap.id); 
                
                let statusHtml = '';
                if (!lap.lapMetadata.isValidByFlag) {
                    statusHtml += '<span class="invalid" title="Lap flagged as invalid by iRacing (e.g., track cut).">INVALID</span>';
                } else if (lap.lapMetadata.isOutlap) {
                    statusHtml += '<span class="outin" title="Outlap (first lap in session/file, likely incomplete or slow).">OUT</span>';
                } else if (lap.lapMetadata.isInlap) {
                    statusHtml += '<span class="outin" title="Inlap (last lap in session/file, likely incomplete or slow).">IN</span>';
                } else if (!lap.lapMetadata.isComplete) {
                    statusHtml += '<span class="invalid" title="Lap did not cover the full track distance or did not record a meaningful first sector.">INCOMPLETE</span>';
                } else if (lap.lapMetadata.isFastestInFile) {
                    statusHtml += '<span class="complete" title="Fastest valid and complete lap in this file.">FASTEST</span>';
                } else if (lap.lapTime < MIN_VALID_LAP_TIME) {
                    statusHtml += '<span class="invalid" title="Lap is too short to be considered valid.">SHORT</span>';
                }

                const div = document.createElement('div');
                div.className = `lap-item ${isRef ? 'is-reference' : ''}`;
                div.innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:2px; margin-right:8px;">
                        <input type="checkbox" value="${lap.id}" onchange="toggleLapVisibility(${lap.id}, this.checked)" ${isChecked ? 'checked' : ''}>
                        <input type="radio" name="refLap" class="ref-radio" value="${lap.id}" title="Set as Reference Lap" onchange="setReferenceLap(${lap.id})" ${isRef ? 'checked' : ''}>
                    </div>
                    <div style="flex-grow:1; cursor:pointer;" onclick="toggleLapVisibility(${lap.id}, !document.querySelector('#lap-selector input[type=&quot;checkbox&quot;][value=&quot;${lap.id}&quot;]').checked)">
                        <span class="lap-file-label" title="${lap.filename}">${lap.filename}</span>
                        <div>Lap ${lap.lapNumber} - ${formatTime(lap.lapTime)}</div>
                        <div style="font-size: 0.75em; color: #aaa; display: flex; gap: 8px; justify-content: space-between; margin-top: 2px;">
                            <span>Fuel: ${lap.fuelUsed !== null ? lap.fuelUsed.toFixed(2) + 'L' : 'N/A'}</span>
                            <span>Avg Spd: ${lap.avgSpeed.toFixed(1)}kph</span>
                            <span>Max Spd: ${lap.maxSpeed.toFixed(1)}kph</span>
                        </div>
                        <div class="lap-status">${statusHtml}</div>
                    </div>
                    <input type="color" value="${lap.color}" onchange="updateLapColor(${lap.id}, this.value)">
                `;
                container.appendChild(div);
            });
        }

        function toggleLapVisibility(id, isChecked) {
            if (isChecked) {
                defaultVisibleLapIds.add(id);
            } else {
                defaultVisibleLapIds.delete(id);
                if (referenceLapId === id) {
                    referenceLapId = null;
                }
            }
            updateLapList(); 
            updateCharts();
        }

        function setReferenceLap(id) {
            referenceLapId = id;
            defaultVisibleLapIds.add(id); 
            updateLapList(); 
            const checkbox = document.querySelector(`input[type="checkbox"][value="${id}"]`);
            if (checkbox) checkbox.checked = true; 
            updateCharts();
        }

        function updateLapColor(id, color) {
            const lap = telemetryData.find(l => l.id === id);
            if (lap) { lap.color = color; updateCharts(); }
        }

        // --- Calculation Logic ---
        
        function calculateTimeDelta(targetLap, refLap) {
            if (!targetLap || !refLap) return [];
            
            const refStart = refLap.data.time[0];
            const targetStart = targetLap.data.time[0];
            
            const deltas = refLap.data.distance.map((dist, i) => {
                const refElapsed = refLap.data.time[i] - refStart;
                
                let idx = -1;
                let minDiff = Infinity;
                
                const proportionalGuess = Math.floor((i / refLap.data.distance.length) * targetLap.data.distance.length);
                const searchWindow = 100; 
                
                const startSearchIdx = Math.max(0, proportionalGuess - searchWindow); 
                const endSearchIdx = Math.min(targetLap.data.distance.length, proportionalGuess + searchWindow);

                for(let k = startSearchIdx; k < endSearchIdx; k++) {
                    const dDiff = Math.abs(targetLap.data.distance[k] - dist);
                    if(dDiff < minDiff) { 
                        minDiff = dDiff; 
                        idx = k; 
                    }
                }
                if (idx > -1) {
                    const targetElapsed = targetLap.data.time[idx] - targetStart;
                    return targetElapsed - refElapsed; 
                } else {
                    return 0; 
                }
            });
            
            return deltas;
        }

        function calculateSectors(selectedLaps, refLap) {
            if (!refLap) return { analysis: [], definitions: [], targetLap: null };

            const targetLap = selectedLaps.find(l => l.id !== refLap.id);

            const maxDist = refLap.data.distance[refLap.data.distance.length - 1];
            const sectorSize = maxDist / 3;
            const sectorDefinitions = [
                { id: 1, start: 0, end: sectorSize },
                { id: 2, start: sectorSize, end: sectorSize * 2 },
                { id: 3, start: sectorSize * 2, end: maxDist }
            ];

            const analysis = [];

            const getSectorTime = (lap, def) => {
                let sIdx = lap.data.distance.findIndex(d => d >= def.start);
                let eIdx = lap.data.distance.findIndex(d => d >= def.end);

                if (sIdx === -1) sIdx = 0; 
                if (eIdx === -1 && lap.data.distance.length > 0) eIdx = lap.data.distance.length -1; 
                
                if (sIdx > -1 && eIdx > -1 && sIdx < eIdx) {
                    return lap.data.time[eIdx] - lap.data.time[sIdx];
                }
                return 0; 
            };

            sectorDefinitions.forEach(def => {
                const refTime = getSectorTime(refLap, def);
                
                let delta = 0;
                let isDiff = false;

                if (targetLap) {
                    const targetTime = getSectorTime(targetLap, def);
                    delta = targetTime - refTime; 
                    isDiff = true;
                }

                analysis.push({
                    id: def.id,
                    start: def.start,
                    end: def.end,
                    refTime: refTime,
                    delta: delta,
                    isDiff: isDiff
                });
            });

            return { analysis, definitions: sectorDefinitions, targetLap };
        }

        function updateSectorTable(sectorsData) {
            const tbody = document.getElementById('sector-body');
            tbody.innerHTML = '';
            
            const headerCell = document.querySelector('.sector-table th:last-child');
            headerCell.textContent = sectorsData.targetLap 
                ? `Delta (vs L${sectorsData.targetLap.lapNumber})` 
                : "Delta (vs Ref)";
            headerCell.title = sectorsData.targetLap ? `Comparing to Lap ${sectorsData.targetLap.lapNumber} from ${sectorsData.targetLap.filename}` : 'No comparison lap selected';

            sectorsData.analysis.forEach(sec => {
                const tr = document.createElement('tr');
                
                let deltaHtml = '<span style="color:#666">-</span>';
                if (sec.isDiff) {
                    let color = '#ccc'; 
                    if (sec.delta > 0.005) color = '#dc3545';
                    else if (sec.delta < -0.005) color = '#28a745';
                    
                    const sign = sec.delta > 0 ? '+' : '';
                    deltaHtml = `<span style="color:${color}">${sign}${sec.delta.toFixed(3)}</span>`;
                } else if (sec.refTime > 0) {
                    deltaHtml = '<span style="color:#888; font-style:italic">Ref</span>'; 
                }

                tr.innerHTML = `
                    <td>S${sec.id}</td>
                    <td>${sec.refTime > 0 ? sec.refTime.toFixed(3) : '--.---'}</td>
                    <td>${deltaHtml}</td>
                `;
                
                tr.addEventListener('click', () => { 
                    zoomToSector(sec.start, sec.end); 
                });
                
                tbody.appendChild(tr);
            });
        }

        function zoomToSector(start, end) {
            const masterChart = charts.delta;
            if (!masterChart || !masterChart.options.scales || !masterChart.options.scales.x) return;

            masterChart.options.scales.x.min = start;
            masterChart.options.scales.x.max = end;
            masterChart.update('none');

            syncScales(masterChart);
        }

        // --- Placemat helpers ---

        // Compute a few simple driving metrics for a lap over a distance window
        function computeLapSectorMetrics(lap, startDist, endDist) {
            if (!lap || !lap.data || !lap.data.distance.length) {
                return null;
            }

            const d   = lap.data.distance;
            const t   = lap.data.time;
            const spd = lap.data.speed;
            const thr = lap.data.throttle;
            const brk = lap.data.brake;
            const abs = lap.data.brakeABSactive || [];

            const idxs = [];
            for (let i = 0; i < d.length; i++) {
                if (d[i] >= startDist && d[i] <= endDist) idxs.push(i);
            }
            if (idxs.length === 0) return null;

            const firstIdx = idxs[0];
            const lastIdx  = idxs[idxs.length - 1];

            const tStart = t[firstIdx];
            const tEnd   = t[lastIdx];
            const sectorTime = tEnd - tStart;

            let minSpeed = Infinity, maxSpeed = -Infinity, sumSpeed = 0;
            let maxBrake = 0, maxThrottle = 0, sumThrottle = 0;

            // ABS time accumulation
            let absTime = 0;
            for (let i = 0; i < idxs.length - 1; i++) {
                const i0 = idxs[i];
                const i1 = idxs[i + 1];

                const s  = spd[i0];
                const th = thr[i0];
                const bk = brk[i0];

                if (s < minSpeed) minSpeed = s;
                if (s > maxSpeed) maxSpeed = s;
                sumSpeed += s;

                if (bk > maxBrake) maxBrake = bk;
                if (th > maxThrottle) maxThrottle = th;
                sumThrottle += th;

                if (abs[i0] > 0) {
                    absTime += (t[i1] - t[i0]);
                }
            }

            const avgSpeed    = sumSpeed / idxs.length;
            const avgThrottle = sumThrottle / idxs.length;

            let brakePointDist = null;
            for (let i of idxs) {
                if (brk[i] > 10) {
                    brakePointDist = d[i];
                    break;
                }
            }

            return {
                sectorTime,
                minSpeed,
                maxSpeed,
                avgSpeed,
                maxBrake,
                avgThrottle,
                brakePointDist,
                absTime   // seconds in ABS in this sector
            };
        }


        // Build two side-by-side SVG track maps (Ref left, Compare right),
        // showing ABS zones and yellow X at sector min-speed points
        function buildTwoTrackMapsSvg(refLap, compareLap, definitions) {
            if (!refLap || !refLap.data || !refLap.data.mapX.length) return '';

            const laps = [refLap, compareLap].filter(Boolean);

            // Shared bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            laps.forEach(lap => {
                lap.data.mapX.forEach(x => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                });
                lap.data.mapY.forEach(y => {
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                });
            });
            if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) {
                return '';
            }

            const width  = maxX - minX || 1;
            const height = maxY - minY || 1;

            function toSvgX(x) { return ((x - minX) / width) * 1000; }
            function toSvgY(y) { return (1 - (y - minY) / height) * 700; } // 1000x700

            function buildSingleSvg(lap, title, absColor, lineColor) {
                if (!lap) {
                    return `<div style="flex:1;padding:4px;box-sizing:border-box;">
<p style="font-size:11px;">Not available</p>
</div>`;
                }

                let svg = `<div style="flex:1;padding:4px;box-sizing:border-box;">
<h3 style="margin:4px 0;font-size:13px;font-weight:bold;">${title}</h3>
<svg class="placemat-svg-map two-maps-svg" viewBox="0 0 1000 700" xmlns="http://www.w3.org/2000/svg"
      style="width:100%;border:1px solid #444;background:#ffffff;">` 

                const dists = lap.data.distance;
                const xs    = lap.data.mapX;
                const ys    = lap.data.mapY;
                const abs   = lap.data.brakeABSactive || [];
                const times = lap.data.time || [];
                const speeds = lap.data.speed || [];

                // --- ABS segments (with gap check) ---
                if (dists.length && abs.length) {
                    let inSeg = false;
                    let segPoints = [];
                    let lastIdx = -1;

                    const MAX_DIST_GAP = 30;   // m
                    const MAX_TIME_GAP = 1.0;  // s

                    function flushSeg() {
                        if (segPoints.length < 2) return;
                        const pathData = segPoints.map((p, i) =>
                            (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ' ' + p.y.toFixed(1)
                        ).join(' ');
                        svg += `<path d="${pathData}" stroke="${absColor}"
                                 stroke-width="18" stroke-linecap="round" stroke-linejoin="round"
                                 fill="none" opacity="0.85"/>`;
                        segPoints = [];
                    }

                    for (let i = 0; i < dists.length; i++) {
                        const active = abs[i] > 0;
                        const px = toSvgX(xs[i]);
                        const py = toSvgY(ys[i]);

                        if (active) {
                            if (inSeg && lastIdx >= 0) {
                                const distGap = Math.abs(dists[i] - dists[lastIdx]);
                                const timeGap = (times.length > i && times.length > lastIdx)
                                    ? Math.abs(times[i] - times[lastIdx])
                                    : 0;
                                if (distGap > MAX_DIST_GAP || timeGap > MAX_TIME_GAP) {
                                    flushSeg();
                                    segPoints = [];
                                }
                            }
                            if (!inSeg) inSeg = true;
                            segPoints.push({ x: px, y: py });
                            lastIdx = i;
                        } else {
                            if (inSeg) {
                                inSeg = false;
                                flushSeg();
                                segPoints = [];
                                lastIdx = -1;
                            }
                        }
                    }
                    if (inSeg) flushSeg();
                }

                // --- Racing line ---
                if (xs.length) {
                    const pathData = xs.map((x, i) => {
                        const sx = toSvgX(x).toFixed(1);
                        const sy = toSvgY(ys[i]).toFixed(1);
                        return (i === 0 ? 'M' : 'L') + sx + ' ' + sy;
                    }).join(' ');

                    svg += `<path d="${pathData}" stroke="${lineColor}" stroke-width="4"
                             fill="none" stroke-linecap="round" stroke-linejoin="round"
                             opacity="0.9"/>`;
                }

                // --- Yellow X markers at sector min-speed points ---
                if (definitions && Array.isArray(definitions) && dists.length && speeds.length) {
                    definitions.forEach(def => {
                        const start = def.start;
                        const end   = def.end;

                        let minSpd = Infinity;
                        let minIdx = -1;

                        for (let i = 0; i < dists.length; i++) {
                            const dist = dists[i];
                            if (dist < start || dist > end) continue;
                            const s = speeds[i];
                            if (s < minSpd) {
                                minSpd = s;
                                minIdx = i;
                            }
                        }

                        if (minIdx >= 0) {
                            const px = toSvgX(xs[minIdx]);
                            const py = toSvgY(ys[minIdx]);

                            const size = 20; // pixels in SVG units
                            svg += `
<line x1="${(px - size).toFixed(1)}" y1="${(py - size).toFixed(1)}"
      x2="${(px + size).toFixed(1)}" y2="${(py + size).toFixed(1)}"
      stroke="#ffcc00" stroke-width="6" stroke-linecap="round"/>
<line x1="${(px - size).toFixed(1)}" y1="${(py + size).toFixed(1)}"
      x2="${(px + size).toFixed(1)}" y2="${(py - size).toFixed(1)}"
      stroke="#ffcc00" stroke-width="6" stroke-linecap="round"/>`;
                        }
                    });
                }

                // Mini legend
                svg += `
<rect x="20" y="20" width="26" height="6" fill="${lineColor}" />
<text x="55" y="26" font-size="18" fill="#000000">Line</text>
<rect x="20" y="44" width="26" height="6" fill="${absColor}" />
<text x="55" y="50" font-size="18" fill="#000000">ABS</text>
<rect x="20" y="68" width="26" height="6" fill="#ffcc00" />
<text x="55" y="74" font-size="18" fill="#000000">Corner Min Speed</text>`;

                svg += `</svg></div>`;
                return svg;
            }

            const refTitle = 'Ref L' + refLap.lapNumber + ' ' + (refLap.filenameWithoutExt || '');
            const cmpTitle = compareLap
                ? 'Lap L' + compareLap.lapNumber + ' ' + (compareLap.filenameWithoutExt || '')
                : 'Comparison';

            const cmpColor = (compareLap && compareLap.color) ? compareLap.color : '#777777';

            const refSvg = buildSingleSvg(refLap, refTitle, '#0066ff', '#222222');
            const cmpSvg = buildSingleSvg(compareLap, cmpTitle, '#ff0000', cmpColor);

            return `<div style="display:flex;gap:8px;align-items:flex-start;" class="two-maps">
${refSvg}
${cmpSvg}
</div>`;
        }


function buildOverlayTrackMapSvg(refLap, compareLap, definitions) {
    if (!refLap || !refLap.data || !refLap.data.mapX.length || !compareLap) return '';

    const laps = [refLap, compareLap];

    // Shared bounds
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    laps.forEach(lap => {
        lap.data.mapX.forEach(x => {
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
        });
        lap.data.mapY.forEach(y => {
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
        });
    });
    if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) {
        return '';
    }

    const width  = maxX - minX || 1;
    const height = maxY - minY || 1;

    function toSvgX(x) { return ((x - minX) / width) * 1000; }
    function toSvgY(y) { return (1 - (y - minY) / height) * 700; } // 1000x700

    let svg = `<svg class="placemat-svg-map overlay-map-svg" viewBox="0 0 1000 700" xmlns="http://www.w3.org/2000/svg"
      style="width:100%;border:1px solid #444;background:#ffffff;">`

    // Helper: ABS with gap check
    function drawAbsSegments(lap, absColor, opacity, offset = 0) {
        const dists = lap.data.distance;
        const xs    = lap.data.mapX;
        const ys    = lap.data.mapY;
        const abs   = lap.data.brakeABSactive || [];
        const times = lap.data.time || [];

        if (!dists.length || !abs.length) return;

        let inSeg = false;
        let segPoints = [];
        let lastIdx = -1;
        const MAX_DIST_GAP = 30;   // m
        const MAX_TIME_GAP = 1.0;  // s

        function flushSeg() {
            if (segPoints.length < 2) return;
            const pathData = segPoints.map((p, i) =>
                (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ' ' + p.y.toFixed(1)
            ).join(' ');
            svg += `<path d="${pathData}" stroke="${absColor}"
                     stroke-width="22" stroke-linecap="round" stroke-linejoin="round"
                     fill="none" opacity="${opacity}"/>`;
            segPoints = [];
        }

        for (let i = 0; i < dists.length; i++) {
            const active = abs[i] > 0;
            const px = toSvgX(xs[i]) + offset;  // Apply offset here
            const py = toSvgY(ys[i]);

            if (active) {
                if (inSeg && lastIdx >= 0) {
                    const distGap = Math.abs(dists[i] - dists[lastIdx]);
                    const timeGap = (times.length > i && times.length > lastIdx)
                        ? Math.abs(times[i] - times[lastIdx])
                        : 0;
                    if (distGap > MAX_DIST_GAP || timeGap > MAX_TIME_GAP) {
                        flushSeg();
                        segPoints = [];
                    }
                }
                if (!inSeg) inSeg = true;
                segPoints.push({ x: px, y: py });
                lastIdx = i;
            } else {
                if (inSeg) {
                    inSeg = false;
                    flushSeg();
                    segPoints = [];
                    lastIdx = -1;
                }
            }
        }
        if (inSeg) flushSeg();
    }

    // Helper: racing line
    function drawLine(lap, stroke, width, opacity, offset = 0) {
        const xs = lap.data.mapX;
        const ys = lap.data.mapY;
        if (!xs.length) return;

        const pathData = xs.map((x, i) => {
            const sx = (toSvgX(x) + offset).toFixed(1);
            const sy = toSvgY(ys[i]).toFixed(1);
            return (i === 0 ? 'M' : 'L') + sx + ' ' + sy;
        }).join(' ');

        svg += `<path d="${pathData}" stroke="${stroke}" stroke-width="${width}"
                 fill="none" stroke-linecap="round" stroke-linejoin="round"
                 opacity="${opacity}"/>`;
    }

    // Helper: min-speed X markers per sector
    function drawMinSpeedXs(lap, definitions, color, offset = 0) {
        const dists  = lap.data.distance;
        const xs     = lap.data.mapX;
        const ys     = lap.data.mapY;
        const speeds = lap.data.speed || [];
        if (!definitions || !Array.isArray(definitions) || !dists.length || !speeds.length) return;

        definitions.forEach(def => {
            const start = def.start;
            const end   = def.end;

            let minSpd = Infinity;
            let minIdx = -1;

            for (let i = 0; i < dists.length; i++) {
                const dist = dists[i];
                if (dist < start || dist > end) continue;
                const s = speeds[i];
                if (s < minSpd) {
                    minSpd = s;
                    minIdx = i;
                }
            }

            if (minIdx >= 0) {
                const px = toSvgX(xs[minIdx]) + offset;
                const py = toSvgY(ys[minIdx]);
                const size = 20;

                svg += `
<line x1="${(px - size).toFixed(1)}" y1="${(py - size).toFixed(1)}"
      x2="${(px + size).toFixed(1)}" y2="${(py + size).toFixed(1)}"
      stroke="${color}" stroke-width="6" stroke-linecap="round"/>
<line x1="${(px - size).toFixed(1)}" y1="${(py + size).toFixed(1)}"
      x2="${(px + size).toFixed(1)}" y2="${(py - size).toFixed(1)}"
      stroke="${color}" stroke-width="6" stroke-linecap="round"/>`;
            }
        });
    }

    const refLineColor   = '#222222';
    const refAbsColor    = '#0066ff';
    const refMinSpeedCol = '#ffcc00';

    const cmpLineColor   = (compareLap && compareLap.color) ? compareLap.color : '#777777';
    const cmpAbsColor    = '#ff0000';
    const cmpMinSpeedCol = '#00cc66';

    // Draw in sensible z-order: lines first, then ABS, then markers
    drawLine(refLap, refLineColor, 4, 0.8, 0);  // Stacked with no offset
    drawLine(compareLap, cmpLineColor, 4, 0.8, 0);  // Stacked with no offset

    drawAbsSegments(refLap, refAbsColor, 0.65, -20);  // ABS offset left for reference
    drawAbsSegments(compareLap, cmpAbsColor, 0.65, +20);  // ABS offset right for compare

    drawMinSpeedXs(refLap, definitions, refMinSpeedCol, 0);  // Stacked if desired
    drawMinSpeedXs(compareLap, definitions, cmpMinSpeedCol, 0);  // Stacked if desired

    // Legend for Overlay Map
svg += `
<g style="font-size: 18px; fill: #000000; transform: translate(20px, 20px);">
    <rect width="26" height="6" fill="${refLineColor}" />
    <text x="35" y="6">Ref Line</text>
    <rect y="20" width="26" height="6" fill="${refAbsColor}" />
    <text x="35" y="26">Ref ABS</text>
    <rect y="40" width="26" height="6" fill="${refMinSpeedCol}" />
    <text x="35" y="46">Ref Min Speed Corner</text>

    <rect y="60" width="26" height="6" fill="${cmpLineColor}" />
    <text x="35" y="66">Compare Line</text>
    <rect y="80" width="26" height="6" fill="${cmpAbsColor}" />
    <text x="35" y="86">Compare ABS</text>
    <rect y="100" width="26" height="6" fill="${cmpMinSpeedCol}" />
    <text x="35" y="106">Compare Min Speed Corner</text>
</g>`;

    svg += `</svg>`;
    return svg;
}


        function openPlacematReport() {
            const selectedLaps = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
            const refLap = telemetryData.find(l => l.id === referenceLapId);

            if (!refLap || selectedLaps.length < 2) {
                alert("Select a reference lap and at least one comparison lap to print a placemat.");
                return;
            }

            const { definitions } = calculateSectors(selectedLaps, refLap);
            if (!definitions || definitions.length === 0) {
                alert("No sector information available.");
                return;
            }

            const compareLaps = selectedLaps.filter(l => l.id !== refLap.id);
            if (compareLaps.length === 0) {
                alert("No comparison laps selected (only the reference is visible).");
                return;
            }

            const metricsByLap = {};
            [refLap, ...compareLaps].forEach(lap => {
                const lapEntry = {};
                definitions.forEach(def => {
                    lapEntry[def.id] = computeLapSectorMetrics(lap, def.start, def.end);
                });
                metricsByLap[lap.id] = lapEntry;
            });

            let html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Placemat Report</title>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; color: #000; }
    h1, h2 { margin-bottom: 5px; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 12px; font-size: 12px; }
    th, td { border: 1px solid #888; padding: 4px 6px; text-align: center; }
    th { background:#eee; }
    .faster { color: #0a0; font-weight:bold; }
    .slower { color: #c00; font-weight:bold; }
    .small { font-size: 11px; color:#555; }
    
    /* Base styles for all SVG maps (screen display) */
    .placemat-svg-map {
        width: 100%;
        height: auto; /* Let viewBox manage aspect ratio by default */
        max-width: 100%;
        display: block; /* Prevents extra space below SVG */
    }
    .placemat-svg-map.two-maps-svg { height: 50vh; max-height: 50vh; }
    .placemat-svg-map.overlay-map-svg { height: 85vh; max-height: 85vh; }
    .map-container { margin-top: 6px; } /* Apply general margin to map containers */

@media print {
  body { margin: 5mm; }

  /* Keep tables and the adjacent two-maps block together */
  table,
  .two-maps,
  .map-container {
    page-break-inside: avoid !important;
    break-inside: avoid !important;
  }

  /* Fixed printed heights for SVG maps */
  .placemat-svg-map.two-maps-svg {
    height: 12.0cm !important;
    max-height: 12.0cm !important;
    display: block !important;
  }
  .placemat-svg-map.overlay-map-svg {
    height: 18.0cm !important;
    max-height: 18.0cm !important;
    display: block !important;
  }

  /* Ensure lap-block content (table + two-maps) stays together and occupies its page */
  .lap-block {
    display: block !important;
    page-break-inside: avoid !important;
    break-inside: avoid !important;
    page-break-after: auto !important;
    break-after: auto !important;
    clear: both !important;
    box-sizing: border-box !important;
    margin: 0 !important;
    padding: 0 !important;
    min-height: 11.5cm !important;
  }

  /* Force overlay to begin on the next page and avoid splitting */
  .overlay-block {
    display: block !important;
    page-break-before: always !important;
    break-before: page !important;
    page-break-inside: avoid !important;
    break-inside: avoid !important;
    clear: both !important;
    margin: 0 !important;
    padding: 0 !important;
  }

  /* Tidy margins so content doesn't float up */
  .lap-block,
  .overlay-block,
  .map-container {
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    padding-bottom: 0 !important;
  }
}
</style>


</head>
<body>
<h1>Placemat – Driving Differences</h1>
<p class="small">
Reference: L${refLap.lapNumber} (${refLap.filenameWithoutExt}) – ${formatTime(refLap.lapTime)}
</p>
`;

            compareLaps.forEach(lap => {
                const mapsHtml = buildTwoTrackMapsSvg(refLap, lap, definitions);

                html += `<div class="lap-block">`;

                html += `<h2>Compare Lap L${lap.lapNumber} (${lap.filenameWithoutExt}) – ${formatTime(lap.lapTime)}</h2>`;
                html += `
<table>
    <thead>
        <tr>
            <th>Sector</th>
            <th>Δ Time (s)</th>
            <th>Ref Time</th>
            <th>Lap Time</th>
            <th>Min Speed (km/h)</th>
            <th>Δ Min Speed</th>
            <th>Avg Speed (km/h)</th>
            <th>Max Brake (%)</th>
            <th>ABS Time Ref (s)</th>
            <th>ABS Time Lap (s)</th>
            <th>Δ ABS Time (s)</th>
            <th>Brake Point (m from S start)</th>
        </tr>
    </thead>
    <tbody>
`;

                definitions.forEach(def => {
                    const refM = metricsByLap[refLap.id][def.id];
                    const lapM = metricsByLap[lap.id][def.id];

                    let sectorDelta = 0;
                    if (refM && lapM) sectorDelta = lapM.sectorTime - refM.sectorTime;

                    const cls = sectorDelta < -0.01 ? 'faster' : (sectorDelta > 0.01 ? 'slower' : '');

                    const refTime = refM ? refM.sectorTime.toFixed(3) : '--';
                    const lapTime = lapM ? lapM.sectorTime.toFixed(3) : '--';

                    const refMinSpd = refM ? refM.minSpeed.toFixed(1) : '--';
                    const lapMinSpd = lapM ? lapM.minSpeed.toFixed(1) : '--';
                    const dMinSpd = (refM && lapM) ? (lapM.minSpeed - refM.minSpeed).toFixed(1) : '--';

                    const avgSpd  = lapM ? lapM.avgSpeed.toFixed(1) : '--';
                    const maxBrake = lapM ? lapM.maxBrake.toFixed(0) : '--';

                    const refAbsTime = refM ? refM.absTime.toFixed(3) : '--';
                    const lapAbsTime = lapM ? lapM.absTime.toFixed(3) : '--';
                    let dAbsTime = '--';
                    if (refM && lapM) {
                        const diff = lapM.absTime - refM.absTime;
                        dAbsTime = (diff >= 0 ? '+' : '') + diff.toFixed(3);
                    }

                    let brakePointRef = refM && refM.brakePointDist != null ? (refM.brakePointDist - def.start).toFixed(1) : '--';
                    let brakePointLap = lapM && lapM.brakePointDist != null ? (lapM.brakePointDist - def.start).toFixed(1) : '--';

                    let brakePointText = '--';
                    if (brakePointRef !== '--' && brakePointLap !== '--') {
                        const diff = (parseFloat(brakePointLap) - parseFloat(brakePointRef)).toFixed(1);
                        const sign = diff > 0 ? '+' : '';
                        brakePointText = `${brakePointLap} (${sign}${diff})`;
                    } else if (brakePointLap !== '--') {
                        brakePointText = brakePointLap;
                    }

                    html += `
        <tr>
            <td>S${def.id}</td>
            <td class="${cls}">${sectorDelta >= 0 ? '+' : ''}${sectorDelta.toFixed(3)}</td>
            <td>${refTime}</td>
            <td>${lapTime}</td>
            <td>${lapMinSpd} / ${refMinSpd}</td>
            <td>${dMinSpd}</td>
            <td>${avgSpd}</td>
            <td>${maxBrake}</td>
            <td>${refAbsTime}</td>
            <td>${lapAbsTime}</td>
            <td>${dAbsTime}</td>
            <td>${brakePointText}</td>
        </tr>`;
                });

                html += `
    </tbody>
</table>
<div class="map-container">
${mapsHtml || '<p class="small">Track maps not available.</p>'}
</div>
</div>`; // end lap-block

                // add full-page overlay map for this comparison lap
                const overlayHtml = buildOverlayTrackMapSvg(refLap, lap, definitions);
                html += `
<div class="overlay-block">
  <h2>Overlay Map – Ref vs L${lap.lapNumber} (${lap.filenameWithoutExt})</h2>
  <div class="map-container overlay-map-wrapper">
    ${overlayHtml || '<p class="small">Overlay track map not available.</p>'}
  </div>
</div>
`;

            });

            html += `
</body>
</html>`;

            const win = window.open('', '_blank');
            if (win) {
                win.document.open();
                win.document.write(html);
                win.document.close();
                setTimeout(() => { win.print(); }, 100);
            } else {
                alert("Popup blocked – allow popups to print the placemat.");
            }
        }


        // --- Chart Zoom History ---
        let zoomHistory = [];
        const MAX_ZOOM_HISTORY_DEPTH = 10;

        function saveCurrentMasterZoom() {
            const chart = charts.delta;
            if (!chart || !chart.scales || !chart.scales.x) return;

            const scale = chart.scales.x;
            if (typeof scale.min !== 'number' || typeof scale.max !== 'number') return;

            const currentState = { min: scale.min, max: scale.max };

            if (zoomHistory.length === 0 ||
                zoomHistory[zoomHistory.length - 1].min !== currentState.min ||
                zoomHistory[zoomHistory.length - 1].max !== currentState.max) {
                
                if (zoomHistory.length >= MAX_ZOOM_HISTORY_DEPTH) {
                    zoomHistory.shift();
                }
                zoomHistory.push(currentState);
            }
        }

        // --- Charts & Map Sync ---
        function syncScales(sourceChart) {
            // --- NEW LOGIC: If the source of the zoom/pan is the histogram,
            // it operates independently and does not affect other charts.
            if (sourceChart === charts.svHistogram || sourceChart === charts.gforces) { 
                // For histograms, we don't use 'master zoom history' in the same way,
                // so no need to call saveCurrentMasterZoom here.
                return; 
            }

            const xMinDistance = sourceChart.scales.x.min; 
            const xMaxDistance = sourceChart.scales.x.max; 

            Object.values(charts).forEach(chart => {
                // --- NEW LOGIC: Skip the histogram chart when applying zoom/pan from other charts.
                if (chart === charts.svHistogram || chart === charts.gforces) { 
                    return; // Do not apply external zoom/pan to the histogram
                }

                // If the current chart in the loop is the source chart, we don't need to update its scales
                // as they already reflect the change that triggered this sync.
                if (chart === sourceChart) return; 

                // Existing logic for other charts (line charts and track map)
                if (chart.config.type !== 'scatter') {
                    if (chart.options.scales && chart.options.scales.x) {
                        chart.options.scales.x.min = xMinDistance;
                        chart.options.scales.x.max = xMaxDistance;
                    }
                } else { // Handle track map (scatter chart)
                    const currentRefLap = telemetryData.find(l => l.id === referenceLapId);

                    if (!currentRefLap || !currentRefLap.data || currentRefLap.data.distance.length === 0) {
                        chart.options.scales.x.min = undefined;
                        chart.options.scales.x.max = undefined;
                        chart.options.scales.y.min = undefined;
                        chart.options.scales.y.max = undefined;
                    } else {
                        let mapPointsInView = [];
                        for (let i = 0; i < currentRefLap.data.distance.length; i++) {
                            const dist = currentRefLap.data.distance[i];
                            if (dist >= xMinDistance && dist <= xMaxDistance) {
                                mapPointsInView.push({
                                    x: currentRefLap.data.mapX[i],
                                    y: currentRefLap.data.mapY[i]
                                });
                            }
                        }

                        if (mapPointsInView.length > 0) {
                            let newMinMapX = Math.min(...mapPointsInView.map(p => p.x));
                            let newMaxMapX = Math.max(...mapPointsInView.map(p => p.x));
                            let newMinMapY = Math.min(...mapPointsInView.map(p => p.y));
                            let newMaxMapY = Math.max(...mapPointsInView.map(p => p.y));

                            const rangeX = newMaxMapX - newMinMapX;
                            const rangeY = newMaxMapY - newMinMapY;
                            const paddingFactor = 0.1;
                            const paddingX = rangeX === 0 ? 0.01 : rangeX * paddingFactor; 
                            const paddingY = rangeY === 0 ? 0.01 : rangeY * paddingFactor;

                            chart.options.scales.x.min = newMinMapX - paddingX;
                            chart.options.scales.x.max = newMaxMapX + paddingX;
                            chart.options.scales.y.min = newMinMapY - paddingY;
                            chart.options.scales.y.max = newMaxMapY + paddingY;
                        } else {
                            chart.options.scales.x.min = undefined;
                            chart.options.scales.x.max = undefined;
                            chart.options.scales.y.min = undefined;
                            chart.options.scales.y.max = undefined;
                        }
                    }
                }
                chart.update('none'); 
            });

            // This part is specific to the delta chart (master zoom for distance-based charts)
            if (sourceChart === charts.delta) {
                saveCurrentMasterZoom();
            }
        }

        
const debouncedUpdateMapCursor = debounce((event, elements, chartInstance) => {
    if (!charts.map || !charts.map.data || !charts.map.data.datasets || charts.map.data.datasets.length === 0) {
        return;
    }

    const cursorDsIndex = charts.map.data.datasets.length - 1;

    if (elements && elements.length > 0) {
        const first = elements[0];

        let distance = null;
        if (first.element && first.element.$context) {
            const ctx = first.element.$context;

            // PREFER raw.d (distance) if present (G-force scatter),
            // then fall back to raw.x (line charts use x = distance),
            // then parsed.x as last resort.
            if (ctx.raw && typeof ctx.raw.d === 'number') {
                distance = ctx.raw.d;
            } else if (ctx.raw && typeof ctx.raw.x === 'number') {
                distance = ctx.raw.x;
            } else if (ctx.parsed && typeof ctx.parsed.x === 'number') {
                distance = ctx.parsed.x;
            }
        }

        if (distance == null) {
            const rect = chartInstance.canvas.getBoundingClientRect();
            const xPixel = event.clientX - rect.left;
            distance = chartInstance.scales.x.getValueForPixel(xPixel);
        }

                let lapForMap = telemetryData.find(l => l.id === referenceLapId);
                if (!lapForMap && defaultVisibleLapIds.size > 0) {
                    const firstVisibleLapId = Array.from(defaultVisibleLapIds)[0];
                    lapForMap = telemetryData.find(l => l.id === firstVisibleLapId);
                }

                if (lapForMap && typeof distance === 'number') {
                    const mapCoords = getInterpolatedMapCoords(lapForMap.data, distance);
                    if (mapCoords) {
                        if (!lastHoveredMapCoords || mapCoords.x !== lastHoveredMapCoords.x || mapCoords.y !== lastHoveredMapCoords.y) {
                            charts.map.data.datasets[cursorDsIndex].data = [{ x: mapCoords.x, y: mapCoords.y }];
                            charts.map.data.datasets[cursorDsIndex].pointBackgroundColor = lapForMap.color;
                            charts.map.data.datasets[cursorDsIndex].pointBorderColor = lapForMap.color;
                            charts.map.update('none');
                            lastHoveredMapCoords = mapCoords;
                        }
                        return;
                    }
                }
            }

            if (charts.map.data.datasets[cursorDsIndex] && charts.map.data.datasets[cursorDsIndex].data.length > 0) {
                charts.map.data.datasets[cursorDsIndex].data = [];
                charts.map.update('none');
                lastHoveredMapCoords = null;
            }
        }, 50);


        function panAllChartsX(stepFraction = 0.1, direction = 1) {
            const masterChart = charts.delta; 
            if (!masterChart || !masterChart.scales || !masterChart.scales.x) return;

            const scale = masterChart.scales.x;
            if (scale.min == null || scale.max == null) return;

            const range = scale.max - scale.min;
            if (range <= 0) return;

            const shift = range * stepFraction * direction;
            const newMin = scale.min + shift;
            const newMax = scale.max + shift;

            masterChart.options.scales.x.min = newMin;
            masterChart.options.scales.x.max = newMax;
            masterChart.update('none');

            syncScales(masterChart);
        }

function computeSVStats(rawVelocities) {
    if (!rawVelocities || rawVelocities.length === 0) return null;

    const mean = rawVelocities.reduce((s, v) => s + v, 0) / rawVelocities.length;
    const variance = rawVelocities.reduce((s, v) => s + (v - mean) ** 2, 0) / rawVelocities.length;
    const stdDev = Math.sqrt(variance);

    let bumpCount = 0, reboundCount = 0;
    rawVelocities.forEach(v => {
        if (v < -0.01) bumpCount++;
        else if (v > 0.01) reboundCount++;
    });

    const totalNonZero = bumpCount + reboundCount || 1;

    return {
        mean,
        stdDev,
        bumpRatio: bumpCount / totalNonZero,
        reboundRatio: reboundCount / totalNonZero,
        max: Math.max(...rawVelocities),
        min: Math.min(...rawVelocities)
    };
}

function buildDynamicDamperTargetProfile(selectedLaps) {
    const wheels = ['LF', 'RF', 'LR', 'RR'];

    let sumMean = 0;
    let sumStdDev = 0;
    let sumBumpRatio = 0;
    let sumReboundRatio = 0;
    let count = 0;

    selectedLaps.forEach(lap => {
        if (!lap.svStats) return;
        wheels.forEach(w => {
            const st = lap.svStats[w];
            if (!st) return;
            sumMean         += st.mean;
            sumStdDev       += st.stdDev;
            sumBumpRatio    += st.bumpRatio;
            sumReboundRatio += st.reboundRatio;
            count++;
        });
    });

    if (count === 0) return null;

    const avgMean         = sumMean / count;
    const avgStdDev       = sumStdDev / count;
    const avgBumpRatio    = sumBumpRatio / count;
    const avgReboundRatio = sumReboundRatio / count;

    return {
        meanTarget: avgMean,
        stdDevTarget: avgStdDev,
        bumpRatioTarget: avgBumpRatio,
        reboundRatioTarget: avgReboundRatio,

        meanTol: 0.01,             // allowable mean offset
        stdDevTolFraction: 0.25,   // ±25% range around target σ
        bumpReboundBalanceTol: 0.15
    };
}


function makeDamperRecommendation(stats, targetProfile) {
    if (!stats || !targetProfile) return 'No data';

    const recs = [];

    // 1) Mean offset vs target
    const meanDelta = stats.mean - targetProfile.meanTarget;
    if (meanDelta > targetProfile.meanTol) {
        recs.push('Shifted toward rebound vs selected-lap average. Try slightly softening rebound or stiffening bump.');
    } else if (meanDelta < -targetProfile.meanTol) {
        recs.push('Shifted toward bump vs selected-lap average. Try slightly softening bump or stiffening rebound.');
    }

    // 2) Spread / stdDev vs target σ
    const stdLow  = targetProfile.stdDevTarget * (1 - targetProfile.stdDevTolFraction);
    const stdHigh = targetProfile.stdDevTarget * (1 + targetProfile.stdDevTolFraction);

    if (stats.stdDev < stdLow) {
        recs.push('Velocity range is tighter than average; damper likely stiffer here. Try softening both bump and rebound a bit.');
    } else if (stats.stdDev > stdHigh) {
        recs.push('Velocity range is wider than average; damper likely softer here. Consider stiffening both bump and rebound slightly.');
    }

    // 3) Bump vs rebound time vs target
    const bumpDelta = stats.bumpRatio - targetProfile.bumpRatioTarget;
    if (Math.abs(bumpDelta) > targetProfile.bumpReboundBalanceTol) {
        if (bumpDelta > 0) {
            recs.push('Spends more time in bump than average. Try reducing bump or increasing rebound slightly.');
        } else {
            recs.push('Spends more time in rebound than average. Try reducing rebound or increasing bump slightly.');
        }
    }

    if (recs.length === 0) {
        recs.push('Damper velocity profile is close to the average of the selected laps. Only fine-tune if you feel handling issues.');
    }

    return recs.join(' ');
}

function updateDamperRecommendations() {
    const container = document.getElementById('damper-rec-content');
    if (!container) return;

    const selectedLaps = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
    if (selectedLaps.length === 0) {
        container.textContent = 'No laps selected.';
        return;
    }

    // Show recommendations for reference lap, otherwise first visible
    const lap = telemetryData.find(l => l.id === referenceLapId) || selectedLaps[0];

    if (!lap.svStats || !lap.damperRecommendations) {
        container.textContent = 'No damper statistics available for selected lap.';
        return;
    }

    const wheels = ['LF', 'RF', 'LR', 'RR'];
    container.innerHTML = wheels.map(w => {
        const stats = lap.svStats[w];
        const rec   = lap.damperRecommendations[w] || 'No recommendation.';
        if (!stats) return `<div><strong>${w}:</strong> No data.</div>`;

        return `
            <div style="margin-bottom:6px;">
                <strong>${w}:</strong><br>
<span style="color:#ccc;">mean:</span> ${(stats.mean * 1000).toFixed(1)} mm/s,
<span style="color:#ccc;">σ:</span> ${(stats.stdDev * 1000).toFixed(1)} mm/s
<br>
                <span>${rec}</span>
            </div>
        `;
    }).join('');
}


function calculateSVHistogram(lap, wheelKey, minVel = -0.5, maxVel = 0.5, binSize = 0.01) {
    const velocities = lap.data[wheelKey]; // m/s
    if (!velocities || velocities.length === 0) return [];

    const validVelocities = velocities.filter(v => v > -5 && v < 5);
    if (validVelocities.length === 0) return [];

    const numBins = Math.ceil((maxVel - minVel) / binSize);
    const binMap = new Map(); // key in m/s

    for (let i = 0; i < validVelocities.length; i++) {
        const vel = validVelocities[i]; // m/s

        if (vel >= minVel && vel < maxVel) {
            const binIndex = Math.floor((vel - minVel) / binSize);
            const binCenterMs = minVel + (binIndex * binSize) + (binSize / 2); // m/s
            const cleanCenterMs = parseFloat(binCenterMs.toFixed(3));
            binMap.set(cleanCenterMs, (binMap.get(cleanCenterMs) || 0) + 1);
        }
    }

    // Output x in mm/s
    const histogramData = Array.from(binMap, ([xMs, y]) => ({
        x: xMs * 1000, // mm/s
        y
    })).sort((a, b) => a.x - b.x);

    return histogramData;
}




function initSVHistogramChart(canvasId, label, unit) {
    const ctx = document.getElementById(canvasId).getContext('2d');

    const existingChart = Chart.getChart(ctx);
    if (existingChart) {
        existingChart.destroy();
    }

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        parsing: {
            xAxisKey: 'x',
            yAxisKey: 'y'
        },
        scales: {
            x: {
                type: 'linear',
                offset: false,
                title: { display: true, text: 'Suspension Velocity (mm/s)', color: '#888' }, // CHANGED to #888
                ticks: { color: '#888' },
                grid: { color: '#333', offset: false }
            },
            y: {
                beginAtZero: true,
                title: { display: true, text: unit, color: '#888' }, // CHANGED to #888
                ticks: { color: '#888' },
                grid: { color: '#333' }
            }
        },
        plugins: {
            legend: { 
                display: true, 
                position: 'top',  // Explicitly set position
                align: 'center',  // Centers the legend items within the legend box
                fullSize: true,   // IMPORTANT: Makes the legend span the full chart width
                labels: { color: '#eee' } // KEEP legend labels light
            },
            title: { 
                display: true, 
                position: 'top',  // Explicitly set position
                text: label, 
                color: '#eee', // KEEP main chart title light
                align: 'center',  // Centers the title text within the title box
                fullSize: true    // IMPORTANT: Makes the title span the full chart width
            },
            tooltip: {
                callbacks: {
title: function(tooltipItems) {
    const binCenterMm = tooltipItems[0].parsed.x;      // already mm/s now
    const binSizeMm   = 0.01 * 1000;                   // if binSize was 0.01 m/s
    const binStart = binCenterMm - (binSizeMm / 2);
    const binEnd   = binCenterMm + (binSizeMm / 2);
    return `Velocity: ${binStart.toFixed(0)} to ${binEnd.toFixed(0)} mm/s`;
},

                    label: function(tooltipItem) {
                        const datasetLabel = tooltipItem.dataset.label || '';
                        const value = tooltipItem.parsed.y;
                        return `${datasetLabel}: ${value} samples`;
                    }
                }
            },
            zoom: {
                zoom: {
                    wheel: { enabled: true },
                    pinch: { enabled: true },
                    mode: 'x', 
                    drag: { enabled: true },
                },
                pan: { enabled: true, mode: 'x' }
            }
        }
    };

            const chart = new Chart(ctx, {
                type: 'bar', 
                data: { datasets: [] },
                options: chartOptions
            });
            // Get the parent .chart-wrapper element
            const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
            if (chartWrapper) {
                addFullscreenButton(chartWrapper, chart);
            }
            return chart; // Return the chart instance
}


// Initialize all charts
charts.delta = initLineChart('delta-chart', 'Time Delta (vs Reference)', 'sec');
charts.map = initTrackMap();
charts.speed = initLineChart('speed-chart', 'Speed', 'km/h');
charts.inputs = initLineChart('throttle-brake-chart', 'Inputs', '%');
charts.steering = initLineChart('steering-chart', 'Steering', 'rad');
charts.rpm = initLineChart('rpm-gear-chart', 'RPM / Gear', 'val');
// --- ADD THIS INITIALIZATION ---
charts.svHistogram = initSVHistogramChart('suspension-velocity-chart', 'Suspension Velocity Histogram', 'Samples');
charts.gforces = initGForceScatterChart('gforce-scatter-chart', 'Combined G-Forces', 'G'); // NEW CHART INITIALIZATION
// --- END OF NEW INITIALIZATION ---


        function initLineChart(canvasId, label, unit) {
            const ctx = document.getElementById(canvasId).getContext('2d');

    const existingChart = Chart.getChart(ctx);
    if (existingChart) {
        existingChart.destroy();
    }
            
            const chartOptions = { 
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'index', intersect: false }, 
                onHover: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, elements, chartInstance), 
                onLeave: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, null, chartInstance), 
                scales: {
                    x: { type: 'linear', title: { display: true, text: 'Distance (m)' }, ticks: { color: '#888' }, grid: { color: '#333' } },
                    y: { title: { display: true, text: unit }, ticks: { color: '#888' }, grid: { color: '#333' } }
                },
                elements: { 
                    point: {
                        hoverRadius: 0 
                    }
                },
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: label, color: '#eee' },
                    tooltip: {
                        enabled: false,
                        mode: 'nearest', 
                        intersect: false, 
                        caretPadding: 10, 
                        callbacks: {
                            title: function(tooltipItems) {
                                if (tooltipItems.length === 0) return '';
                                const distance = tooltipItems[0].parsed.x;
                                return `Distance: ${distance.toFixed(1)} m`;
                            },
                            label: function(tooltipItem) {
                                const lapId = tooltipItem.dataset.lapId;
                                if (lapId === -1) return ''; 

                                const lap = telemetryData.find(l => l.id === lapId);
                                if (!lap) return '';

                                const value = tooltipItem.parsed.y;
                                let formattedValue = '';
                                
                                const lapInfo = `L${lap.lapNumber} (${lap.filenameWithoutExt})`; 

                                if (tooltipItem.dataset.label.includes('Speed')) {
                                    formattedValue = `${lapInfo} Speed: ${value.toFixed(1)} km/h`;
                                } else if (tooltipItem.dataset.label.includes('Thr')) {
                                    formattedValue = `${lapInfo} Throttle: ${value.toFixed(1)} %`;
                                } else if (tooltipItem.dataset.label.includes('Brk')) {
                                    formattedValue = `${lapInfo} Brake: ${value.toFixed(1)} %`;
                                } else if (tooltipItem.dataset.label.includes('Steering')) {
                                    formattedValue = `${lapInfo} Steering: ${(value * 180 / Math.PI).toFixed(1)} deg`;
                                } else if (tooltipItem.dataset.label.includes('RPM')) {
                                    formattedValue = `${lapInfo} RPM: ${value.toFixed(0)}`;
                                } else if (tooltipItem.dataset.label.includes('Gear')) {
                                    formattedValue = `${lapInfo} Gear: ${value.toFixed(0)}`;
                                } else if (tooltipItem.dataset.label.includes('Delta')) {
                                    const sign = value > 0 ? '+' : '';
                                    formattedValue = `${lapInfo} Delta: ${sign}${value.toFixed(3)} s`;
                                } else if (tooltipItem.dataset.label.includes('ABS Active')) { 
                                    formattedValue = `${lapInfo} ABS Active`; 
                                } else if (tooltipItem.dataset.label.includes('Reference')) { 
                                    formattedValue = `${lapInfo} Delta: 0.000 s`;
                                } else {
                                    formattedValue = `${lapInfo} ${tooltipItem.dataset.label.replace(`L${lap.lapNumber} `, '').replace(` (${lap.filename})`, '')}: ${value.toFixed(2)}`;
                                }
                                return formattedValue; 
                            },
                        }
                    },
                    zoom: {
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: 'x',
                            drag: {
                                enabled: true,
                                borderColor: 'rgba(255,255,255,0.3)',
                                borderWidth: 1,
                                backgroundColor: 'rgba(255,255,255,0.1)',
                                threshold: 5
                            },
                            onZoomComplete: ({chart}) => { syncScales(chart); }, 
                            onZoom: ({chart}) => syncScales(chart)
                        },
                        pan: {
                            enabled: false
                        }
                    },
                    annotation: { annotations: {} }
                }
            };

            if (canvasId === 'throttle-brake-chart') {
                chartOptions.scales.y.min = 0;
                chartOptions.scales.y.max = 100;
            }


            const chart = new Chart(ctx, {
                type: 'line',
                data: { datasets: [] },
                options: chartOptions 
            });
            // Get the parent .chart-wrapper element
            const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
            if (chartWrapper) {
                addFullscreenButton(chartWrapper, chart);
            }
            return chart; // Return the chart instance
        }

        function initTrackMap() {
            const ctx = document.getElementById('track-map-chart').getContext('2d');

            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }

            const chart = new Chart(ctx, { // <-- Declare 'chart' here
                type: 'scatter', 
                data: { datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: { 
                        x: { display: false, grid: { drawOnChartArea: false } }, 
                        y: { display: false, grid: { drawOnChartArea: false } }
                    },
                    plugins: { legend: { display: false }, tooltip: { enabled: false } }, 
                    elements: { point: { radius: 0 }, line: { borderWidth: 2 } } 
                }
            });

            // Get the parent .chart-wrapper element
            const chartWrapper = document.getElementById('track-map-chart').closest('.chart-wrapper');
            if (chartWrapper) {
                addFullscreenButton(chartWrapper, chart);
            }
            return chart; // Return the chart instance
        }


function toggleTooltips(enabled) {
    Object.values(charts).forEach(chart => {
        if (!chart.options.plugins || !chart.options.plugins.tooltip) return;

        const isGForce = chart.canvas && chart.canvas.id === 'gforce-scatter-chart';
        const isTrackMap = chart.canvas && chart.canvas.id === 'track-map-chart';

        // Never show tooltips on the track map
        if (isTrackMap) {
            chart.options.plugins.tooltip.enabled = false;
            chart.update('none');
            return;
        }

        // Enable/disable on all non-map charts, including G-force
        if (chart.config.type !== 'scatter' || isGForce) {
            chart.options.plugins.tooltip.enabled = enabled;
            chart.update('none');
        }
    });
}


        function updateCharts() {
            const selectedLaps = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
            const refLap = telemetryData.find(l => l.id === referenceLapId);

            const sectorData = calculateSectors(selectedLaps, refLap);
            if (refLap) updateSectorTable(sectorData);
            else document.getElementById('sector-body').innerHTML =
                '<tr><td colspan="3" style="text-align:center;color:#888;">No reference lap selected.</td></tr>';

            const createDataset = (lap, dataKey, label, color, borderDash = []) => ({
                label: `L${lap.lapNumber} ${label} (${lap.filenameWithoutExt})`,
                data: lap.data[dataKey].map((val, i) => ({ x: lap.data.distance[i], y: val })),
                borderColor: color,
                borderWidth: 1.5,
                borderDash: borderDash,
                pointRadius: 0,
                tension: 0.1,
                lapId: lap.id
            });

            // 1. Time Delta Chart
            if (refLap && selectedLaps.length > 0) {
                charts.delta.data.datasets = selectedLaps.map(lap => {
                    if (lap.id === refLap.id) {
                        return {
                            label: `Reference L${lap.lapNumber}`,
                            data: lap.data.distance.map(d => ({ x: d, y: 0 })),
                            borderColor: '#666',
                            borderWidth: 1,
                            pointRadius: 0,
                            lapId: lap.id
                        };
                    }
                    const deltas = calculateTimeDelta(lap, refLap);
                    return {
                        label: `Delta L${lap.lapNumber} vs Ref`,
                        data: refLap.data.distance.map((dist, i) => ({ x: dist, y: deltas[i] })),
                        borderColor: lap.color,
                        borderWidth: 1.5,
                        pointRadius: 0,
                        lapId: lap.id
                    };
                });
            } else {
                charts.delta.data.datasets = [];
            }

            // 2. Standard Telemetry Charts
            charts.speed.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'speed', 'Speed', lap.color)
            );

            let inputsDatasets = [];
            selectedLaps.forEach(lap => {
                inputsDatasets.push(createDataset(lap, 'throttle', 'Thr', lap.color));
                inputsDatasets.push(createDataset(lap, 'brake', 'Brk', lap.color, [5, 5]));
            });
            charts.inputs.data.datasets = inputsDatasets;

            charts.steering.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'steering', 'Steering', lap.color)
            );

            charts.rpm.data.datasets = selectedLaps.map(lap => {
                const rpmDataset = createDataset(lap, 'rpm', 'RPM', lap.color);
                const gearDataset = createDataset(lap, 'gear', 'Gear', lap.color, [2, 2]);
                gearDataset.yAxisID = 'y1';
                return [rpmDataset, gearDataset];
            }).flat();

            if (charts.rpm.options.scales.y1 === undefined &&
                charts.rpm.data.datasets.some(ds => ds.yAxisID === 'y1')) {
                charts.rpm.options.scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'Gear', color: '#888' },
                    grid: { drawOnChartArea: false },
                    ticks: { color: '#888', stepSize: 1, precision: 0 }
                };
            } else if (charts.rpm.options.scales.y1 &&
                       !charts.rpm.data.datasets.some(ds => ds.yAxisID === 'y1')) {
                delete charts.rpm.options.scales.y1;
            }

            // --- SUSPENSION VELOCITY HISTOGRAM (FIXED SCALING, RANGE, AND CENTERING) ---
            const svDatasets = [];
            const wheelKeys = ['shockVelLF', 'shockVelRF', 'shockVelLR', 'shockVelRR'];
            const wheelNames = ['LF', 'RF', 'LR', 'RR'];
            const wheelColors = { 'LF': '#007bff', 'RF': '#ffc107', 'LR': '#28a745', 'RR': '#dc3545' };

            // Define a more generous, yet realistic, range for damper velocity (in m/s)
const HIST_MIN = -2000;    // -2.0 m/s
const HIST_MAX =  2000;    //  2.0 m/s
const HIST_BIN = 10;       // 10 mm/s per bin

            let globalMinVel = Infinity;
            let globalMaxVel = -Infinity;

selectedLaps.forEach(lap => {
    if (!lap.svStats) lap.svStats = {};

    wheelKeys.forEach((key, i) => {
        const rawVelocities = lap.data[key];
        if (!rawVelocities || rawVelocities.length === 0) return;

        // 1) Stats for recommendations
        const stats = computeSVStats(rawVelocities);
        lap.svStats[wheelNames[i]] = stats;

        // 2) Histogram for plotting (keep your existing logic)
        const histData = calculateSVHistogram(lap, key);
        if (histData.length > 0) {
            svDatasets.push({
                label: `L${lap.lapNumber} ${wheelNames[i]}`,
                data: histData,
                backgroundColor: wheelColors[wheelNames[i]] + '80',
                borderColor: wheelColors[wheelNames[i]],
                borderWidth: 1,
                barPercentage: 1,
                categoryPercentage: 1,
                lapId: lap.id
            });
        }
    });
});

// --- Damper target + recommendations based on selected laps ---
const dynamicTarget = buildDynamicDamperTargetProfile(selectedLaps);

selectedLaps.forEach(lap => {
    if (!lap.svStats) return;
    if (!lap.damperRecommendations) lap.damperRecommendations = {};

    ['LF', 'RF', 'LR', 'RR'].forEach(w => {
        const stats = lap.svStats[w];
        lap.damperRecommendations[w] = makeDamperRecommendation(stats, dynamicTarget);
    });
});

// Update the recommendations panel
updateDamperRecommendations();

            charts.svHistogram.data.datasets = []; // Explicitly clear
            charts.svHistogram.data.datasets = svDatasets; // Assign new

            // Set scale to be symmetrical around zero, based on the largest absolute velocity.
            if (globalMinVel !== Infinity && globalMaxVel !== -Infinity && svDatasets.length > 0) {
                const maxAbsoluteVelocity = Math.max(Math.abs(globalMinVel), Math.abs(globalMaxVel));
                
                // Calculate padding based on the determined range
                const rangeForPadding = maxAbsoluteVelocity * 2; 
                const padding = Math.max(rangeForPadding * 0.1, 0.05); // Minimum padding of 0.05 m/s
                
                charts.svHistogram.options.scales.x.min = -(maxAbsoluteVelocity + padding);
                charts.svHistogram.options.scales.x.max = (maxAbsoluteVelocity + padding);
            } else {
                // Fallback defaults if no valid data found
                charts.svHistogram.options.scales.x.min = HIST_MIN; 
                charts.svHistogram.options.scales.x.max = HIST_MAX;
            }
            
            charts.svHistogram.options.scales.y.min = 0;
            charts.svHistogram.update();
            // --- END SUSPENSION VELOCITY HISTOGRAM ---

            // --- G-Force Scatter Plot (NEW BLOCK) ---
const gForceDatasets = [];
let globalMinLatG = Infinity, globalMaxLatG = -Infinity;
let globalMinLongG = Infinity, globalMaxLongG = -Infinity;

// Use visible laps only
selectedLaps.forEach(lap => {
    if (!lap.data.gForceLat || !lap.data.gForceLong || lap.data.gForceLat.length === 0) return;
    if (!lap.data.distance || lap.data.distance.length === 0) return;

    const data = [];
    const len = Math.min(
        lap.data.gForceLat.length,
        lap.data.gForceLong.length,
        lap.data.distance.length
    );

    for (let i = 0; i < len; i++) {
        const longG = lap.data.gForceLong[i];
        const latG  = lap.data.gForceLat[i];
        const d     = lap.data.distance[i];  // distance along lap at this sample

        if (longG < globalMinLongG) globalMinLongG = longG;
        if (longG > globalMaxLongG) globalMaxLongG = longG;
        if (latG  < globalMinLatG)  globalMinLatG  = latG;
        if (latG  > globalMaxLatG)  globalMaxLatG  = latG;

        data.push({ x: longG, y: latG, d }); // <-- include distance
    }

    if (data.length > 0) {
        gForceDatasets.push({
            label: `L${lap.lapNumber} G-Forces`,
            data,
            borderColor: lap.color,
            backgroundColor: lap.color + '40',
            pointRadius: 1.5,
            pointHoverRadius: 5,
            lapId: lap.id
        });
    }
});

charts.gforces.data.datasets = []; 
charts.gforces.data.datasets = gForceDatasets;

// then axis min/max logic...
charts.gforces.update();

            // Set symmetrical scales around zero for G-forces
            if (globalMinLatG !== Infinity && globalMaxLatG !== -Infinity && gForceDatasets.length > 0) {
                const maxAbsoluteLatG = Math.max(Math.abs(globalMinLatG), Math.abs(globalMaxLatG));
                const maxAbsoluteLongG = Math.max(Math.abs(globalMinLongG), Math.abs(globalMaxLongG));

                const paddingFactor = 0.1;
                const latGExtent = maxAbsoluteLatG + (maxAbsoluteLatG * paddingFactor);
                const longGExtent = maxAbsoluteLongG + (maxAbsoluteLongG * paddingFactor);
                
                // Use the largest of the two extents to ensure both axes are symmetrical and cover all data
                const overallMaxAbsG = Math.max(latGExtent, longGExtent);

                charts.gforces.options.scales.x.min = -overallMaxAbsG;
                charts.gforces.options.scales.x.max = overallMaxAbsG;
                charts.gforces.options.scales.y.min = -overallMaxAbsG;
                charts.gforces.options.scales.y.max = overallMaxAbsG;
            } else {
                // Fallback defaults if no valid G-force data
                charts.gforces.options.scales.x.min = -2;
                charts.gforces.options.scales.x.max = 2;
                charts.gforces.options.scales.y.min = -2;
                charts.gforces.options.scales.y.max = 2;
            }
            charts.gforces.update();
            // --- END G-Force Scatter Plot ---


            // 3. Track Map & Cursor
            const mapDatasets = selectedLaps.map(lap => ({
                label: `L${lap.lapNumber} (${lap.filenameWithoutExt})`,
                data: lap.data.mapX.map((x, i) => ({ x: x, y: lap.data.mapY[i] })),
                borderColor: lap.color,
                borderWidth: 2,
                showLine: true,
                pointRadius: 0,
                lapId: lap.id
            }));

            mapDatasets.push({
                label: 'Cursor',
                data: [],
                pointRadius: 6,
                pointBackgroundColor: 'white',
                pointBorderColor: 'white',
                lapId: -1
            });
            charts.map.data.datasets = mapDatasets;

            let globalMinX = Infinity, globalMaxX = -Infinity;
            let globalMinY = Infinity, globalMaxY = -Infinity;

            if (selectedLaps.length > 0) {
                selectedLaps.forEach(lap => {
                    lap.data.mapX.forEach(val => {
                        globalMinX = Math.min(globalMinX, val);
                        globalMaxX = Math.max(globalMaxX, val);
                    });
                    lap.data.mapY.forEach(val => {
                        globalMinY = Math.min(globalMinY, val);
                        globalMaxY = Math.max(globalMaxY, val);
                    });
                });

                const mapPaddingX = (globalMaxX === -Infinity) ? 0 : (globalMaxX - globalMinX) * 0.1;
                const mapPaddingY = (globalMaxY === -Infinity) ? 0 : (globalMaxY - globalMinY) * 0.1;

                charts.map.options.scales.x.min = globalMinX - mapPaddingX;
                charts.map.options.scales.x.max = globalMaxX + mapPaddingX;
                charts.map.options.scales.y.min = globalMinY - mapPaddingY;
                charts.map.options.scales.y.max = globalMaxY + mapPaddingY;
            } else {
                charts.map.options.scales.x.min = undefined;
                charts.map.options.scales.x.max = undefined;
                charts.map.options.scales.y.min = undefined;
                charts.map.options.scales.y.max = undefined;
            }

            // 4. Sector Lines Annotations
            let sectorAnnotations = {};
            if (sectorData && sectorData.definitions && refLap) {
                sectorData.definitions.forEach((sec, i) => {
                    sectorAnnotations[`sec_${i}`] = {
                        type: 'line',
                        xMin: sec.end,
                        xMax: sec.end,
                        borderColor: '#444',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: `S${sec.id}`,
                            position: 'start',
                            color: '#666'
                        }
                    };
                });
            }

            // 5. ABS Areas (box annotations on inputs chart)
            let absAnnotations = {};
            if (showAbsAreas) {
                selectedLaps.forEach(lap => {
                    const dist = lap.data.distance;
                    const absArr = lap.data.brakeABSactive || [];
                    if (!dist.length || !absArr.length) return;

                    let inSegment = false;
                    let segStart = null;

                    for (let i = 0; i < dist.length; i++) {
                        const active = absArr[i] > 0;
                        if (active && !inSegment) {
                            inSegment = true;
                            segStart = dist[i];
                        } else if (!active && inSegment) {
                            inSegment = false;
                            const segEnd = dist[i];
                            const id = `abs_${lap.id}_${segStart.toFixed(3)}`;
                            absAnnotations[id] = {
                                type: 'box',
                                xMin: segStart,
                                xMax: segEnd,
                                yMin: 0,
                                yMax: 100,
                                backgroundColor: 'rgba(255, 0, 0, 0.25)',
                                borderWidth: 0,
                                drawTime: 'beforeDatasetsDraw'
                            };
                        }
                    }

                    if (inSegment) {
                        const segEnd = dist[dist.length - 1];
                        const id = `abs_${lap.id}_${segStart.toFixed(3)}_end`;
                        absAnnotations[id] = {
                            type: 'box',
                            xMin: segStart,
                            xMax: segEnd,
                            yMin: 0,
                            yMax: 100,
                            backgroundColor: 'rgba(255, 0, 0, 0.25)',
                            borderWidth: 0,
                            drawTime: 'beforeDatasetsDraw'
                        };
                    }
                });
            }

            charts.delta.options.plugins.annotation.annotations = sectorAnnotations;
            charts.speed.options.plugins.annotation.annotations = sectorAnnotations;
            charts.steering.options.plugins.annotation.annotations = sectorAnnotations;
            charts.rpm.options.plugins.annotation.annotations = sectorAnnotations;

            charts.inputs.options.plugins.annotation.annotations = {
                ...sectorAnnotations,
                ...absAnnotations
            };

            Object.values(charts).forEach(chart => {
                if (chart.config.type !== 'scatter' && chart.options.scales && chart.options.scales.x) {
                    // Do not reset X-axis min/max for the SV histogram here
                    if (chart.canvas.id !== 'suspension-velocity-chart') {
                         chart.options.scales.x.min = undefined;
                         chart.options.scales.x.max = undefined;
                    }
                }
                // Only update charts not updated already (svHistogram is updated above)
                if (chart.canvas.id !== 'suspension-velocity-chart') {
                    chart.update();
                }
            });
            
            if (charts.delta) {
                syncScales(charts.delta);
            }
        }


// --- New initGForceScatterChart function ---
function initGForceScatterChart(canvasId, label, unit) {
    const ctx = document.getElementById(canvasId).getContext('2d');

    const existingChart = Chart.getChart(ctx);
    if (existingChart) {
        existingChart.destroy();
    }

const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    animation: false,
    parsing: {
        xAxisKey: 'x',
        yAxisKey: 'y'
    },
    interaction: { mode: 'nearest', intersect: false },
    onHover: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, elements, chartInstance),
    onLeave: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, null, chartInstance),
    scales: {
            x: {
                type: 'linear',
                position: 'bottom',
                title: { display: true, text: 'Longitudinal G (' + unit + ')', color: '#888' }, // Gray axis title
                ticks: { color: '#888' },
                grid: { color: '#333' }
            },
            y: {
                type: 'linear',
                position: 'left',
                title: { display: true, text: 'Lateral G (' + unit + ')', color: '#888' }, // Gray axis title
                ticks: { color: '#888' },
                grid: { color: '#333' }
            }
        },
        elements: {
            point: {
                radius: 1.5, // Small points for scatter
                hoverRadius: 4
            },
            line: {
                borderWidth: 0 // No line connecting points for scatter by default
            }
        },
        plugins: {
            legend: { 
                display: true, 
                position: 'top',
                align: 'center',
                fullSize: true,
                labels: { color: '#eee' } // Keep legend labels light
            },
            title: { 
                display: true, 
                position: 'top',
                text: label, 
                color: '#eee', // Keep main chart title light
                align: 'center',
                fullSize: true
            },
tooltip: {
    enabled: false, // start with tooltips off; checkbox will control this
    callbacks: {
        title: function(tooltipItems) {
            return `G-Forces`; // Shorter title for tooltip
        },
        label: function(tooltipItem) {
            const lapId = tooltipItem.dataset.lapId;
            const lap = telemetryData.find(l => l.id === lapId);
            const lapInfo = lap ? `L${lap.lapNumber} (${lap.filenameWithoutExt})` : '';
            return `${lapInfo} Lat: ${tooltipItem.parsed.y.toFixed(2)} G, Long: ${tooltipItem.parsed.x.toFixed(2)} G`;
        }
    }
},
            zoom: {
                zoom: {
                    wheel: { enabled: true },
                    pinch: { enabled: true },
                    mode: 'xy', // Zoom on both X and Y axes for scatter
                    drag: { enabled: true },
                },
                pan: { enabled: true, mode: 'xy' } // Pan on both X and Y axes
            }
        }
    };

    const chart = new Chart(ctx, {
        type: 'scatter', // Use scatter chart type
        data: { datasets: [] },
        options: chartOptions
    });

    const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
    if (chartWrapper) {
        addFullscreenButton(chartWrapper, chart);
    }
    return chart;
}



        // --- Full reset of charts ---
        function performFullReset() {
            // Reset zoom for all charts that have the plugin, except the independent histogram
            Object.values(charts).forEach(chart => {
            if (chart && chart.canvas.id !== 'suspension-velocity-chart' && chart.canvas.id !== 'gforce-scatter-chart' && chart.zoom && chart.zoom.resetZoom) {
                chart.zoom.resetZoom();
                }
            });
            
            // This will update all charts' data and responsive behavior should handle initial drawing
            updateCharts(); 
            zoomHistory = []; 
        }




        function applyZoomState(min, max) {
            const masterChart = charts.delta;
            if (!masterChart || !masterChart.options.scales || !masterChart.options.scales.x) return;

            masterChart.options.scales.x.min = min;
            masterChart.options.scales.x.max = max;
            masterChart.update('none');

            syncScales(masterChart);
        }

        // --- Reset Zoom button with hold functionality ---
        let resetZoomTimer;
        const HOLD_DURATION = 500; // ms

        document.getElementById('reset-zoom').addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                let isLongPress = false;
                resetZoomTimer = setTimeout(() => {
                    isLongPress = true;
                    performFullReset(); // Long press performs a full reset
                    resetZoomTimer = null;
                }, HOLD_DURATION);

                const mouseUpHandler = () => {
                    clearTimeout(resetZoomTimer);
                    if (!isLongPress) {
                        if (zoomHistory.length > 1) {
                            zoomHistory.pop();
                            const previousState = zoomHistory[zoomHistory.length - 1];
                            applyZoomState(previousState.min, previousState.max); // Short press "undoes" using history
                        } else {
                            // If no history, or only initial state, perform a full reset for all zoomable charts
                            performFullReset(); 
                        }
                    }
                    document.removeEventListener('mouseup', mouseUpHandler);
                    document.removeEventListener('mouseleave', mouseLeaveHandler);
                    resetZoomTimer = null;
                };

                const mouseLeaveHandler = () => {
                    clearTimeout(resetZoomTimer);
                    document.removeEventListener('mouseup', mouseUpHandler);
                    document.removeEventListener('mouseleave', mouseLeaveHandler);
                    resetZoomTimer = null;
                };

                document.addEventListener('mouseup', mouseUpHandler);
                document.addEventListener('mouseleave', mouseLeaveHandler);
            }
        });


        document.addEventListener('DOMContentLoaded', () => {
            const toggleTooltipsCheckbox = document.getElementById('toggle-tooltips');
            const toggleAbsAreasCheckbox = document.getElementById('toggle-abs-areas');

            toggleTooltipsCheckbox.checked = false; 
            toggleTooltips(toggleTooltipsCheckbox.checked); 

            toggleAbsAreasCheckbox.checked = false;
            showAbsAreas = toggleAbsAreasCheckbox.checked; 

            toggleTooltipsCheckbox.addEventListener('change', (event) => {
                toggleTooltips(event.target.checked);
            });

            toggleAbsAreasCheckbox.addEventListener('change', (event) => {
                showAbsAreas = event.target.checked; 
                updateCharts(); 
            });

            // NEW: placemat button
            document.getElementById('print-placemat')
                .addEventListener('click', openPlacematReport);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                panAllChartsX(0.1, -1);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                panAllChartsX(0.1, 1);
            }
        });

document.getElementById('buy-coffee-btn').addEventListener('click', function () {
    window.open('https://www.buymeacoffee.com/mhmatthew', '_blank', 'noopener');
});

</script>

</body>
</html>



           


                
