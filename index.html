<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rapid Telemetry Viewer</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #007bff;
            --accent-color: #ffc107;
            --header-bg: #2c2c2c;
            --sidebar-bg: #252526;
            --chart-bg: #2a2a2a;
            --text-color: #f0f0f0;
            --text-color-light: #ccc;
            --border-color: #444;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: var(--header-bg);
            padding: 10px 20px;
            border-bottom: 2px solid var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        h1 { margin: 0; font-size: 1.5em; }

        .controls { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }

        .import-button, button {
            background-color: var(--primary-color);
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .import-button:hover, button:hover { background-color: #0056b3; }

        main {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        #sidebar {
            width: 350px;
            background-color: var(--sidebar-bg);
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #sidebar h2 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            font-size: 1.1em;
            color: var(--text-color-light);
        }

        #lap-selector { max-height: 250px; overflow-y: auto; }
        .lap-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            padding: 6px;
            border-radius: 3px;
            background: #333;
            font-size: 0.85em;
            border-left: 3px solid transparent;
        }
        .lap-item:hover { background-color: #444; }
        .lap-item.is-reference { border-left-color: var(--accent-color); background-color: #3a3a3a; }
        
        .lap-file-label { font-size: 0.8em; color: #888; display: block; width: 100px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .lap-status { font-size: 0.7em; margin-left: auto; text-align: right; color: #aaa; }
        .lap-status span { padding: 2px 5px; border-radius: 3px; }
        .lap-status .invalid { background-color: rgba(220, 53, 69, 0.2); color: #ff8089; }
        .lap-status .outin { background-color: rgba(255, 193, 7, 0.2); color: #ffc107; }
        .lap-status .complete { background-color: rgba(40, 167, 69, 0.2); color: #80ff97; }

        input[type="radio"].ref-radio {
            appearance: none;
            width: 12px;
            height: 12px;
            border: 2px solid #666;
            border-radius: 50%;
            cursor: pointer;
            outline: none;
        }
        input[type="radio"].ref-radio:checked {
            border-color: var(--accent-color);
            background-color: var(--accent-color);
            box-shadow: 0 0 5px var(--accent-color);
        }

        .sector-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }
        .sector-table th { text-align: left; color: #aaa; padding: 4px; }
        .sector-table td { padding: 4px; border-bottom: 1px solid #333; cursor: pointer; }
        .sector-table tr:hover { background-color: #333; }

        #track-map-wrapper {
            height: 250px;
            background-color: var(--chart-bg);
            border-radius: 6px;
            padding: 5px;
            margin-bottom: 10px;
        }

        #chart-container {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            background-color: #222;
        }

#import-coffee, #buy-coffee, #buy-coffee-btn { 
  margin-left: 1px;
  text-decoration: none; /* Removes underline if using anchor */
  display: inline-flex; /* Aligns items horizontally */
  align-items: center; /* Vertically centers content */
  gap: 6px; /* Space between icon and text */
  padding: 6px 10px; /* Reduced padding for a smaller height */
  border: none; /* Removes border */
  border-radius: 4px; /* Matches button corners */
  background-color: #007bff; /* Matches existing button styles */
  color: white; /* Text color */
  font-size: 14px; /* Ensure font size matches others */
  cursor: pointer; /* Show pointer on hover */
  transition: background-color 0.2s; /* Smooth hover effect */
}

#buy-coffee-btn:hover {
  background-color: #0056b3; /* Darkens background on hover */
}


        /* New styles for fullscreen chart toggle */
        #chart-container {
            position: relative; /* Needed for absolute positioning of fullscreen charts */
        }

        .chart-wrapper {
            position: relative; /* Needed for absolute positioning of the fullscreen button */
        }

        .fullscreen-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 3px;
            color: white;
            padding: 4px 6px;
            cursor: pointer;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1; /* Prevents extra line height causing vertical misalignment */
            z-index: 10; /* Ensure button is above chart */
            transition: background-color 0.2s;
        }

        .fullscreen-btn:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }

        /* Styles for the chart in fullscreen mode */
        .chart-wrapper.is-fullscreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100; /* Ensure it's on top of other elements in #chart-container */
            background-color: var(--chart-bg); /* Ensure background covers hidden charts */
            padding: 20px; /* Adjust padding for fullscreen view */
            box-sizing: border-box; /* Include padding in width/height calculation */
            border-radius: 0; /* Remove rounded corners in fullscreen */
        }

        /* Hide other charts when one is fullscreen */
        #chart-container.fullscreen-active .chart-wrapper:not(.is-fullscreen) {
            display: none;
        }



        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
            flex-shrink: 0;
            background-color: var(--chart-bg);
            border-radius: 6px;
            padding: 10px;
            box-sizing: border-box;
        }

        canvas { width: 100% !important; height: 100% !important; }

        .status { padding: 10px; border-radius: 4px; font-size: 0.9em; }
        .info { background-color: rgba(0, 123, 255, 0.2); color: #80bdff; }
        .error { background-color: rgba(220, 53, 69, 0.2); color: #ff8089; }
        .success { background-color: rgba(40, 167, 69, 0.2); color: #80ff97; }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

        .chartjs-tooltip {
            pointer-events: none;
        }

.chart-help-icon {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.5);
    color: #fff;
    font-size: 11px;
    line-height: 18px;
    text-align: center;
    cursor: help;
    z-index: 6;
    user-select: none;
}

.chart-help-icon:hover {
    background-color: rgba(0, 0, 0, 0.8);
}

.header-brand {
    display: flex;
    align-items: center;
    gap: 0;              /* remove flex gap */
}

.header-brand h1 {
    margin: 0;
    margin-left: 0px;    /* tiny manual spacing between logo and text */
    font-size: 1.4em;
}

        .ai-setup-modal {
            background: #252526;
            color: #eee;
            padding: 14px;
            border-radius: 6px;
            width: 1440px;
            height: 700px;
            max-width: 98vw;
            max-height: 90vh;
            box-shadow: 0 0 10px #000;
            font-size: 0.82rem;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .ai-setup-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

            .ai-setup-modal-header h3 {
                margin: 0;
                font-size: 0.95rem;
            }

        .ai-setup-close-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .ai-setup-modal-body {
            display: flex;
            gap: 10px;
            height: 100%;
            min-height: 320px;
            /* Flex-direction is already row by default for 'flex', so columns arrange side-by-side */
        }

        .ai-setup-column {
            flex: 1; /* Each column will take equal space */
            display: flex; /* Keep the flex display for internal stacking of header, car grid, etc. */
            flex-direction: column;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 6px;
            box-sizing: border-box;
            background: #2b2b2b;
        }

        .ai-setup-column-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 4px;
        }

        /* Optional: Specific styles for the new prediction column if needed */
        .ai-setup-prediction-column {
            flex: 1; /* Changed to 1 to give it equal width as other columns */
            /* Removed 'justify-content: space-between;' to allow content to stack from the top naturally */
            display: flex; /* Ensure it's still a flex container */
            flex-direction: column; /* Ensure content stacks vertically */
        }

            .ai-setup-prediction-column .ai-setup-controls {
                /* Removed 'margin-top: auto;' so it follows the header naturally */
                flex-grow: 0; /* Still prevent it from growing */
                padding-top: 10px;
                border-top: 1px solid #444;
            }

            .ai-setup-prediction-column .ai-setup-result {
                /* Removed 'margin-top: auto;' and 'flex-grow: 1;' */
                /* This ensures it only takes space needed by its content, and will scroll if max-height is exceeded */
                flex-grow: 1; /* Allowing it to grow but not explicitly pushing other elements apart */
                /* Keep max-height and overflow-y as defined in .ai-setup-result directly */
            }

        .ai-setup-meta {
            font-size: 0.7rem;
            color: #aaa;
            margin-top: 2px;
        }

        .ai-setup-car-grid {
            flex: 1;
            display: grid;
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 1fr;
            gap: 4px;
            border-radius: 4px;
            padding: 4px;
            background: #222;
            box-sizing: border-box;
        }

        /* Top-down car layout: front row, center spine, rear row */
        .ai-setup-car-row {
            display: flex;
            justify-content: space-between;
            gap: 4px;
        }

        .ai-setup-car-center {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 4px;
        }

        .ai-setup-corner {
            flex: 1;
            border-radius: 4px;
            background: #333;
            padding: 4px;
            box-sizing: border-box;
            font-size: 0.75rem;
        }

        .ai-setup-corner-header {
            font-weight: 600;
            font-size: 0.72rem;
            margin-bottom: 2px;
        }

        .ai-setup-corner-field {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
            margin-bottom: 2px;
        }

            .ai-setup-corner-field span.label {
                color: #aaa;
            }

            .ai-setup-corner-field span.value {
                color: #eee;
            }

            .ai-setup-corner-field span.delta {
                color: #ffc107;
                font-size: 0.7rem;
            }

        .ai-setup-center-block {
            border-radius: 4px;
            background: #333;
            padding: 4px;
            box-sizing: border-box;
            font-size: 0.75rem;
        }

        .ai-setup-center-block-header {
            font-weight: 600;
            font-size: 0.72rem;
            margin-bottom: 2px;
        }

        .ai-setup-center-field {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
            margin-bottom: 2px;
        }

            .ai-setup-center-field span.label {
                color: #aaa;
            }

            .ai-setup-center-field span.value {
                color: #eee;
            }

            .ai-setup-center-field span.delta {
                color: #ffc107;
                font-size: 0.7rem;
            }

        /* Editable inputs on the proposed side */
        .ai-setup-input {
            width: 60px;
            padding: 2px 3px;
            border-radius: 3px;
            border: 1px solid #555;
            background: #1f1f1f;
            color: #eee;
            font-size: 0.72rem;
            box-sizing: border-box;
        }

        .ai-setup-controls {
            margin-top: 6px;
            padding-top: 4px;
            border-top: 1px solid #444;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .ai-setup-controls-row label {
            display: block;
            font-size: 0.78rem;
            color: #ccc;
        }

        .ai-setup-controls-row select,
        .ai-setup-controls-row input {
            width: 100%;
            margin-top: 2px;
            box-sizing: border-box;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #222;
            color: #eee;
            font-size: 0.78rem;
        }

        .ai-setup-run-btn {
            margin-top: 4px;
            width: 100%;
            padding: 6px 8px;
            border: none;
            border-radius: 4px;
            background: var(--primary-color);
            color: #fff;
            font-size: 0.8rem;
            cursor: pointer;
        }

            .ai-setup-run-btn:hover {
                background: #0056b3;
            }

        .ai-setup-result {
            margin-top: 6px;
            font-size: 0.78rem;
            color: #ccc;
            flex: 1;
            overflow-y: auto;
        }

        /* Fullscreen mode for AI Setup modal */
        .ai-setup-modal.fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            border-radius: 0;
        }

        /* Load snapshot toggle in AI modal */
        #ai-load-toggle {
            margin-bottom: 4px;
            padding: 3px 6px;
            font-size: 0.7rem;
            border-radius: 3px;
            border: 1px solid #444;
            background: #1f1f1f;
            color: #ccc;
            cursor: pointer;
        }

            #ai-load-toggle:hover {
                background: #333;
            }

        #ai-load-details.collapsed {
            display: none;
        }

        .ai-setup-prediction-column table th,
        .ai-setup-prediction-column table td {
            text-align: center;
        }

        /* You might also want to explicitly set a padding if it's not consistent */
        .ai-setup-prediction-column table th,
        .ai-setup-prediction-column table td {
            padding: 2px 4px; /* Adjust as needed */
            vertical-align: middle; /* Ensures content is vertically centered */
        }


        /* Responsive adjustments for smaller screens (existing media queries might need tweaks) */
        @media (max-width: 1250px) { /* Adjust breakpoint as needed for the new modal width */
            .ai-setup-modal {
                width: 95vw; /* Make modal fill more of the screen */
            }
            /* You might need to change ai-setup-modal-body to flex-direction: column here if 3 columns don't fit well */
            .ai-setup-modal-body {
                flex-wrap: wrap; /* Allow columns to wrap if screen is too narrow */
            }

            .ai-setup-column {
                flex-basis: calc(50% - 10px); /* 2 columns per row */
            }

            .ai-setup-prediction-column {
                flex-basis: 100%; /* Make the prediction column full width on wrap */
            }
        }

        @media (max-width: 800px) { /* Your existing breakpoint for very small screens */
            .ai-setup-modal-body {
                flex-direction: column; /* Stack all columns vertically */
            }

            .ai-setup-column, .ai-setup-prediction-column {
                flex-basis: auto; /* Revert flex-basis */
                width: 100%; /* Fill available width */
            }
        }

        /* Pit Card Specific Styles (ADAPTED FOR DARK THEME) */
        :root {
            /* Keep existing variables, but add/adjust for pit card context */
            --pitcard-card-w: 90mm;
            --pitcard-card-h: 190mm; /* Start at a reasonable default, will expand */
            /* Using main app's color variables for consistency */
            --pitcard-accent: var(--primary-color); /* #007bff */
            --pitcard-muted: var(--text-color-light); /* #ccc */
            --pitcard-fg: var(--text-color); /* #f0f0f0 */
            --pitcard-bg: var(--sidebar-bg); /* #252526 - Match sidebar background */
        }

        #pit-card-modal {
            /* Keep modal overlay styles as they are from the main app */
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9998;
        }

        .pit-card-content { /* This is the actual card wrapper */
            position: relative; /* For positioning the close button */
            width: var(--pitcard-card-w);
            min-height: var(--pitcard-card-h); /* Allows card to grow */
            background: var(--pitcard-bg); /* Dark background for the card */
            color: var(--pitcard-fg); /* Light text for the card content */
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.45);
            padding: 12px 14px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 1px solid var(--border-color); /* Added a subtle border */
        }

        /* Adjust close button for better visibility on dark card */
        #close-pit-card-modal {
            color: var(--text-color-light) !important; /* Force light color for visibility */
            background: rgba(255, 255, 255, 0.1) !important; /* Slightly visible background */
            border-radius: 4px !important;
            padding: 2px 8px !important;
        }

            #close-pit-card-modal:hover {
                background: rgba(255, 255, 255, 0.2) !important;
            }


        .pit-card-content header.card-head {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Spreads out logo, h1, meta */
            gap: 8px;
            flex-wrap: wrap; /* Allow wrapping if width is too constrained */
        }

            .pit-card-content header.card-head .pit-card-logo {
                flex-shrink: 0; /* Don't let logo shrink */
            }

            .pit-card-content header.card-head h1 {
                font-size: 14px;
                margin: 0;
                color: var(--pitcard-fg); /* Light text for header title */
                flex-grow: 1; /* Allow h1 to take up available space */
                text-align: center; /* Center the title text */
            }

            .pit-card-content header.card-head .meta {
                font-size: 11px;
                color: var(--pitcard-muted);
                text-align: right;
                flex-shrink: 0; /* Don't let meta shrink */
            }

        .pit-card-content .meta-input {
            width: 70px;
            border: 1px solid var(--border-color); /* Darker border for inputs */
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 11px;
            background: var(--chart-bg); /* Darker background for inputs */
            color: var(--pitcard-fg); /* Light text for inputs */
            margin-left: 4px;
        }

        .pit-card-content .section-title {
            font-weight: 700;
            font-size: 11px;
            color: var(--primary-color);
            margin-top: 6px;
        }
        /* Use primary color as accent */
        .pit-card-content ul.checklist {
            list-style: none;
            padding: 0;
            margin: 4px 0 0 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

            .pit-card-content ul.checklist li {
                display: flex;
                gap: 8px;
                align-items: flex-start;
                font-size: 12px;
                color: var(--pitcard-fg);
            }
            /* Light text for checklist items */
            .pit-card-content ul.checklist label {
                display: flex;
                gap: 8px;
                align-items: center;
                cursor: pointer;
            }

        .pit-card-content .small-input {
            width: 58px;
            border: 1px solid var(--border-color); /* Darker border for inputs */
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
            background: var(--chart-bg); /* Darker background for inputs */
            color: var(--pitcard-fg); /* Light text for inputs */
        }

        .pit-card-content .time-box {
            margin-left: auto;
            font-size: 11px;
            color: var(--pitcard-muted);
        }

        .pit-card-content .notes {
            flex: 1;
            min-height: 64px; /* Approximately 4 lines of 12px text + padding */
            border: 1px dashed var(--border-color); /* Darker dashed border */
            padding: 6px;
            border-radius: 4px;
            font-size: 12px;
            background: var(--chart-bg); /* Darker background for notes area */
            color: var(--pitcard-fg); /* Light text for notes */
            overflow-y: auto; /* Allow scrolling for very long notes */
        }

        .pit-card-content .footer {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
        }

            .pit-card-content .footer div {
                color: var(--pitcard-muted);
            }
        /* Muted text for footer info */
        .pit-card-content .btn {
            background: var(--pitcard-accent);
            color: #fff;
            padding: 6px 8px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }

            .pit-card-content .btn.secondary {
                background: #6b7280;
            }
        /* This grey seems okay on dark */
        .pit-card-content .no-print {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        /* Custom style for the change/reason inputs */
        .pit-card-content .checklist li.change-reason-stack {
            flex-direction: column; /* Stack the div elements vertically */
            gap: 4px; /* Add a small vertical gap between them */
            align-items: flex-start; /* Ensure content aligns to the left */
            margin-left: 22px; /* Indent this line item */
            font-size: 12px;
            color: var(--pitcard-fg); /* Light text */
        }

        /* Print styles for the pit card when the entire page is printed */
        @media print {
            /* Hide the main viewer UI when printing the Pit Card specifically */
            body > header,
            body > main,
            #pit-card-modal #close-pit-card-modal {
                display: none !important;
            }

            #pit-card-modal {
                position: static !important; /* Allow it to flow naturally */
                display: flex !important;
                align-items: flex-start !important; /* Align to top of print area */
                justify-content: flex-start !important; /* Align to left of print area */
                background: none !important; /* No background for the modal itself */
                padding: 0 !important;
                margin: 0 !important;
                box-shadow: none !important;
                overflow: visible !important; /* Ensure content is not clipped */
                width: 100% !important;
                height: auto !important;
            }

            .pit-card-content {
                box-shadow: none !important;
                border-radius: 0 !important;
                page-break-inside: avoid !important; /* Keep the card as one piece */
                width: 100% !important; /* Use available print width (controlled by @page margin) */
                max-width: var(--pitcard-card-w) !important; /* Keep the card visual width */
                min-height: auto !important; /* Allow shrinking if needed */
                height: auto !important; /* CRITICAL: Allow height to grow to fit notes */
                /* Override dark theme for print to ensure readability on paper */
                background: #fff !important;
                color: #111 !important;
                border: 1px solid #ccc !important;
                display: block !important; /* Fix flex issues in print */
            }

                /* Adjust internal layout for print to ensure spacing */
                .pit-card-content .pit-card {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    height: auto !important;
                }

                .pit-card-content header.card-head h1,
                .pit-card-content header.card-head .meta,
                .pit-card-content .meta-input,
                .pit-card-content .section-title,
                .pit-card-content ul.checklist li,
                .pit-card-content .small-input,
                .pit-card-content .time-box,
                .pit-card-content .notes,
                .pit-card-content .footer div,
                .pit-card-content .checklist li.change-reason-stack {
                    color: #111 !important; /* Force black text for print */
                    background: #fff !important; /* Force white background for print */
                    border-color: #ddd !important;
                }

                .pit-card-content .btn {
                    background: var(--pitcard-accent) !important; /* Keep accent color for buttons */
                    color: #fff !important;
                }

                .pit-card-content .no-print {
                    display: none !important;
                }

            /* 
               Updated @page: Removed fixed height to prevent cutting off bottom content.
               Set to 'auto' or standard size so the printer driver handles the length.
            */
            @page {
                size: auto; /* Let printer decide height */
                margin: 5mm; /* Small margins */
            }
        }


@media (max-width: 768px) {
    /* Layout: stack sidebar above charts instead of side-by-side */
    main {
        flex-direction: column;
    }

    #sidebar {
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
        max-height: 40vh; /* let it scroll but not take the whole screen */
        overflow-y: auto;
    }

    #chart-container {
        padding: 10px;            /* less padding on small screens */
        gap: 10px;
    }

    /* Make charts taller so they’re easier to read on a narrow screen */
    .chart-wrapper {
        height: 260px;            /* was 200px */
        padding: 8px;
    }

    /* Header: title on top, controls below */
    header {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
    }

    header h1 {
        font-size: 1.2em;
        text-align: left;
        margin-bottom: 4px;
    }

    /* Controls in a 2-column grid on phones */
    header .controls {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
    }

    /* Make each control fill its grid cell */
    header .controls > * {
        width: 100%;
        justify-content: center;
    }

    /* Compact the toggle labels (Show Tooltip, Show ABS) */
    header .controls label {
        font-size: 0.8rem;
        padding: 4px 6px;
        background-color: #333;
        border-radius: 4px;
        box-sizing: border-box;
        display: flex;
        align-items: center;
    }

    header .controls label input[type="checkbox"] {
        margin-right: 4px;
    }

    /* Smaller buttons on mobile */
    .import-button,
    button {
        padding: 6px 8px;
        font-size: 0.8rem;
    }

    /* Keep Import button blue and center its text */
    header .controls .import-button {
        background-color: #007bff;
        color: #fff;
        display: flex;
        align-items: center;    /* vertical centering */
        justify-content: center;/* horizontal centering */
        text-align: center;
    }
}

@media (max-width: 480px) {
    /* On very small phones, stack controls in a single column */
    header .controls {
        grid-template-columns: 1fr;
    }
}




    </style>
</head>
<body>
    <header>
        <div class="header-brand">
            <svg viewBox="0 0 130 40"
                 width="90"
                 height="28"
                 xmlns="http://www.w3.org/2000/svg">
                <!-- Telemetry waveform line (shifted left and scaled down vertically) -->
                <polyline points="0,28 13,24 26,30 39,20 52,22 65,15 78,18 91,14 104,17"
                          fill="none"
                          stroke="#007bff"
                          stroke-width="2.5"
                          stroke-linecap="round"
                          stroke-linejoin="round" />

                <!-- Stylized car silhouette (shifted and scaled for new viewBox) -->
                <path d="M5 24
         C 12 14, 33 12, 45 14
         L 57 15
         C 64 16, 70 19, 74 23
         L 72 24
         C 68 20, 63 18, 57 19
         L 44 20
         C 33 17, 18 17, 9 24
         Z"
                      fill="none"
                      stroke="#ffc107"
                      stroke-width="1.8"
                      stroke-linecap="round"
                      stroke-linejoin="round" />

                <!-- Wheels -->
                <circle cx="18" cy="26" r="3" fill="#1a1a1a" stroke="#888" stroke-width="1.6" />
                <circle cx="40" cy="26" r="3" fill="#1a1a1a" stroke="#888" stroke-width="1.6" />
            </svg>

            <h1>Rapid Telemetry Viewer</h1>
        </div>

        <div class="controls">
            <label for="file-import" class="import-button">Import .ibt File(s)</label>
            <input type="file" id="file-import" accept=".ibt" multiple hidden>

            <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color: var(--text-color-light);">
                <input type="checkbox" id="toggle-tooltips" style="margin:0;">
                Show Tooltip Details
            </label>
            <label style="display:flex; align-items:center; gap:5px; cursor:pointer; color: var(--text-color-light);">
                <input type="checkbox" id="toggle-abs-areas" style="margin:0;">
                Show ABS Areas
            </label>

            <button id="reset-zoom">Reset Zoom</button>
            <button id="print-placemat">Placemat Report</button>
            <button id="buy-coffee-btn" class="import-button" title="Buy me a coffee">☕ Buy Me a Coffee</button>
        </div>
    </header>
    <main>
        <aside id="sidebar">
            <div>
                <h2>Status</h2>
                <div id="status-container">
                    <div class="status info">Ready to import .ibt files</div>
                </div>
            </div>

            <div>
                <h2>Track Map</h2>
                <div id="track-map-wrapper">
                    <canvas id="track-map-chart"></canvas>
                </div>
                <div style="font-size: 0.8em; color: #888; margin-top:5px; text-align: center;">
                    Hover over charts to see position<br>
                    Drag to zoom, <-|-> to pan
                </div>
            </div>

            <div>
                <h2>Laps</h2>
                <div style="font-size: 0.8em; color: #aaa; margin-bottom: 5px; display: flex; justify-content: space-between; padding: 0 5px;">
                    <span>Vis | Ref</span>
                    <span>Lap Info</span>
                    <span>Color</span>
                </div>
                <div id="lap-selector">
                    <p style="color: #888; font-style: italic;">No laps loaded.</p>
                </div>
            </div>

            <div>
                <h2>Sector Analysis</h2>
                <div id="sector-container">
                    <table class="sector-table">
                        <thead>
                            <tr>
                                <th>Sector</th>
                                <th>Time</th>
                                <th>Delta (vs Ref)</th>
                            </tr>
                        </thead>
                        <tbody id="sector-body"></tbody>
                    </table>
                </div>
            </div>
            <div>
                <h2>Session Summary</h2>
                <div id="summary-container" style="font-size:0.8em; color:#aaa;">
                    <span style="color:#888;">No summary available.</span>
                </div>
            </div>
            <div>
                <h2>AI / Data Tools</h2>
                <!-- NEW: select N fastest complete laps -->
                <div style="display:flex; align-items:center; gap:4px; margin-bottom: 15px;">
                    <label style="font-size:0.78rem; color:#ccc;">
                        Fastest
                        <select id="fastest-lap-count"
                                style="margin-left:2px; padding:2px 4px; border-radius:4px; border:1px solid #444; background:#222; color:#eee;">
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="20">20</option>
                            <option value="30">30</option>
                            <option value="40">40</option>
                            <option value="50">50</option>
                        </select>
                        laps
                    </label>
                    <button id="select-fastest-laps" style="flex-shrink:0; padding:4px 8px; font-size:0.78rem;">
                        Select
                    </button>
                </div>
                <div style="display:flex; flex-direction:column; gap:6px; font-size:0.85em;">
                    <button id="export-training-data">Export Training Data (CSV)</button>

                    <!-- Load CSV back in for AI assistant -->
                    <button id="load-training-csv">Load Training CSV</button>
                    <input type="file" id="training-file-input" accept=".csv" style="display:none;">

                    <!-- Open AI setup assistant modal -->
                    <button id="open-setup-assistant">AI Setup Assistant</button>
                    <button id="open-pit-card-modal">Pit Card</button>
                    <button id="export-lap-report" style="background-color: #17a2b8;">Export Full Lap Report (CSV)</button>
                </div>
            </div>
            <div>
                <h2>Contact</h2>
                <p style="font-size: 0.8em; color: #888;">
                    Questions or feedback? Email us at: <br>
                    <a href="mailto:hello@rapidtelem.com" style="color: var(--primary-color); text-decoration: none;">hello@rapidtelem.com</a>
                </p>
                <p style="font-size: 0.8em; color: #888; margin-top: 5px;">
                    Explore the project on GitHub: <br>
                                                   <a href="https://github.com/mhmatthew/rapidtelem" target="_blank" rel="noopener noreferrer" style="color: var(--primary-color); text-decoration: none;">github.com/mhmatthew/rapidtelem</a>
                </p>
            </div>
        </aside>

        <section id="chart-container">
            <div class="chart-wrapper">
                <canvas id="delta-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="speed-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="throttle-brake-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="steering-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="rpm-gear-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <div class="chart-help-icon"
                     title="Suspension Velocity Histogram:
- X axis: damper shaft velocity in mm/s (negative = bump/compression, positive = rebound/extension).
- Y axis: number of samples at that speed.
- A smooth, roughly symmetric shape around 0 mm/s usually indicates a well-balanced damper.
- Tall bars near 0 mm/s → damper spends most time at low speed (stiffer feel).
- Significant bars far from 0 mm/s → frequent high-speed movement (softer or heavily worked corner).">
                    ?
                </div>
                <canvas id="suspension-velocity-chart"></canvas>
            </div>

            <div class="chart-wrapper" id="damper-rec-wrapper" style="height:auto; padding:10px;">
                <h3 style="margin:0 0 8px; font-size:0.95rem; color:#ccc; cursor:help;"
                    title="Each corner shows mean and σ (sigma) for damper velocity:
- mean (mm/s): average shaft speed. Near 0 → balanced bump/rebound. Negative → bump bias, positive → rebound bias.
- σ (mm/s): how wide the velocity spread is. Low σ → stiffer / less movement. High σ → softer / more movement.
Use these with the text below to decide whether to soften or stiffen bump/rebound at each corner.
Application:
• If the recommendation shows a bump bias (too much bump / not enough rebound), reduce bump and/or add rebound to improve grip and compliance.
• If the recommendation shows a rebound bias (too much rebound / not enough bump), reduce rebound and/or add bump so the suspension can move and recover more freely.">
                    Damper Recommendations
                </h3>

                <div id="damper-rec-content" style="font-size:0.8rem; color:#aaa;"></div>
            </div>
            <div class="chart-wrapper">
                <div class="chart-help-icon"
                     title="Combined G-Forces Scatter:
- Each point is one moment on track: X = Longitudinal G (braking/throttle), Y = Lateral G (cornering).
- Negative X: braking, positive X: acceleration.
- Negative Y: left-hand cornering load, positive Y: right-hand cornering load.
- The outer ‘cloud’ shape shows the maximum combined grip you’re using.
- Compare laps: denser outer points for one lap often mean better use of available grip, if the car is still stable.">
                    ?
                </div>
                <canvas id="gforce-scatter-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="temp-lf-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="temp-rf-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="temp-lr-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="temp-rr-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="corner-load-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="corner-load-all-chart"></canvas>  <!-- all selected laps -->
            </div>
            <div class="chart-wrapper">
                <canvas id="ride-height-lf-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="ride-height-rf-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="ride-height-lr-chart"></canvas>
            </div>
            <div class="chart-wrapper">
                <canvas id="ride-height-rr-chart"></canvas>
            </div>

        </section>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>


    <script>
        // --- Global State ---
        let telemetryData = []; // Stores ALL laps (valid, invalid, out/in)
        let charts = {};
        let currentFullscreenChartWrapper = null;
        let setupByBaseName = {}; // e.g. { "mysetup": { spring_F: ..., ... } }
        let referenceLapId = null; // ID of the lap selected as reference
        const defaultVisibleLapIds = new Set(); // IDs of laps checked visible by default
        const defaultColors = ['#007bff', '#ff4500', '#28a745', '#ffc107', '#17a2b8', '#6f42c1', '#e83e8c'];

        // Variables to track last hovered point for cursor stability
        let lastHoveredMapCoords = null;

        // NEW: Toggle state for ABS shaded areas
        let showAbsAreas = false;

        // NEW: global pit wear snapshots
        let allPitWearSnapshots = [];

        // --- NEW: Minimum time for a lap to be considered valid/complete ---
        const MIN_VALID_LAP_TIME = 10; // seconds.


        // SVG icons for the button
        const fullscreenIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3m-18 0V19a2 2 0 0 0 2 2h3"></path></svg>`;
        const exitFullscreenIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 4H5a2 2 0 0 0-2 2v3m18 0V6a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3m-18 0V18a2 2 0 0 0 2 2h3"></path></svg>`;

        function addFullscreenButton(chartWrapper, chartInstance) {
            const btn = document.createElement('button');
            btn.className = 'fullscreen-btn';
            btn.innerHTML = fullscreenIcon; // Initial icon
            btn.title = 'Toggle Fullscreen';

            btn.addEventListener('click', () => {
                toggleChartFullscreen(chartWrapper, chartInstance, btn);
            });
            chartWrapper.appendChild(btn);
        }

        function toggleChartFullscreen(targetWrapper, chartInstance, buttonElement) {
            const chartContainer = document.getElementById('chart-container');

            // Store references to all potentially affected charts
            const allCharts = Object.values(charts).filter(c => c && c.canvas && c.canvas.id !== 'suspension-velocity-chart' && c.canvas.id !== 'gforce-scatter-chart');


            // If this chart is already fullscreen, exit fullscreen
            if (targetWrapper.classList.contains('is-fullscreen')) {
                targetWrapper.classList.remove('is-fullscreen');
                chartContainer.classList.remove('fullscreen-active');
                buttonElement.innerHTML = fullscreenIcon;
                currentFullscreenChartWrapper = null;
            } else {
                // If another chart is fullscreen, exit that one first
                if (currentFullscreenChartWrapper && currentFullscreenChartWrapper !== targetWrapper) {
                    currentFullscreenChartWrapper.classList.remove('is-fullscreen');
                    const otherBtn = currentFullscreenChartWrapper.querySelector('.fullscreen-btn');
                    if (otherBtn) otherBtn.innerHTML = fullscreenIcon;
                }

                // Enter fullscreen for the target chart
                targetWrapper.classList.add('is-fullscreen');
                chartContainer.classList.add('fullscreen-active');
                buttonElement.innerHTML = exitFullscreenIcon;
                currentFullscreenChartWrapper = targetWrapper;
            }

            // Crucially, trigger Chart.js to resize itself after DOM manipulation
            // Use a small delay to ensure CSS transitions/layout changes are complete
            // We now resize ALL relevant charts to ensure they pick up their correct container dimensions
            setTimeout(() => {
                allCharts.forEach(chart => {
                    // Check if the chart's wrapper is currently visible
                    const chartElement = chart.canvas;
                    const chartWrapper = chartElement.closest('.chart-wrapper');
                    if (chartWrapper && chartWrapper.offsetParent !== null) { // offsetParent is null if display: none
                        chart.resize();
                    } else {
                        // If the chart is hidden, we explicitly ensure its internal state is prepared for when it becomes visible
                        // Forcing an update can sometimes help it wake up correctly when display:block
                        chart.update('none');
                    }
                });
            }, 50); // Small delay to let CSS apply
        }



        // --- Utility function for debouncing ---
        function debounce(func, delay) {
            let timeout;
            return function (...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        // Helper function to interpolate Y value based on X (distance)
        function getInterpolatedMapCoords(lapData, distance) {
            if (!lapData || lapData.distance.length === 0) return null;

            const distances = lapData.distance;
            const mapX = lapData.mapX;
            const mapY = lapData.mapY;

            let i = 0;
            while (i < distances.length && distances[i] < distance) {
                i++;
            }

            if (i === 0) return { x: mapX[0], y: mapY[0] };
            if (i >= distances.length) return { x: mapX[distances.length - 1], y: mapY[distances.length - 1] };

            const x1 = distances[i - 1];
            const y1_mapX = mapX[i - 1];
            const y1_mapY = mapY[i - 1];

            const x2 = distances[i];
            const y2_mapX = mapX[i];
            const y2_mapY = mapY[i];

            if (x1 === x2) return { x: y1_mapX, y: y1_mapY };

            const ratio = (distance - x1) / (x2 - x1);
            const interpolatedMapX = y1_mapX + (y2_mapX - y1_mapX) * ratio;
            const interpolatedMapY = y1_mapY + (y2_mapY - y1_mapY) * ratio;

            return { x: interpolatedMapX, y: interpolatedMapY };
        }


        // --- IBT Parser (Now including LapInvalid, BrakeABSactive, G-Forces, SessionInfo, and Dynamic Tire Wear) ---
        class IBTParser {
            constructor(buffer) {
                this.buffer = buffer;
                this.view = new DataView(buffer);
                this.header = {};
                this.vars = [];
            }

            readHeader() {
                // Based on irsdk_header layout
                this.header.version = this.view.getInt32(0, true);  // irsdk_ver
                this.header.sessionInfoLen = this.view.getInt32(8, true);  // irsdk_sessionInfoLen
                this.header.sessionInfoOffset = this.view.getInt32(12, true);  // irsdk_sessionInfoOffset
                this.header.numVars = this.view.getInt32(24, true);  // irsdk_numVars
                this.header.varHeaderOffset = this.view.getInt32(28, true);  // irsdk_varHeaderOffset
                this.header.bufLen = this.view.getInt32(36, true);  // irsdk_bufLen
                this.header.bufOffset = this.view.getInt32(52, true);  // irsdk_bufOffset
                this.header.sessionInfoLen = this.view.getInt32(16, true); // sessionInfoLen
                this.header.sessionInfoOffset = this.view.getInt32(20, true); // sessionInfoOffset
            }

            readVarHeaders() {
                const decoder = new TextDecoder('windows-1252');
                const VAR_HEADER_SIZE = 144;
                for (let i = 0; i < this.header.numVars; i++) {
                    const offset = this.header.varHeaderOffset + (i * VAR_HEADER_SIZE);
                    const type = this.view.getInt32(offset, true);
                    const varOffset = this.view.getInt32(offset + 4, true);
                    const name = decoder.decode(new Uint8Array(this.buffer, offset + 16, 32)).replace(/\0/g, '');
                    this.vars.push({ name, type, offset: varOffset });
                }
            }

            parse() {
                try {
                    this.readHeader();
                    this.readVarHeaders();

                    const varMap = new Map();
                    this.vars.forEach(v => varMap.set(v.name, v));

                    // --- Read SessionInfo text (YAML/INI-style) ---
                    let sessionInfoStr = '';
                    if (this.header.sessionInfoLen > 0 && this.header.sessionInfoOffset > 0) {
                        const bytes = new Uint8Array(
                            this.buffer,
                            this.header.sessionInfoOffset,
                            this.header.sessionInfoLen
                        );
                        sessionInfoStr = new TextDecoder('utf-8')
                            .decode(bytes)
                            .replace(/\0+$/, '');
                    }
                    this.header.sessionInfoStr = sessionInfoStr;

                    // Helper to choose primary/fallback var names
                    const resolveVarName = (primary, fallback = null) => {
                        if (varMap.has(primary)) return primary;
                        if (fallback && varMap.has(fallback)) return fallback;
                        return null;
                    };

                    const requiredVars = {
                        'Lap': 'Lap',
                        'LapDist': 'LapDist',
                        'Speed': 'Speed',
                        'RPM': 'RPM',
                        'Gear': 'Gear',
                        'Throttle': 'Throttle',
                        'Brake': 'Brake',
                        'Steering': 'SteeringWheelAngle',
                        'SessionTime': 'SessionTime',
                        'Lat': 'Lat',
                        'Lon': 'Lon',

                        // Use LapInvalidated primarily
                        'LapInvalid': resolveVarName('LapInvalidated', 'LapInvalid'),

                        'BrakeABSactive': 'BrakeABSactive',
                        'FuelLevel': 'FuelLevel',

                        'LFshockVel': 'LFshockVel',
                        'RFshockVel': 'RFshockVel',
                        'LRshockVel': 'LRshockVel',
                        'RRshockVel': 'RRshockVel',

                        'gForceLat': 'LatAccel',
                        'gForceLong': 'LongAccel',

                        // ADD THESE:
                        'LFRideHeight': 'LFrideHeight', // Try this first
                        'RFRideHeight': 'RFrideHeight', // Try this first
                        'LRRideHeight': 'LRrideHeight', // Try this first
                        'RRRideHeight': 'LRrideHeight', // Try this first
                        // Some cars use 'RideHeight_LF', etc. The parser helper will return null if not found.

                        'PlayerTrackSurface': 'PlayerTrackSurface',

                        // --- Tire Temp (Surface Middle) ---
                        'LFtemp': 'LFtempM',
                        'RFtemp': 'RFtempM',
                        'LRtemp': 'LRtempM',
                        'RRtemp': 'RRtempM', 

                        // Pit‑stall wear (only valid in stall)
                        'LFwearL': 'LFwearL',
                        'RFwearL': 'RFwearL',
                        'LRwearL': 'LRwearL',
                        'RRwearL': 'RRwearL'
                    };

                    const targetVars = {};
                    for (const [key, ibtName] of Object.entries(requiredVars)) {
                        if (ibtName && varMap.has(ibtName)) {
                            targetVars[key] = varMap.get(ibtName);
                        } else {
                            console.info(`IBTParser: '${ibtName}' not present in file (key '${key}').`);
                            targetVars[key] = null;
                        }
                    }

                    const parsed = this.readDataBuffer(targetVars);
                    parsed.sessionInfoStr = sessionInfoStr;
                    return parsed;
                } catch (e) {
                    throw new Error("Failed to parse IBT: " + e.message);
                }
            }


            readDataBuffer(targetVars) {
                const dataStart = this.header.bufOffset;
                const totalBytes = this.buffer.byteLength;
                const rowCount = Math.floor((totalBytes - dataStart) / this.header.bufLen);

                // NOTE: now we also track pit wear snapshots
                const result = { laps: [], pitWearSnapshots: [] };

                let currentLap = -1;
                let currentLapData = null;

                const getValue = (rowOffset, varDef) => {
                    if (!varDef) return 0;
                    const pos = rowOffset + varDef.offset;
                    switch (varDef.type) {
                        case 0: return this.view.getInt8(pos);
                        case 1: return this.view.getUint8(pos);
                        case 2: return this.view.getInt32(pos, true);
                        case 3: return this.view.getUint32(pos, true);
                        case 4: return this.view.getFloat32(pos, true);
                        case 5: return this.view.getFloat64(pos, true);
                        default: return 0;
                    }
                };

                const MS2_TO_G = 1 / 9.80665;

                for (let i = 0; i < rowCount; i++) {
                    const rowOffset = dataStart + (i * this.header.bufLen);
                    const lapNum = getValue(rowOffset, targetVars.Lap);

                    if (lapNum !== currentLap) {
                        if (currentLapData && currentLapData.data.distance.length > 50) {
                            currentLapData.lapTime =
                                currentLapData.data.time[currentLapData.data.time.length - 1] -
                                currentLapData.data.time[0];
                            result.laps.push(currentLapData);
                        }
                        currentLap = lapNum;
                        currentLapData = this.createLapData(lapNum);
                    }

                    if (!currentLapData) continue;

                    const time = getValue(rowOffset, targetVars.SessionTime);
                    const lat = getValue(rowOffset, targetVars.Lat);
                    const lon = getValue(rowOffset, targetVars.Lon);
                    const lapInvalid = getValue(rowOffset, targetVars.LapInvalid);
                    const brakeABSactive = getValue(rowOffset, targetVars.BrakeABSactive);
                    const trackSurface = getValue(rowOffset, targetVars.PlayerTrackSurface);

                    currentLapData.data.time.push(time);
                    currentLapData.data.distance.push(getValue(rowOffset, targetVars.LapDist));
                    currentLapData.data.speed.push(getValue(rowOffset, targetVars.Speed) * 3.6);
                    currentLapData.data.rpm.push(getValue(rowOffset, targetVars.RPM));
                    currentLapData.data.gear.push(getValue(rowOffset, targetVars.Gear));
                    currentLapData.data.throttle.push(getValue(rowOffset, targetVars.Throttle) * 100);
                    currentLapData.data.brake.push(getValue(rowOffset, targetVars.Brake) * 100);
                    currentLapData.data.steering.push(getValue(rowOffset, targetVars.Steering));
                    currentLapData.data.rawLat.push(lat);
                    currentLapData.data.rawLon.push(lon);
                    currentLapData.data.brakeABSactive.push(brakeABSactive);

                    if (targetVars.FuelLevel) {
                        currentLapData.data.fuelLevel.push(getValue(rowOffset, targetVars.FuelLevel));
                    }

                    if (targetVars.LFshockVel) currentLapData.data.shockVelLF.push(getValue(rowOffset, targetVars.LFshockVel));
                    if (targetVars.RFshockVel) currentLapData.data.shockVelRF.push(getValue(rowOffset, targetVars.RFshockVel));
                    if (targetVars.LRshockVel) currentLapData.data.shockVelLR.push(getValue(rowOffset, targetVars.LRshockVel));
                    if (targetVars.RRshockVel) currentLapData.data.shockVelRR.push(getValue(rowOffset, targetVars.RRshockVel));

                    // G-forces in G
                    if (targetVars.gForceLat) {
                        const latMs2 = getValue(rowOffset, targetVars.gForceLat);
                        currentLapData.data.gForceLat.push(latMs2 * MS2_TO_G);
                    }
                    if (targetVars.gForceLong) {
                        const longMs2 = getValue(rowOffset, targetVars.gForceLong);
                        currentLapData.data.gForceLong.push(longMs2 * MS2_TO_G);
                    }

                    // Store in meters (iRacing default) or convert to mm immediately if preferred. 
                    // Let's store as raw meters here to match typical data structure.
                    if (targetVars.LFRideHeight) currentLapData.data.rideHeightLF.push(getValue(rowOffset, targetVars.LFRideHeight));
                    if (targetVars.RFRideHeight) currentLapData.data.rideHeightRF.push(getValue(rowOffset, targetVars.RFRideHeight));
                    if (targetVars.LRRideHeight) currentLapData.data.rideHeightLR.push(getValue(rowOffset, targetVars.LRRideHeight));
                    if (targetVars.RRRideHeight) currentLapData.data.rideHeightRR.push(getValue(rowOffset, targetVars.RRRideHeight));

                    // We check for the 'LFtemp' key we defined in requiredVars (which maps to LFtempM)
                    if (targetVars.LFtemp) currentLapData.data.tempLF.push(getValue(rowOffset, targetVars.LFtemp));
                    if (targetVars.RFtemp) currentLapData.data.tempRF.push(getValue(rowOffset, targetVars.RFtemp));
                    if (targetVars.LRtemp) currentLapData.data.tempLR.push(getValue(rowOffset, targetVars.LRtemp));
                    if (targetVars.RRtemp) currentLapData.data.tempRR.push(getValue(rowOffset, targetVars.RRtemp));

                    // Mark invalid by flag
                    if (lapInvalid > 0) {
                        currentLapData.lapMetadata.isValidByFlag = false;
                    }

                    // PIT‑STALL WEAR SNAPSHOTS (PlayerTrackSurface = 2 => InPitStall)
                    if (typeof trackSurface === 'number' && trackSurface === 2 &&
                        targetVars.LFwearL && targetVars.RFwearL &&
                        targetVars.LRwearL && targetVars.RRwearL) {

                        const lfWear = getValue(rowOffset, targetVars.LFwearL);
                        const rfWear = getValue(rowOffset, targetVars.RFwearL);
                        const lrWear = getValue(rowOffset, targetVars.LRwearL);
                        const rrWear = getValue(rowOffset, targetVars.RRwearL);

                        result.pitWearSnapshots.push({
                            time,
                            lapNumber: currentLap,
                            LF: lfWear,
                            RF: rfWear,
                            LR: lrWear,
                            RR: rrWear
                        });
                    }
                }

                if (currentLapData && currentLapData.data.distance.length > 50) {
                    currentLapData.lapTime =
                        currentLapData.data.time[currentLapData.data.time.length - 1] -
                        currentLapData.data.time[0];
                    result.laps.push(currentLapData);
                }

                return result;
            }


            createLapData(lapNum) {
                return {
                    lapNumber: lapNum,
                    lapTime: 0,
                    data: {
                        distance: [], speed: [], rpm: [], gear: [], throttle: [], brake: [],
                        steering: [], time: [],
                        rawLat: [], rawLon: [],
                        mapX: [], mapY: [],
                        brakeABSactive: [],
                        fuelLevel: [],
                        shockVelLF: [], shockVelRF: [], shockVelLR: [], shockVelRR: [],
                        rideHeightLF: [], rideHeightRF: [], rideHeightLR: [], rideHeightRR: [],
                        gForceLat: [], gForceLong: [],
                        tempLF: [], tempRF: [], tempLR: [], tempRR: [],

                        // ADD: dynamic normal loads (per sample)
                        normalLoadFL: [],
                        normalLoadFR: [],
                        normalLoadLR: [],
                        normalLoadRR: []
                    },
                    lapMetadata: {
                        isValidByFlag: true,
                        isOutlap: false,
                        isInlap: false,
                        isComplete: false,
                        isFastestInFile: false,
                        isConsideredValid: false
                    },
                    avgSpeed: 0,
                    maxSpeed: 0,
                    minSpeed: 0,
                    fuelUsed: null,
                    tireWearEndLF: null,
                    tireWearEndRF: null,
                    tireWearEndLR: null,
                    tireWearEndRR: null,

                    // ADD: per‑lap load summary (filled later)
                    loadSummary: null
                };
            }
        }



        function updateSummary() {
            const el = document.getElementById('summary-container');
            if (!el) return;

            if (telemetryData.length === 0) {
                el.innerHTML = '<span style="color:#888;">No data loaded.</span>';
                return;
            }

            // Group laps by filename
            const byFile = {};
            telemetryData.forEach(lap => {
                if (!byFile[lap.filename]) byFile[lap.filename] = [];
                byFile[lap.filename].push(lap);
            });

            const blocks = [];

            Object.keys(byFile).forEach(filename => {
                const laps = byFile[filename];

                // Use first lap from this file for SessionInfo
                const firstLap = laps[0];
                const si = firstLap.sessionInfoStr || '';
                const info = parseSessionInfo(si);

                // Best valid lap in this file
                const bestLap = laps.reduce((best, l) =>
                    (l.lapMetadata && l.lapMetadata.isConsideredValid && l.lapTime < best.lapTime ? l : best),
                    { lapTime: Infinity }
                );

                const trackName = info.trackName || 'Unknown';
                const trackLength = info.trackLength || 'n/a';
                const sessionName = info.sessionName || 'n/a';

                const airTemp = info.airTemp || 'n/a';
                const trackTemp = info.trackTemp || 'n/a';
                const skies = info.skies || 'n/a';
                const wind = info.windVel || 'n/a';
                const humidity = info.humidity || 'n/a';

                const bestLapStr = bestLap.lapTime !== Infinity
                    ? `L${bestLap.lapNumber} – ${formatTime(bestLap.lapTime)}`
                    : 'n/a';

                blocks.push(`
                        <div style="margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #333;">
                            <div><strong>File:</strong> ${filename}</div>
                            <div><strong>Track:</strong> ${trackName}</div>
                            <div><strong>Length:</strong> ${trackLength}</div>
                            <div><strong>Session:</strong> ${sessionName}</div>
                            <div style="margin-top:4px;"><strong>Air Temp:</strong> ${airTemp}</div>
                            <div><strong>Track Temp:</strong> ${trackTemp}</div>
                            <div><strong>Skies:</strong> ${skies}</div>
                            <div><strong>Wind:</strong> ${wind}</div>
                            <div><strong>Humidity:</strong> ${humidity}</div>
                            <div style="margin-top:4px;"><strong>Laps Loaded (this file):</strong> ${laps.length}</div>
                            <div><strong>Best Lap (this file):</strong> ${bestLapStr}</div>
                        </div>
                    `);
            });

            el.innerHTML = blocks.join('');
        }


        // --- Application Logic ---
        function updateStatus(msg, type) {
            const el = document.getElementById('status-container');
            el.innerHTML = `<div class="status ${type}">${msg}</div>`;
        }

        // Helper function to get sector time for a specific lap and sector definition
        const getSectorTimeForLap = (lap, sectorStartDistance, sectorEndDistance) => {
            if (!lap || !lap.data || lap.data.distance.length === 0) return 0;

            let sIdx = lap.data.distance.findIndex(d => d >= sectorStartDistance);
            if (sIdx === -1) sIdx = 0;

            let eIdx = lap.data.distance.findIndex(d => d >= sectorEndDistance);

            if (eIdx === -1 || eIdx <= sIdx) {
                return 0;
            }

            return lap.data.time[eIdx] - lap.data.time[sIdx];
        };

        // Very simple CarSetup parser out of SessionInfo string.
        // This looks for a "CarSetup:" block and then for key = value lines under it.
        // You can extend the key list as needed for your car.
        function parseSetupFromSessionInfo(sessionInfoStr) {
            if (!sessionInfoStr) return {};

            let doc;
            try {
                doc = jsyaml.load(sessionInfoStr);
            } catch (e) {
                console.warn('YAML parse error for SessionInfo:', e);
                return {};
            }
            if (!doc || !doc.CarSetup) {
                console.warn('CarSetup not found in parsed SessionInfo');
                return {};
            }

            const cs = doc.CarSetup;
            const setup = {};

            if (!window.__rtvLoggedCarSetup) {
                console.log('RAW CarSetup for this car:', JSON.stringify(cs, null, 2));
                window.__rtvLoggedCarSetup = true;
            }

            const ta = cs.TiresAero || cs['Tires / Aero'] || {};

            if (ta.TireType && ta.TireType.TireType) {
                setup.TireType = ta.TireType.TireType;
            }

            function copyTireCorner(prefix, src) {
                if (!src) return;
                setup[`${prefix}_StartingPressure`] = src.StartingPressure || '';
                setup[`${prefix}_LastHotPressure`] = src.LastHotPressure || '';
                setup[`${prefix}_LastTempsOMI`] = src.LastTempsOMI || src.LastTempsIMO || '';
                setup[`${prefix}_TreadRemaining`] = src.TreadRemaining || '';
            }

            copyTireCorner('LF', ta.LeftFront);
            copyTireCorner('RF', ta.RightFront);
            copyTireCorner('LR', ta.LeftRear);
            copyTireCorner('RR', ta.RightRear);

            // Unified aero block: Ferrari + Porsche
            const aero = ta.AeroBalanceCalc || cs.Aero || {};
            setup.FrontRhAtSpeed = aero.FrontRhAtSpeed || '';
            setup.RearRhAtSpeed = aero.RearRhAtSpeed || '';
            setup.FrontDownforce = aero.FrontDownforce || '';

            // Wing: some cars use RearWingAngle, some use WingSetting
            setup.RearWingAngle = (
                aero.RearWingAngle ??
                aero.WingSetting ??   // <‑‑ Porsche GT3: "WingSetting": "12.7 degrees"
                ''
            );

            // ===== CHASSIS =====
            const ch = cs.Chassis || {};
            const fbl = ch.FrontBrakesLights || {};
            const front = ch.Front || ch.FrontSuspension || {};
            const rear = ch.Rear || ch.RearSuspension || {};
            const fuel = cs.Fuel || cs.FuelSystem || {};

            // Front ARB: prefer explicit Front node, fall back to FrontBrakesLights
            setup.ArbBlades = (
                front.ArbBlades ??
                front.AntiRollBarSetting ??
                fbl.ArbBlades ??
                fbl.AntiRollBarSetting ??
                fbl.ArbSetting ??       // <‑‑ Porsche GT3 front ARB
                ''
            );
            setup.ArbOptions = (
                front.ArbOptions ??
                front.AntiRollBarOptions ??
                fbl.ArbOptions ??
                ''
            );

            // Misc front / brake items
            setup.TotalToeIn = fbl.TotalToeIn || front.TotalToeIn || '';
            setup.FrontMasterCyl = fbl.FrontMasterCyl || front.FrontMasterCyl || '';
            setup.RearMasterCyl = fbl.RearMasterCyl || front.RearMasterCyl || '';
            setup.BrakePads = fbl.BrakePads || front.BrakePads || '';
            setup.EnduranceLights = fbl.EnduranceLights || front.EnduranceLights || '';
            setup.NightLedStripColor = fbl.NightLedStripColor || front.NightLedStripColor || '';
            setup.CenterFrontSplitterHeight = fbl.CenterFrontSplitterHeight || front.CenterFrontSplitterHeight || '';

            // In-car adjustments (existing behaviour)
            const adj = ch.InCarAdjustments || {};
            setup.BrakePressureBias = adj.BrakePressureBias || '';
            setup.AbsSetting = adj.AbsSetting || '';
            setup.TcSetting = adj.TcSetting || '';
            setup.ThrottleShapeSetting = adj.ThrottleShapeSetting || '';
            setup.DashDisplayPage = adj.DashDisplayPage || '';
            setup.FWtdist = adj.FWtdist || '';
            setup.CrossWeight = adj.CrossWeight || '';

            // Per-corner chassis (unchanged)
            function copyCorner(prefix, src) {
                if (!src) return;
                setup[`${prefix}_CornerWeight`] = src.CornerWeight || '';
                setup[`${prefix}_RideHeight`] = src.RideHeight || '';
                setup[`${prefix}_BumpRubberGap`] = src.BumpRubberGap || '';
                setup[`${prefix}_SpringRate`] = src.SpringRate || '';
                setup[`${prefix}_Camber`] = src.Camber || '';
                setup[`${prefix}_ToeIn`] = src.ToeIn || '';
            }

            copyCorner('LF', ch.LeftFront);
            copyCorner('RF', ch.RightFront);
            copyCorner('LR', ch.LeftRear);
            copyCorner('RR', ch.RightRear);

            // NEW – Ferrari + Porsche (RarbSetting)
            setup.RearArbBlades = (
                rear.ArbBlades ??
                rear.AntiRollBarSetting ??
                rear.RarbSetting ??      // <‑‑ Porsche GT3 rear ARB
                ''
            );
            setup.RearArbOptions = (
                rear.ArbOptions ??
                rear.AntiRollBarOptions ??
                ''
            );

            // Rear wing: let Chassis.Rear override aero if present
            if (rear.WingSetting != null && rear.WingSetting !== '') {
                setup.RearWingAngle = rear.WingSetting;        // Porsche: Chassis.Rear.WingSetting
            } else if (rear.RearWingAngle != null && rear.RearWingAngle !== '') {
                setup.RearWingAngle = rear.RearWingAngle;
            }
            setup.RearWingAngle_Rear = setup.RearWingAngle;    // used by CSV/export

            // Fuel: prefer dedicated Fuel block, fallback to Chassis.Rear.FuelLevel
            setup.FuelLevel_Rear = (
                fuel.FuelLevel ??
                fuel.FuelFill ??        // some cars use this name
                rear.FuelLevel ??        // some cars put it on Chassis.Rear
                fbl.FuelLevel ??        // <‑‑ Porsche GT3 fuel in FrontBrakesLights
                ''
            );

            // Rear wing: let Chassis.Rear override aero if present
            if (rear.RearWingAngle != null && rear.RearWingAngle !== '') {
                setup.RearWingAngle = rear.RearWingAngle;
            }
            setup.RearWingAngle_Rear = setup.RearWingAngle;   // used by CSV/export

            // Gears / Differential
            const gd = ch.GearsDifferential || {};
            setup.GearStack = gd.GearStack || '';
            setup.FrictionFaces = gd.FrictionFaces ?? '';
            setup.DiffPreload = gd.DiffPreload || '';

            // ===== DAMPERS (axle-level) =====
            const damp = cs.Dampers || {};
            const fd = damp.FrontDampers || {};
            const rd = damp.RearDampers || {};

            // Front axle values
            setup.Front_LSC = fd.LowSpeedCompressionDamping || '';
            setup.Front_HSC = fd.HighSpeedCompressionDamping || '';
            setup.Front_LSR = fd.LowSpeedReboundDamping || '';
            setup.Front_HSR = fd.HighSpeedReboundDamping || '';

            // Rear axle values
            setup.Rear_LSC = rd.LowSpeedCompressionDamping || '';
            setup.Rear_HSC = rd.HighSpeedCompressionDamping || '';
            setup.Rear_LSR = rd.LowSpeedReboundDamping || '';
            setup.Rear_HSR = rd.HighSpeedReboundDamping || '';


            return setup;
        }



        function parseSessionInfo(sessionInfoStr) {
            if (!sessionInfoStr) return {};

            let doc;
            try {
                doc = jsyaml.load(sessionInfoStr);
            } catch (e) {
                console.warn('YAML parse error for SessionInfo:', e);
                return {};
            }

            const info = {};

            // --- Existing info extraction (track, weather, etc.) ---
            // Track info (try several common keys)
            info.trackName =
                match(/TrackDisplayName:\s*([^\r\n]+)/i) ||
                match(/TrackName:\s*([^\r\n]+)/i);

            info.trackLength =
                match(/TrackLength:\s*([^\r\n]+)/i);

            info.sessionName =
                match(/SessionName:\s*([^\r\n]+)/i) ||
                match(/SessionType:\s*([^\r\n]+)/i);

            info.sessionTimeOfDay =
                match(/SessionTimeOfDay:\s*([^\r\n]+)/i);

            // Weather – prefer *Crew variants, then fall back
            info.airTemp =
                match(/AirTempCrew:\s*([^\r\n]+)/i) ||
                match(/AirTemp:\s*([^\r\n]+)/i);

            info.trackTemp =
                match(/TrackTempCrew:\s*([^\r\n]+)/i) ||
                match(/TrackTemp:\s*([^\r\n]+)/i);

            info.skies =
                match(/Skies:\s*([^\r\n]+)/i);

            info.windVel =
                match(/WindVel:\s*([^\r\n]+)/i) ||
                match(/WindSpeed:\s*([^\r\n]+)/i);

            info.humidity =
                match(/RelativeHumidity:\s*([^\r\n]+)/i) ||
                match(/Humidity:\s*([^\r\n]+)/i);
            // --- END Existing info extraction ---


            // --- NEW/UPDATED: Extract Car Name for specific targets ---
            if (doc.DriverInfo && doc.DriverInfo.Drivers && Array.isArray(doc.DriverInfo.Drivers)) {
                // Find the player's car index if available
                const playerCarIdx = doc.DriverInfo.DriverCarIdx;

                if (typeof playerCarIdx === 'number' && doc.DriverInfo.Drivers[playerCarIdx]) {
                    // Prioritize CarScreenName, then CarPath, then fallback
                    info.carScreenName = doc.DriverInfo.Drivers[playerCarIdx].CarScreenName || doc.DriverInfo.Drivers[playerCarIdx].CarPath || 'Unknown Car';
                } else if (doc.DriverInfo.Drivers.length > 0) {
                    // Fallback: If no explicit playerCarIdx or it's invalid, use the first driver's car
                    info.carScreenName = doc.DriverInfo.Drivers[0].CarScreenName || doc.DriverInfo.Drivers[0].CarPath || 'Unknown Car';
                }
            } else {
                info.carScreenName = 'Unknown Car'; // No driver info found
            }
            // --- END NEW/UPDATED ---

            return info;

            // Helper to get the first regex group match (ensure it's still available)
            function match(re) {
                const m = sessionInfoStr.match(re);
                return m && m[1] ? m[1].trim() : null;
            }
        }


        // --- NEW: Lap Report Export Logic ---

        // 1. Listener
        document.getElementById('export-lap-report').addEventListener('click', exportLapReport);

        // 2. Time Formatter (mm:ss.000)
        function formatTimeForCsv(seconds) {
            if (!seconds || isNaN(seconds) || seconds === 0) return "";

            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.round((seconds % 1) * 1000);

            // Returns format like "1:24.123"
            return `${m}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }

        // ... (keep your existing `formatTimeForCsv` and `getSectorTimeForLap` functions) ...

        // 3. Main Export Function (UPDATED - Tire Data Removed)
        function exportLapReport() {
            if (!telemetryData.length) {
                alert('No laps loaded.');
                return;
            }

            // A. Determine Sector Split Distances (based on a single, robust reference lap)
            // These markers define where S1 ends and S2 ends on the track itself.
            let refLapForSectorMarkers = telemetryData.find(l => l.id === referenceLapId) ||
                telemetryData.find(l => l.lapMetadata.isFastestOverall) ||
                telemetryData.find(l => l.lapMetadata.isComplete && l.data.distance.length > 0);

            let s1MarkerDist = 0; // Distance marker for end of Sector 1 (on track)
            let s2MarkerDist = 0; // Distance marker for end of Sector 2 (on track)

            if (refLapForSectorMarkers && refLapForSectorMarkers.data.distance.length > 0) {
                const refLapTotalDist = refLapForSectorMarkers.data.distance[refLapForSectorMarkers.data.distance.length - 1];
                if (refLapTotalDist > 0) { // Ensure it's a meaningful distance
                    s1MarkerDist = refLapTotalDist / 3;
                    s2MarkerDist = (refLapTotalDist / 3) * 2;
                }
            } else {
                console.warn("No suitable reference lap found to define consistent sector markers for CSV export.");
            }

            // B. Build CSV Rows
            const rows = [];

            // Define headers - SIMPLIFIED, ONLY GENERAL LAP/FUEL DATA
            const headers = [
                'File', 'Lap', 'Valid_Lap', 'Was_Inlap', 'Was_Outlap', 'Lap_Time', 'S1_Time', 'S2_Time', 'S3_Time',
                'Fuel_Used_L', 'Fuel_Start_L'
            ];
            rows.push(headers.map(h => `"${h}"`).join(',')); // Quote all headers

            // Iterate ALL laps in order of array
            telemetryData.forEach(lap => {
                // For each lap, we need its OWN total distance for the end of Sector 3 calculation.
                const currentLapOwnTotalDist = (lap.data.distance.length > 0) ? lap.data.distance[lap.data.distance.length - 1] : 0;

                // Calculate sector times dynamically.
                const s1Time = getSectorTimeForLap(lap, 0, s1MarkerDist);
                const s2Time = getSectorTimeForLap(lap, s1MarkerDist, s2MarkerDist);
                const s3Time = getSectorTimeForLap(lap, s2MarkerDist, currentLapOwnTotalDist);

                const rowData = [
                    `"${lap.filename}"`,
                    lap.lapNumber,
                    lap.lapMetadata.isConsideredValid ? 'Yes' : 'No', // "Valid" based on your criteria
                    lap.lapMetadata.isInlap ? 'Yes' : 'No',
                    lap.lapMetadata.isOutlap ? 'Yes' : 'No',
                    formatTimeForCsv(lap.lapTime),
                    formatTimeForCsv(s1Time),
                    formatTimeForCsv(s2Time),
                    formatTimeForCsv(s3Time),
                    (lap.fuelUsed !== null && lap.fuelUsed !== undefined) ? lap.fuelUsed.toFixed(3) : '', // Fuel consumed during the lap
                    (lap.data.fuelLevel && lap.data.fuelLevel.length > 0) ? lap.data.fuelLevel[0].toFixed(2) : '' // Fuel at start of lap

                    // REMOVED ALL TIRE WEAR AND SETUP TIRE DATA HERE
                ];

                rows.push(rowData.join(','));
            });

            // C. Download
            const csvContent = rows.join('\n');
            downloadCsv(csvContent, 'Full_Lap_Report.csv');
        }



        document.getElementById('export-training-data')
            .addEventListener('click', exportTrainingData);


        function exportTrainingData() {
            if (!telemetryData.length) {
                alert('No laps loaded.');
                return;
            }

            // --- Prepare Sector Definitions ---
            const refLapForSectors = telemetryData.find(l => l.id === referenceLapId) ||
                telemetryData.find(l => l.lapMetadata.isFastestOverall); // Ensure this flag is set if you need it, otherwise remove.

            let sectorDefinitions = [];
            if (refLapForSectors && refLapForSectors.data.distance.length > 0) {
                const maxDist = refLapForSectors.data.distance[refLapForSectors.data.distance.length - 1];
                // Ensure maxDist is a positive, finite number to prevent division by zero or errors
                if (maxDist > 0 && Number.isFinite(maxDist)) {
                    const sectorSize = maxDist / 3; // Dividing into 3 sectors
                    sectorDefinitions = [
                        { id: 'S1', start: 0, end: sectorSize },
                        { id: 'S2', start: sectorSize, end: sectorSize * 2 },
                        { id: 'S3', start: sectorSize * 2, end: maxDist }
                    ];
                } else {
                    console.warn("Could not determine max track distance for sector definitions. Sector metrics will be empty.");
                }
            } else {
                alert('No suitable reference lap found to define sectors. Export might be incomplete.');
                // We can continue, but sector metrics will be empty.
            }

            // --- Filter and Pre-calculate Per-Sector Metrics for each valid, selected lap ---
            const validLaps = telemetryData.filter(lap =>
                lap.lapMetadata &&
                lap.lapMetadata.isComplete &&
                defaultVisibleLapIds.has(lap.id)   // only laps the user has selected/checked
            );

            if (!validLaps.length) {
                alert('No complete selected laps to export. Check some laps in the Laps list first.');
                return;
            }


            validLaps.forEach(lap => {
                lap.sectorMetrics = {}; // Initialize an object to store per-sector data for this lap
                sectorDefinitions.forEach(def => {
                    lap.sectorMetrics[def.id] = computeLapSectorMetrics(lap, def.start, def.end);
                });
            });

            // --- 1. DEFINE THE MASTER SCHEMA (INCLUDING NEW FIELDS) ---
            const columns = [
                // Basics
                { header: 'file', fn: l => l.filename || '' },
                { header: 'lapNumber', fn: l => l.lapNumber },
                { header: 'lapTime', fn: l => l.lapTime },
                { header: 'avgSpeed', fn: l => (l.avgSpeed !== null && l.avgSpeed !== undefined) ? l.avgSpeed.toFixed(2) : '' },
                { header: 'maxSpeed', fn: l => (l.maxSpeed !== null && l.maxSpeed !== undefined) ? l.maxSpeed.toFixed(2) : '' },
                { header: 'minSpeed', fn: l => (l.minSpeed !== null && l.minSpeed !== undefined) ? l.minSpeed.toFixed(2) : '' },
                { header: 'fuelUsed', fn: l => (l.fuelUsed !== null && l.fuelUsed !== undefined) ? l.fuelUsed.toFixed(3) : '' },

                // *** NEW: Add this line to get the actual fuel at start of lap ***
                { header: 'FuelLevel_Start', fn: l => (l.data.fuelLevel && l.data.fuelLevel.length > 0) ? l.data.fuelLevel[0].toFixed(2) : '' },

                // --- NEW: End-of-Lap Dynamic Tire Wear ---
                { header: 'TireWearEnd_LF', fn: l => (l.tireWearEndLF !== null && l.tireWearEndLF !== undefined) ? l.tireWearEndLF.toFixed(2) : '' },
                { header: 'TireWearEnd_RF', fn: l => (l.tireWearEndRF !== null && l.tireWearEndRF !== undefined) ? l.tireWearEndRF.toFixed(2) : '' },
                { header: 'TireWearEnd_LR', fn: l => (l.tireWearEndLR !== null && l.tireWearEndLR !== undefined) ? l.tireWearEndLR.toFixed(2) : '' },
                { header: 'TireWearEnd_RR', fn: l => (l.tireWearEndRR !== null && l.tireWearEndRR !== undefined) ? l.tireWearEndRR.toFixed(2) : '' },

                // Per-Sector Data
                { header: 'S1_Time', fn: l => l.sectorMetrics?.S1?.sectorTime ? l.sectorMetrics.S1.sectorTime.toFixed(3) : '' },
                { header: 'S1_MinSpeed', fn: l => l.sectorMetrics?.S1?.minSpeed ? l.sectorMetrics.S1.minSpeed.toFixed(2) : '' },
                { header: 'S1_MaxSpeed', fn: l => l.sectorMetrics?.S1?.maxSpeed ? l.sectorMetrics.S1.maxSpeed.toFixed(2) : '' },
                { header: 'S2_Time', fn: l => l.sectorMetrics?.S2?.sectorTime ? l.sectorMetrics.S2.sectorTime.toFixed(3) : '' },
                { header: 'S2_MinSpeed', fn: l => l.sectorMetrics?.S2?.minSpeed ? l.sectorMetrics.S2.minSpeed.toFixed(2) : '' },
                { header: 'S2_MaxSpeed', fn: l => l.sectorMetrics?.S2?.maxSpeed ? l.sectorMetrics.S2.maxSpeed.toFixed(2) : '' },
                { header: 'S3_Time', fn: l => l.sectorMetrics?.S3?.sectorTime ? l.sectorMetrics.S3.sectorTime.toFixed(3) : '' },
                { header: 'S3_MinSpeed', fn: l => l.sectorMetrics?.S3?.minSpeed ? l.sectorMetrics.S3.minSpeed.toFixed(2) : '' },
                { header: 'S3_MaxSpeed', fn: l => l.sectorMetrics?.S3?.maxSpeed ? l.sectorMetrics.S3.maxSpeed.toFixed(2) : '' },

                // Damper Stats (Telemetry Analysis)
                { header: 'damperMean_LF', fn: l => (l.svStats?.LF?.mean !== null && l.svStats?.LF?.mean !== undefined) ? l.svStats.LF.mean.toFixed(6) : '' },
                { header: 'damperSigma_LF', fn: l => (l.svStats?.LF?.stdDev !== null && l.svStats?.LF?.stdDev !== undefined) ? l.svStats.LF.stdDev.toFixed(6) : '' },
                { header: 'damperMean_RF', fn: l => (l.svStats?.RF?.mean !== null && l.svStats?.RF?.mean !== undefined) ? l.svStats.RF.mean.toFixed(6) : '' },
                { header: 'damperSigma_RF', fn: l => (l.svStats?.RF?.stdDev !== null && l.svStats?.RF?.stdDev !== undefined) ? l.svStats.RF.stdDev.toFixed(6) : '' },
                { header: 'damperMean_LR', fn: l => (l.svStats?.LR?.mean !== null && l.svStats?.LR?.mean !== undefined) ? l.svStats.LR.mean.toFixed(6) : '' },
                { header: 'damperSigma_LR', fn: l => (l.svStats?.LR?.stdDev !== null && l.svStats?.LR?.stdDev !== undefined) ? l.svStats.LR.stdDev.toFixed(6) : '' },
                { header: 'damperMean_RR', fn: l => (l.svStats?.RR?.mean !== null && l.svStats?.RR?.mean !== undefined) ? l.svStats.RR.mean.toFixed(6) : '' },
                { header: 'damperSigma_RR', fn: l => (l.svStats?.RR?.stdDev !== null && l.svStats?.RR?.stdDev !== undefined) ? l.svStats.RR.stdDev.toFixed(6) : '' },

                // Setup: Tires (Static from SessionInfo, initial state)
                { header: 'TireType', fn: l => l.setup?.TireType ?? '' },
                { header: 'LF_StartingPressure', fn: l => l.setup?.LF_StartingPressure ?? '' },
                { header: 'LF_LastHotPressure', fn: l => l.setup?.LF_LastHotPressure ?? '' },
                { header: 'LF_LastTempsOMI', fn: l => l.setup?.LF_LastTempsOMI ?? '' },
                { header: 'RF_StartingPressure', fn: l => l.setup?.RF_StartingPressure ?? '' },
                { header: 'RF_LastHotPressure', fn: l => l.setup?.RF_LastHotPressure ?? '' },
                { header: 'RF_LastTempsOMI', fn: l => l.setup?.RF_LastTempsOMI ?? '' },
                { header: 'LR_StartingPressure', fn: l => l.setup?.LR_StartingPressure ?? '' },
                { header: 'LR_LastHotPressure', fn: l => l.setup?.LR_LastHotPressure ?? '' },
                { header: 'LR_LastTempsOMI', fn: l => l.setup?.LR_LastTempsOMI ?? '' },
                { header: 'RR_StartingPressure', fn: l => l.setup?.RR_StartingPressure ?? '' },
                { header: 'RR_LastHotPressure', fn: l => l.setup?.RR_LastHotPressure ?? '' },
                { header: 'RR_LastTempsOMI', fn: l => l.setup?.RR_LastTempsOMI ?? '' },

                // Setup: Aero
                { header: 'FrontRhAtSpeed', fn: l => l.setup?.FrontRhAtSpeed ?? '' },
                { header: 'RearRhAtSpeed', fn: l => l.setup?.RearRhAtSpeed ?? '' },
                { header: 'RearWingAngle', fn: l => l.setup?.RearWingAngle ?? '' },
                { header: 'FrontDownforce', fn: l => l.setup?.FrontDownforce ?? '' },

                // Setup: Chassis & Brakes (Front/Common)
                { header: 'ArbBlades_Front', fn: l => l.setup?.ArbBlades ?? '' },
                { header: 'ArbOptions_Front', fn: l => l.setup?.ArbOptions ?? '' },
                { header: 'TotalToeIn', fn: l => l.setup?.TotalToeIn ?? '' },
                { header: 'FrontMasterCyl', fn: l => l.setup?.FrontMasterCyl ?? '' },
                { header: 'RearMasterCyl', fn: l => l.setup?.RearMasterCyl ?? '' },
                { header: 'BrakePads', fn: l => l.setup?.BrakePads ?? '' },
                { header: 'BrakePressureBias', fn: l => l.setup?.BrakePressureBias ?? '' },
                { header: 'AbsSetting', fn: l => l.setup?.AbsSetting ?? '' },
                { header: 'TcSetting', fn: l => l.setup?.TcSetting ?? '' },
                { header: 'CrossWeight', fn: l => l.setup?.CrossWeight ?? '' },

                // Setup: Chassis Per Corner (Springs, Ride Height, Camber)
                { header: 'LF_SpringRate', fn: l => l.setup?.LF_SpringRate ?? '' },
                { header: 'LF_RideHeight', fn: l => l.setup?.LF_RideHeight ?? '' },
                { header: 'LF_Camber', fn: l => l.setup?.LF_Camber ?? '' },
                { header: 'LF_BumpRubberGap', fn: l => l.setup?.LF_BumpRubberGap ?? '' },
                { header: 'RF_SpringRate', fn: l => l.setup?.RF_SpringRate ?? '' },
                { header: 'RF_RideHeight', fn: l => l.setup?.RF_RideHeight ?? '' },
                { header: 'RF_Camber', fn: l => l.setup?.RF_Camber ?? '' },
                { header: 'RF_BumpRubberGap', fn: l => l.setup?.RF_BumpRubberGap ?? '' },
                { header: 'LR_SpringRate', fn: l => l.setup?.LR_SpringRate ?? '' },
                { header: 'LR_RideHeight', fn: l => l.setup?.LR_RideHeight ?? '' },
                { header: 'LR_Camber', fn: l => l.setup?.LR_Camber ?? '' },
                { header: 'LR_BumpRubberGap', fn: l => l.setup?.LR_BumpRubberGap ?? '' },
                { header: 'RR_SpringRate', fn: l => l.setup?.RR_SpringRate ?? '' },
                { header: 'RR_RideHeight', fn: l => l.setup?.RR_RideHeight ?? '' },
                { header: 'RR_Camber', fn: l => l.setup?.RR_Camber ?? '' },
                { header: 'RR_BumpRubberGap', fn: l => l.setup?.RR_BumpRubberGap ?? '' },

                // Setup: Rear & Differential
                { header: 'FuelLevel_Rear', fn: l => l.setup?.FuelLevel_Rear ?? '' },
                { header: 'RearArbBlades', fn: l => l.setup?.RearArbBlades ?? '' },
                { header: 'RearArbOptions', fn: l => l.setup?.RearArbOptions ?? '' },
                { header: 'GearStack', fn: l => l.setup?.GearStack ?? '' },
                { header: 'FrictionFaces', fn: l => l.setup?.FrictionFaces ?? '' },
                { header: 'DiffPreload', fn: l => l.setup?.DiffPreload ?? '' },

                // Setup: Dampers (Axle-level)
                { header: 'Front_LSC', fn: l => l.setup?.Front_LSC ?? '' },
                { header: 'Front_HSC', fn: l => l.setup?.Front_HSC ?? '' },
                { header: 'Front_LSR', fn: l => l.setup?.Front_LSR ?? '' },
                { header: 'Front_HSR', fn: l => l.setup?.Front_HSR ?? '' },
                { header: 'Rear_LSC', fn: l => l.setup?.Rear_LSC ?? '' },
                { header: 'Rear_HSC', fn: l => l.setup?.Rear_HSC ?? '' },
                { header: 'Rear_LSR', fn: l => l.setup?.Rear_LSR ?? '' },
                { header: 'Rear_HSR', fn: l => l.setup?.Rear_HSR ?? '' }
            ];

            // --- 3. Generate CSV String with a Validation Row ---
            const csv = convertRowsToCsv(validLaps, columns, true); // Pass true to include validation row
            downloadCsv(csv, 'training_data.csv');
        }

        // --- Make sure to use these helper functions too ---

        function convertRowsToCsv(laps, columns, includeValidationRow = false) {
            if (!laps || !laps.length || !columns) return '';

            // A. Identify which columns have at least one non-empty value across all laps
            // Always keep the first 3 (file, lap, time)
            const alwaysKeepHeaders = new Set(['file', 'lapNumber', 'lapTime']);

            const activeColumns = columns.filter(col => {
                if (alwaysKeepHeaders.has(col.header)) return true;

                // check if any lap has a value for this column
                return laps.some(lap => {
                    const val = col.fn(lap);
                    return val !== null && val !== undefined && String(val).trim() !== '';
                });
            });

            const lines = [];

            // B. Write Header Row
            const headerRow = activeColumns.map(c => escapeCsvValue(c.header)).join(',');
            lines.push(headerRow);

            // C. (NEW) Write Validation Row if requested
            if (includeValidationRow) {
                const validationRow = activeColumns.map((_, index) => escapeCsvValue(index + 1)).join(',');
                lines.push(validationRow);
            }

            // D. Write Data Rows
            laps.forEach(lap => {
                const rowValues = activeColumns.map(col => {
                    const rawVal = col.fn(lap);
                    return escapeCsvValue(rawVal);
                });
                lines.push(rowValues.join(','));
            });

            return lines.join('\n');
        }

        // Helper to handle commas/quotes within data
        function escapeCsvValue(v) {
            if (v === null || v === undefined) return '';
            const str = String(v);
            if (str.includes('"') || str.includes(',') || str.includes('\n')) {
                return '"' + str.replace(/"/g, '""') + '"';
            }
            return str;
        }


        function downloadCsv(csvText, fileName) {
            const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();

            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }





        // Handle Multiple Files
        document.getElementById('file-import').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            updateStatus(`Reading ${files.length} file(s)...`, 'info');

            telemetryData = [];
            defaultVisibleLapIds.clear();
            lastHoveredMapCoords = null;

            // NEW: Clear zoom history on new file import
            zoomHistory = [];

            let allRawLaps = [];
            allPitWearSnapshots = [];

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const buffer = await file.arrayBuffer();
                    const parser = new IBTParser(buffer);
                    const parsedData = parser.parse();
                    const sessionInfoStr = parsedData.sessionInfoStr || '';

                    parsedData.laps.forEach(lap => {
                        lap.filename = file.name;
                        const dotIndex = file.name.lastIndexOf('.');
                        lap.filenameWithoutExt = dotIndex > 0 ? file.name.substring(0, dotIndex) : file.name;
                        lap.sessionInfoStr = sessionInfoStr;

                        const setupObj = parseSetupFromSessionInfo(sessionInfoStr);
                        lap.setup = setupObj;

                        // NEW: static tire temps parsed from LastTempsOMI in setup
                        lap.tireTempsStatic = {
                            LF: parseOMI(lap.setup?.LF_LastTempsOMI),
                            RF: parseOMI(lap.setup?.RF_LastTempsOMI),
                            LR: parseOMI(lap.setup?.LR_LastTempsOMI),
                            RR: parseOMI(lap.setup?.RR_LastTempsOMI),
                        };

                        allRawLaps.push(lap);
                    });

                    function parseOMI(str) {
                        if (!str) return null;
                        const parts = str.split(/[ ,]+/).map(Number).filter(x => !isNaN(x));
                        if (parts.length !== 3) return null;
                        const [O, M, I] = parts;
                        const avg = (O + M + I) / 3;
                        const insideMinusOutside = I - O;
                        const middleMinusEdges = M - (I + O) / 2;
                        return { O, M, I, avg, insideMinusOutside, middleMinusEdges };
                    }

                    // collect wear snapshots too
                    if (parsedData.pitWearSnapshots && parsedData.pitWearSnapshots.length) {
                        parsedData.pitWearSnapshots.forEach(snap => {
                            allPitWearSnapshots.push({
                                ...snap,
                                filename: file.name
                            });
                        });
                    }

                } catch (err) {
                    console.error(`Error parsing ${file.name}:`, err);
                    updateStatus(`Error parsing ${file.name}`, 'error');
                }
            }

            allPitWearSnapshots.sort((a, b) => a.time - b.time);


            if (allRawLaps.length === 0) {
                updateStatus('No laps found in imported files.', 'error');
                updateLapList();
                updateCharts();
                return;
            }

            // --- GLOBAL MAP COORDINATE CALCULATION ---
            const EARTH_RADIUS = 6371000;
            let globalOriginLat = null;
            let globalOriginLon = null;

            for (const lap of allRawLaps) {
                for (let i = 0; i < lap.data.rawLat.length; i++) {
                    if (lap.data.rawLat[i] !== 0 && lap.data.rawLon[i] !== 0) {
                        globalOriginLat = lap.data.rawLat[i];
                        globalOriginLon = lap.data.rawLon[i];
                        break;
                    }
                }
                if (globalOriginLat !== null) break;
            }

            // Calculate mapX and mapY for all laps using the global origin
            allRawLaps.forEach(lap => {
                lap.data.mapX = [];
                lap.data.mapY = [];
                for (let i = 0; i < lap.data.rawLat.length; i++) {
                    const lat = lap.data.rawLat[i];
                    const lon = lap.data.rawLon[i];

                    let x = 0, y = 0;
                    if (globalOriginLat !== null) {
                        x = (lon - globalOriginLon) * (Math.PI / 180) * EARTH_RADIUS * Math.cos(globalOriginLat * Math.PI / 180);
                        y = (lat - globalOriginLat) * (Math.PI / 180) * EARTH_RADIUS;
                    }
                    lap.data.mapX.push(x);
                    lap.data.mapY.push(y);
                }
                delete lap.data.rawLat;
                delete lap.data.rawLon;
            });
            // --- END GLOBAL MAP COORDINATE CALCULATION ---

            const lapsByFilename = {};
            allRawLaps.forEach((lap, index) => {
                lap.id = index;
                lap.color = defaultColors[index % defaultColors.length];
                if (!lapsByFilename[lap.filename]) {
                    lapsByFilename[lap.filename] = [];
                }
                lapsByFilename[lap.filename].push(lap);
                telemetryData.push(lap);
            });

            // Calculate average speed, max speed, min speed, and fuel used for each lap
            telemetryData.forEach(lap => {
                // Average / max / min speed
                if (lap.data.speed.length > 0) {
                    lap.avgSpeed = lap.data.speed.reduce((sum, s) => sum + s, 0) / lap.data.speed.length;
                    lap.maxSpeed = Math.max(...lap.data.speed);
                    const movingSpeeds = lap.data.speed.filter(s => s > 1); // ignore near‑zero
                    lap.minSpeed = movingSpeeds.length > 0 ? Math.min(...movingSpeeds) : 0;
                } else {
                    lap.avgSpeed = 0;
                    lap.maxSpeed = 0;
                    lap.minSpeed = 0;
                }

                // Fuel used
                if (lap.data.fuelLevel && lap.data.fuelLevel.length > 1) {
                    const startFuel = lap.data.fuelLevel[0];
                    const endFuel = lap.data.fuelLevel[lap.data.fuelLevel.length - 1];
                    lap.fuelUsed = (startFuel > endFuel) ? (startFuel - endFuel) : null;
                } else {
                    lap.fuelUsed = null;
                }

                // Do NOT set tireWearEnd* here anymore; assignWearToLapsFromSnapshots() will handle that
            });

            // AFTER avgSpeed / fuelUsed are computed for all laps
            telemetryData.forEach(lap => {
                const vp = buildVehicleParamsFromSetup(lap);
                if (!vp) return;

                computeNormalLoadsForLap(lap, vp);
                buildLoadSummaryForLap(lap);
            });


            let maxTrackDistance = 0;
            telemetryData.forEach(lap => {
                if (lap.lapMetadata.isValidByFlag && lap.data.distance.length > 100 && lap.lapTime > MIN_VALID_LAP_TIME) {
                    maxTrackDistance = Math.max(maxTrackDistance, lap.data.distance[lap.data.distance.length - 1]);
                }
            });
            if (maxTrackDistance < 100) maxTrackDistance = 1000;

            const firstSectorEndDistance = maxTrackDistance / 3;

            telemetryData.forEach(lap => {
                const isFullDistance = lap.data.distance.length > 100 && lap.data.distance[lap.data.distance.length - 1] > (maxTrackDistance * 0.9);
                const firstSectorTime = getSectorTimeForLap(lap, 0, firstSectorEndDistance);
                lap.lapMetadata.isComplete = isFullDistance && (firstSectorTime > 0.5);
            });

            for (const filename in lapsByFilename) {
                const fileLaps = lapsByFilename[filename].sort((a, b) => a.lapNumber - b.lapNumber);
                if (fileLaps.length > 0) {
                    fileLaps[0].lapMetadata.isOutlap = !fileLaps[0].lapMetadata.isComplete || fileLaps[0].lapTime < MIN_VALID_LAP_TIME;
                    if (fileLaps.length > 1) {
                        fileLaps[fileLaps.length - 1].lapMetadata.isInlap = !fileLaps[fileLaps.length - 1].lapMetadata.isComplete || fileLaps[fileLaps.length - 1].lapTime < MIN_VALID_LAP_TIME;
                    }
                }
            }

            telemetryData.forEach(lap => {
                lap.lapMetadata.isConsideredValid =
                    lap.lapTime >= MIN_VALID_LAP_TIME &&
                    lap.lapMetadata.isComplete &&
                    !lap.lapMetadata.isOutlap &&
                    !lap.lapMetadata.isInlap &&
                    lap.lapMetadata.isValidByFlag;
            });

            const lap11 = telemetryData.find(l => l.lapNumber === 11);
            if (lap11) {
                console.log(`[DEBUG_VALIDITY] Lap 11 (ID: ${lap11.id}) - isConsideredValid: ${lap11.lapMetadata.isConsideredValid}`);
                console.log(`[DEBUG_VALIDITY]   isComplete: ${lap11.lapMetadata.isComplete}`);
                console.log(`[DEBUG_VALIDITY]   isOutlap: ${lap11.lapMetadata.isOutlap}`);
                console.log(`[DEBUG_VALIDITY]   isInlap: ${lap11.lapMetadata.isInlap}`);
                console.log(`[DEBUG_VALIDITY]   isValidByFlag: ${lap11.lapMetadata.isValidByFlag}`);
                console.log(`[DEBUG_VALIDITY]   lapTime: ${lap11.lapTime}, distance.length: ${lap11.data.distance.length}`);

                // Also check maxTrackDistance which influences isComplete
                let currentMaxTrackDistance = 0;
                telemetryData.forEach(l => {
                    if (l.lapMetadata.isValidByFlag && l.data.distance.length > 100 && l.lapTime > MIN_VALID_LAP_TIME) {
                        currentMaxTrackDistance = Math.max(currentMaxTrackDistance, l.data.distance[l.data.distance.length - 1]);
                    }
                });
                console.log(`[DEBUG_VALIDITY]   Calculated maxTrackDistance (influencing isComplete): ${currentMaxTrackDistance}`);
                const isFullDistanceCheck = lap11.data.distance.length > 100 && lap11.data.distance[lap11.data.distance.length - 1] > (currentMaxTrackDistance * 0.9);
                console.log(`[DEBUG_VALIDITY]   isFullDistance check for Lap 11: ${isFullDistanceCheck}`);
            }


            let fastestOverallValidLap = null;

            for (const filename in lapsByFilename) {
                const validCandidateLapsInFile = lapsByFilename[filename].filter(l => l.lapMetadata.isConsideredValid);

                if (validCandidateLapsInFile.length > 0) {
                    const fastestInFile = validCandidateLapsInFile.reduce((prev, curr) =>
                        (curr.lapTime < prev.lapTime ? curr : prev),
                        { lapTime: Infinity });

                    if (fastestInFile.lapTime !== Infinity) {
                        fastestInFile.lapMetadata.isFastestInFile = true;
                        defaultVisibleLapIds.add(fastestInFile.id);
                        if (!fastestOverallValidLap || fastestInFile.lapTime < fastestOverallValidLap.lapTime) {
                            fastestOverallValidLap = fastestInFile;
                        }
                    }
                }
            }

            referenceLapId = fastestOverallValidLap ? fastestOverallValidLap.id : null;
            assignWearToLapsFromSnapshots();
            updateLapList();
            updateStatus(`Loaded ${telemetryData.length} laps from ${files.length} files.`, 'success');

            defaultVisibleLapIds.forEach(lapId => {
                const checkbox = document.querySelector(`#lap-selector input[type="checkbox"][value="${lapId}"]`);
                if (checkbox) checkbox.checked = true;
            });

            updateCharts();
            saveCurrentMasterZoom();
            updateSummary();

        });

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds) || seconds === Infinity) return "--:--.--";
            const m = Math.floor(seconds / 60);
            const s = (seconds % 60).toFixed(3);
            return `${m}:${s.padStart(6, '0')}`;
        }

        function updateLapList() {
            const container = document.getElementById('lap-selector');
            container.innerHTML = '';
            if (telemetryData.length === 0) {
                container.innerHTML = '<p style="color: #888; font-style: italic;">No laps loaded.</p>';
                return;
            }

            telemetryData.forEach((lap) => {
                const isRef = lap.id === referenceLapId;
                const isChecked = defaultVisibleLapIds.has(lap.id);

                let statusHtml = '';
                if (!lap.lapMetadata.isValidByFlag) {
                    statusHtml += '<span class="invalid" title="Lap flagged as invalid by iRacing (e.g., track cut).">INVALID</span>';
                } else if (lap.lapMetadata.isOutlap) {
                    statusHtml += '<span class="outin" title="Outlap (first lap in session/file, likely incomplete or slow).">OUT</span>';
                } else if (lap.lapMetadata.isInlap) {
                    statusHtml += '<span class="outin" title="Inlap (last lap in session/file, likely incomplete or slow).">IN</span>';
                } else if (!lap.lapMetadata.isComplete) {
                    statusHtml += '<span class="invalid" title="Lap did not cover the full track distance or did not record a meaningful first sector.">INCOMPLETE</span>';
                } else if (lap.lapMetadata.isFastestInFile) {
                    statusHtml += '<span class="complete" title="Fastest valid and complete lap in this file.">FASTEST</span>';
                } else if (lap.lapTime < MIN_VALID_LAP_TIME) {
                    statusHtml += '<span class="invalid" title="Lap is too short to be considered valid.">SHORT</span>';
                }

                const div = document.createElement('div');
                div.className = `lap-item ${isRef ? 'is-reference' : ''}`;
                div.innerHTML = `
                                <div style="display:flex; flex-direction:column; gap:2px; margin-right:8px;">
                                    <input type="checkbox" value="${lap.id}" onchange="toggleLapVisibility(${lap.id}, this.checked)" ${isChecked ? 'checked' : ''}>
                                    <input type="radio" name="refLap" class="ref-radio" value="${lap.id}" title="Set as Reference Lap" onchange="setReferenceLap(${lap.id})" ${isRef ? 'checked' : ''}>
                                </div>
                                <div style="flex-grow:1; cursor:pointer;" onclick="toggleLapVisibility(${lap.id}, !document.querySelector('#lap-selector input[type=&quot;checkbox&quot;][value=&quot;${lap.id}&quot;]').checked)">
                                    <span class="lap-file-label" title="${lap.filename}">${lap.filename}</span>
                                    <div>Lap ${lap.lapNumber} - ${formatTime(lap.lapTime)}</div>
                                    <div style="font-size: 0.75em; color: #aaa; display: flex; gap: 8px; justify-content: space-between; margin-top: 2px;">
                                        <span>Fuel: ${lap.fuelUsed !== null ? lap.fuelUsed.toFixed(2) + 'L' : 'N/A'}</span>
                                        <span>Avg Spd: ${lap.avgSpeed.toFixed(1)}kph</span>
                                        <span>Max Spd: ${lap.maxSpeed.toFixed(1)}kph</span>
                                    </div>
                                    <div class="lap-status">${statusHtml}</div>
                                </div>
                                <input type="color" value="${lap.color}" onchange="updateLapColor(${lap.id}, this.value)">
                            `;
                container.appendChild(div);
            });
        }

        function toggleLapVisibility(id, isChecked) {
            if (isChecked) {
                defaultVisibleLapIds.add(id);
            } else {
                defaultVisibleLapIds.delete(id);
                if (referenceLapId === id) {
                    referenceLapId = null;
                }
            }
            updateLapList();
            updateCharts();
        }

        function setReferenceLap(id) {
            referenceLapId = id;
            defaultVisibleLapIds.add(id);
            updateLapList();
            const checkbox = document.querySelector(`input[type="checkbox"][value="${id}"]`);
            if (checkbox) checkbox.checked = true;
            updateCharts();
        }

        function updateLapColor(id, color) {
            const lap = telemetryData.find(l => l.id === id);
            if (lap) { lap.color = color; updateCharts(); }
        }

        // --- Calculation Logic ---

        function calculateTimeDelta(targetLap, refLap) {
            if (!targetLap || !refLap) return [];

            const refStart = refLap.data.time[0];
            const targetStart = targetLap.data.time[0];

            const deltas = refLap.data.distance.map((dist, i) => {
                const refElapsed = refLap.data.time[i] - refStart;

                let idx = -1;
                let minDiff = Infinity;

                const proportionalGuess = Math.floor((i / refLap.data.distance.length) * targetLap.data.distance.length);
                const searchWindow = 100;

                const startSearchIdx = Math.max(0, proportionalGuess - searchWindow);
                const endSearchIdx = Math.min(targetLap.data.distance.length, proportionalGuess + searchWindow);

                for (let k = startSearchIdx; k < endSearchIdx; k++) {
                    const dDiff = Math.abs(targetLap.data.distance[k] - dist);
                    if (dDiff < minDiff) {
                        minDiff = dDiff;
                        idx = k;
                    }
                }
                if (idx > -1) {
                    const targetElapsed = targetLap.data.time[idx] - targetStart;
                    return targetElapsed - refElapsed;
                } else {
                    return 0;
                }
            });

            return deltas;
        }

        function calculateSectors(selectedLaps, refLap) {
            if (!refLap) return { analysis: [], definitions: [], targetLap: null };

            const targetLap = selectedLaps.find(l => l.id !== refLap.id);

            const maxDist = refLap.data.distance[refLap.data.distance.length - 1];
            const sectorSize = maxDist / 3;
            const sectorDefinitions = [
                { id: 1, start: 0, end: sectorSize },
                { id: 2, start: sectorSize, end: sectorSize * 2 },
                { id: 3, start: sectorSize * 2, end: maxDist }
            ];

            const analysis = [];

            const getSectorTime = (lap, def) => {
                let sIdx = lap.data.distance.findIndex(d => d >= def.start);
                let eIdx = lap.data.distance.findIndex(d => d >= def.end);

                if (sIdx === -1) sIdx = 0;
                if (eIdx === -1 && lap.data.distance.length > 0) eIdx = lap.data.distance.length - 1;

                if (sIdx > -1 && eIdx > -1 && sIdx < eIdx) {
                    return lap.data.time[eIdx] - lap.data.time[sIdx];
                }
                return 0;
            };

            sectorDefinitions.forEach(def => {
                const refTime = getSectorTime(refLap, def);

                let delta = 0;
                let isDiff = false;

                if (targetLap) {
                    const targetTime = getSectorTime(targetLap, def);
                    delta = targetTime - refTime;
                    isDiff = true;
                }

                analysis.push({
                    id: def.id,
                    start: def.start,
                    end: def.end,
                    refTime: refTime,
                    delta: delta,
                    isDiff: isDiff
                });
            });

            return { analysis, definitions: sectorDefinitions, targetLap };
        }

        function updateSectorTable(sectorsData) {
            const tbody = document.getElementById('sector-body');
            tbody.innerHTML = '';

            const headerCell = document.querySelector('.sector-table th:last-child');
            headerCell.textContent = sectorsData.targetLap
                ? `Delta (vs L${sectorsData.targetLap.lapNumber})`
                : "Delta (vs Ref)";
            headerCell.title = sectorsData.targetLap ? `Comparing to Lap ${sectorsData.targetLap.lapNumber} from ${sectorsData.targetLap.filename}` : 'No comparison lap selected';

            sectorsData.analysis.forEach(sec => {
                const tr = document.createElement('tr');

                let deltaHtml = '<span style="color:#666">-</span>';
                if (sec.isDiff) {
                    let color = '#ccc';
                    if (sec.delta > 0.005) color = '#dc3545';
                    else if (sec.delta < -0.005) color = '#28a745';

                    const sign = sec.delta > 0 ? '+' : '';
                    deltaHtml = `<span style="color:${color}">${sign}${sec.delta.toFixed(3)}</span>`;
                } else if (sec.refTime > 0) {
                    deltaHtml = '<span style="color:#888; font-style:italic">Ref</span>';
                }

                tr.innerHTML = `
                                <td>S${sec.id}</td>
                                <td>${sec.refTime > 0 ? sec.refTime.toFixed(3) : '--.---'}</td>
                                <td>${deltaHtml}</td>
                            `;

                tr.addEventListener('click', () => {
                    zoomToSector(sec.start, sec.end);
                });

                tbody.appendChild(tr);
            });
        }

        function zoomToSector(start, end) {
            const masterChart = charts.delta;
            if (!masterChart || !masterChart.options.scales || !masterChart.options.scales.x) return;

            masterChart.options.scales.x.min = start;
            masterChart.options.scales.x.max = end;
            masterChart.update('none');

            syncScales(masterChart);
        }

        function assignWearToLapsFromSnapshots() {
            if (!allPitWearSnapshots.length || !telemetryData.length) {
                // If no snapshots or no laps, there's nothing to do.
                // Ensure that for all laps, wear is explicitly null if no data is found.
                telemetryData.forEach(lap => {
                    lap.tireWearEndLF = null; lap.tireWearEndRF = null;
                    lap.tireWearEndLR = null; lap.tireWearEndRR = null;
                });
                return;
            }

            // Sort snapshots by time to ensure correct processing order
            allPitWearSnapshots.sort((a, b) => a.time - b.time);

            // Create a temporary map to easily find the first snapshot *after* a lap.
            // This is for regular laps where we need the wear just before the next pit.
            const firstSnapAfterLap = new Map(); // Key: lap.id, Value: snapshot

            for (let i = 0; i < telemetryData.length; i++) {
                const lap = telemetryData[i];
                const lapEndTime = lap.data.time[lap.data.time.length - 1];

                let chosenSnap = null;
                // Search for a snapshot in the same file that occurs AFTER this lap's end
                // but before the next lap's end (if applicable) or the next pit.
                for (let j = 0; j < allPitWearSnapshots.length; j++) {
                    const snap = allPitWearSnapshots[j];
                    if (snap.filename === lap.filename && snap.time >= lapEndTime) {
                        chosenSnap = snap;
                        break; // Found the first relevant snapshot after this lap
                    }
                }
                if (chosenSnap) {
                    firstSnapAfterLap.set(lap.id, chosenSnap);
                }
            }


            // Now iterate through all laps and assign wear based on context
            telemetryData.forEach((lap, index) => {
                // --- Default to null ---
                lap.tireWearEndLF = null;
                lap.tireWearEndRF = null;
                lap.tireWearEndLR = null;
                lap.tireWearEndRR = null;

                // --- Priority 1: Outlap (assumed new tires) ---
                // If it's an outlap, we assume new tires were put on.
                if (lap.lapMetadata.isOutlap) {
                    lap.tireWearEndLF = 0.0;
                    lap.tireWearEndRF = 0.0;
                    lap.tireWearEndLR = 0.0;
                    lap.tireWearEndRR = 0.0;
                    return; // Move to next lap
                }

                // --- Priority 2: Inlap (wear from the last moment before pit stop) ---
                // For an inlap, we want the wear from the pit entry itself.
                // This is tricky as "pitWearSnapshots" are from *in* the pit stall.
                // A simple approach is to use the snapshot associated with this lap number,
                // if it happened within its time bounds.
                const snapshotsForThisLap = allPitWearSnapshots.filter(snap =>
                    snap.filename === lap.filename &&
                    snap.lapNumber === lap.lapNumber && // The snapshot happened within this lap's sequence
                    snap.time >= lap.data.time[0] &&
                    snap.time <= lap.data.time[lap.data.time.length - 1]
                );
                if (snapshotsForThisLap.length > 0) {
                    // Take the last snapshot from within this specific lap's boundaries
                    const lastSnapInLap = snapshotsForThisLap[snapshotsForThisLap.length - 1];
                    lap.tireWearEndLF = lastSnapInLap.LF;
                    lap.tireWearEndRF = lastSnapInLap.RF;
                    lap.tireWearEndLR = lastSnapInLap.LR;
                    lap.tireWearEndRR = lastSnapInLap.RR;
                    return; // Move to next lap
                }

                // --- Priority 3: Regular lap (wear just before the *next* pit stop) ---
                // For a regular flying lap, its wear is whatever state the tires were in
                // when the lap ended, which is often reflected by the wear in the next
                // pit stop snapshot (if any).
                const nextPitSnap = firstSnapAfterLap.get(lap.id);
                if (nextPitSnap) {
                    lap.tireWearEndLF = nextPitSnap.LF;
                    lap.tireWearEndRF = nextPitSnap.RF;
                    lap.tireWearEndLR = nextPitSnap.LR;
                    lap.tireWearEndRR = nextPitSnap.RR;
                    // No return here, as we continue to next lap.
                }
                // If no snapshot is found for any of the above, wear remains null.
            });
        }



        // --- Select N fastest complete laps (AI tools helper) ---
        const fastestCountSelect = document.getElementById('fastest-lap-count');
        const selectFastestBtn = document.getElementById('select-fastest-laps');

        if (fastestCountSelect && selectFastestBtn) {
            selectFastestBtn.addEventListener('click', () => {
                if (!telemetryData.length) {
                    alert('No laps loaded.');
                    return;
                }

                const n = parseInt(fastestCountSelect.value || '4', 10);

                // Use only laps that are complete and considered valid
                const candidates = telemetryData.filter(lap =>
                    lap.lapMetadata &&
                    lap.lapMetadata.isComplete &&
                    lap.lapMetadata.isConsideredValid &&
                    Number.isFinite(lap.lapTime) &&
                    lap.lapTime > 0
                );

                if (!candidates.length) {
                    alert('No complete, valid laps available.');
                    return;
                }

                // Sort by lapTime ascending
                const sorted = [...candidates].sort((a, b) => a.lapTime - b.lapTime);
                const chosen = sorted.slice(0, n);

                // Clear current selection, then add chosen laps
                defaultVisibleLapIds.clear();
                chosen.forEach(lap => defaultVisibleLapIds.add(lap.id));

                // Set reference lap as the fastest of the chosen
                referenceLapId = chosen[0].id;

                updateLapList();
                updateCharts();
                updateSummary && updateSummary();
            });
        }


        // --- Placemat helpers ---

        // Compute a few simple driving metrics for a lap over a distance window
        function computeLapSectorMetrics(lap, startDist, endDist) {
            if (!lap || !lap.data || !lap.data.distance.length) {
                return null;
            }

            const d = lap.data.distance;
            const t = lap.data.time;
            const spd = lap.data.speed;
            const thr = lap.data.throttle;
            const brk = lap.data.brake;
            const abs = lap.data.brakeABSactive || [];

            const idxs = [];
            for (let i = 0; i < d.length; i++) {
                if (d[i] >= startDist && d[i] <= endDist) idxs.push(i);
            }
            if (idxs.length === 0) return null;

            const firstIdx = idxs[0];
            const lastIdx = idxs[idxs.length - 1];

            const tStart = t[firstIdx];
            const tEnd = t[lastIdx];
            const sectorTime = tEnd - tStart;

            let minSpeed = Infinity, maxSpeed = -Infinity, sumSpeed = 0;
            let maxBrake = 0, maxThrottle = 0, sumThrottle = 0;

            // ABS time accumulation
            let absTime = 0;
            for (let i = 0; i < idxs.length - 1; i++) {
                const i0 = idxs[i];
                const i1 = idxs[i + 1];

                const s = spd[i0];
                const th = thr[i0];
                const bk = brk[i0];

                if (s < minSpeed) minSpeed = s;
                if (s > maxSpeed) maxSpeed = s;
                sumSpeed += s;

                if (bk > maxBrake) maxBrake = bk;
                if (th > maxThrottle) maxThrottle = th;
                sumThrottle += th;

                if (abs[i0] > 0) {
                    absTime += (t[i1] - t[i0]);
                }
            }

            const avgSpeed = sumSpeed / idxs.length;
            const avgThrottle = sumThrottle / idxs.length;

            let brakePointDist = null;
            for (let i of idxs) {
                if (brk[i] > 10) {
                    brakePointDist = d[i];
                    break;
                }
            }

            return {
                sectorTime,
                minSpeed,
                maxSpeed,
                avgSpeed,
                maxBrake,
                avgThrottle,
                brakePointDist,
                absTime   // seconds in ABS in this sector
            };
        }


        // Build two side-by-side SVG track maps (Ref left, Compare right),
        // showing ABS zones and yellow X at sector min-speed points
        function buildTwoTrackMapsSvg(refLap, compareLap, definitions, cornerDefs) {
            if (!refLap || !refLap.data || !refLap.data.mapX.length) return '';

            const laps = [refLap, compareLap].filter(Boolean);

            // Shared bounds
            // Shared bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            laps.forEach(lap => {
                lap.data.mapX.forEach(x => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                });
                lap.data.mapY.forEach(y => {
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                });
            });
            if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) {
                return '';
            }

            // ADD: pad bounds so track isn’t right on the SVG edge
            const rawWidth = maxX - minX || 1;
            const rawHeight = maxY - minY || 1;
            const padFrac = 0.05; // 5% padding on each side

            const padX = rawWidth * padFrac;
            const padY = rawHeight * padFrac;

            minX -= padX;
            maxX += padX;
            minY -= padY;
            maxY += padY;

            const width = maxX - minX || 1;
            const height = maxY - minY || 1;

            function toSvgX(x) { return ((x - minX) / width) * 1000; }
            function toSvgY(y) { return (1 - (y - minY) / height) * 700; } // 1000x700

            // Corner label positions (use refLap apex)
            function getCornerSvgPositions(lap, cornerDefs) {
                if (!cornerDefs || !cornerDefs.length) return [];
                const d = lap.data.distance;
                const xs = lap.data.mapX;
                const ys = lap.data.mapY;
                const v = lap.data.speed;

                const out = [];
                cornerDefs.forEach(c => {
                    // pick the min speed within [dStart, dEnd] as apex
                    let bestIdx = -1;
                    let bestSpeed = Infinity;
                    for (let i = 0; i < d.length; i++) {
                        if (d[i] < c.dStart || d[i] > c.dEnd) continue;
                        if (v[i] < bestSpeed) {
                            bestSpeed = v[i];
                            bestIdx = i;
                        }
                    }
                    if (bestIdx >= 0) {
                        out.push({
                            id: c.id,
                            x: toSvgX(xs[bestIdx]),
                            y: toSvgY(ys[bestIdx])
                        });
                    }
                });
                return out;
            }

            const cornerLabelsRef = getCornerSvgPositions(refLap, cornerDefs);
            const cornerLabelsCmp = compareLap ? getCornerSvgPositions(compareLap, cornerDefs) : [];



            function buildSingleSvg(lap, title, absColor, lineColor) {
                if (!lap) {
                    return `<div style="flex:1;padding:4px;box-sizing:border-box;">
<p style="font-size:11px;">Not available</p>
</div>`;
                }

                let svg = `<div style="flex:1;padding:4px;box-sizing:border-box;">
<h3 style="margin:4px 0;font-size:13px;font-weight:bold;">${title}</h3>
<svg class="placemat-svg-map two-maps-svg" viewBox="0 0 1000 700" xmlns="http://www.w3.org/2000/svg"
                  style="width:100%;border:1px solid #444;background:#ffffff;">`

                const dists = lap.data.distance;
                const xs = lap.data.mapX;
                const ys = lap.data.mapY;
                const abs = lap.data.brakeABSactive || [];
                const times = lap.data.time || [];
                const speeds = lap.data.speed || [];

                // --- ABS segments (with gap check) ---
                if (dists.length && abs.length) {
                    let inSeg = false;
                    let segPoints = [];
                    let lastIdx = -1;

                    const MAX_DIST_GAP = 30;   // m
                    const MAX_TIME_GAP = 1.0;  // s

                    function flushSeg() {
                        if (segPoints.length < 2) return;
                        const pathData = segPoints.map((p, i) =>
                            (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ' ' + p.y.toFixed(1)
                        ).join(' ');
                        svg += `<path d="${pathData}" stroke="${absColor}"
                                             stroke-width="18" stroke-linecap="round" stroke-linejoin="round"
                                             fill="none" opacity="0.85"/>`;
                        segPoints = [];
                    }

                    for (let i = 0; i < dists.length; i++) {
                        const active = abs[i] > 0;
                        const px = toSvgX(xs[i]);
                        const py = toSvgY(ys[i]);

                        if (active) {
                            if (inSeg && lastIdx >= 0) {
                                const distGap = Math.abs(dists[i] - dists[lastIdx]);
                                const timeGap = (times.length > i && times.length > lastIdx)
                                    ? Math.abs(times[i] - times[lastIdx])
                                    : 0;
                                if (distGap > MAX_DIST_GAP || timeGap > MAX_TIME_GAP) {
                                    flushSeg();
                                    segPoints = [];
                                }
                            }
                            if (!inSeg) inSeg = true;
                            segPoints.push({ x: px, y: py });
                            lastIdx = i;
                        } else {
                            if (inSeg) {
                                inSeg = false;
                                flushSeg();
                                segPoints = [];
                                lastIdx = -1;
                            }
                        }
                    }
                    if (inSeg) flushSeg();
                }

                // --- Racing line ---
                if (xs.length) {
                    const pathData = xs.map((x, i) => {
                        const sx = toSvgX(x).toFixed(1);
                        const sy = toSvgY(ys[i]).toFixed(1);
                        return (i === 0 ? 'M' : 'L') + sx + ' ' + sy;
                    }).join(' ');

                    svg += `<path d="${pathData}" stroke="${lineColor}" stroke-width="4"
                                         fill="none" stroke-linecap="round" stroke-linejoin="round"
                                         opacity="0.9"/>`;
                }

                // --- Yellow X markers at sector min-speed points ---
                if (definitions && Array.isArray(definitions) && dists.length && speeds.length) {
                    definitions.forEach(def => {
                        const start = def.start;
                        const end = def.end;

                        let minSpd = Infinity;
                        let minIdx = -1;

                        for (let i = 0; i < dists.length; i++) {
                            const dist = dists[i];
                            if (dist < start || dist > end) continue;
                            const s = speeds[i];
                            if (s < minSpd) {
                                minSpd = s;
                                minIdx = i;
                            }
                        }

                        if (minIdx >= 0) {
                            const px = toSvgX(xs[minIdx]);
                            const py = toSvgY(ys[minIdx]);

                            const size = 20; // pixels in SVG units
                            svg += `
<line x1="${(px - size).toFixed(1)}" y1="${(py - size).toFixed(1)}"
                  x2="${(px + size).toFixed(1)}" y2="${(py + size).toFixed(1)}"
                  stroke="#ffcc00" stroke-width="6" stroke-linecap="round"/>
<line x1="${(px - size).toFixed(1)}" y1="${(py + size).toFixed(1)}"
                  x2="${(px + size).toFixed(1)}" y2="${(py - size).toFixed(1)}"
                  stroke="#ffcc00" stroke-width="6" stroke-linecap="round"/>`;
                        }
                    });
                }

                // Corner numbers (use ref lap positions for both)
                if (title.startsWith('Ref')) {
                    cornerLabelsRef.forEach(c => {
                        svg += `
<circle cx="${c.x.toFixed(1)}" cy="${c.y.toFixed(1)}" r="12"
        fill="rgba(255,255,255,0.85)" stroke="#000" stroke-width="1"/>
<text x="${c.x.toFixed(1)}" y="${(c.y + 4).toFixed(1)}"
      font-size="18" text-anchor="middle" fill="#000">C${c.id}</text>`;
                    });
                } else {
                    cornerLabelsCmp.forEach(c => {
                        svg += `
<circle cx="${c.x.toFixed(1)}" cy="${c.y.toFixed(1)}" r="12"
        fill="rgba(255,255,255,0.85)" stroke="#000" stroke-width="1"/>
<text x="${c.x.toFixed(1)}" y="${(c.y + 4).toFixed(1)}"
      font-size="18" text-anchor="middle" fill="#000">C${c.id}</text>`;
                    });
                }


                // Mini legend
                svg += `
<rect x="20" y="20" width="26" height="6" fill="${lineColor}" />
<text x="55" y="26" font-size="18" fill="#000000">Line</text>
<rect x="20" y="44" width="26" height="6" fill="${absColor}" />
<text x="55" y="50" font-size="18" fill="#000000">ABS</text>
<rect x="20" y="68" width="26" height="6" fill="#ffcc00" />
<text x="55" y="74" font-size="18" fill="#000000">Corner Min Speed</text>`;

                svg += `</svg></div>`;
                return svg;
            }

            const refTitle = 'Ref L' + refLap.lapNumber + ' ' + (refLap.filenameWithoutExt || '');
            const cmpTitle = compareLap
                ? 'Lap L' + compareLap.lapNumber + ' ' + (compareLap.filenameWithoutExt || '')
                : 'Comparison';

            const cmpColor = (compareLap && compareLap.color) ? compareLap.color : '#777777';

            const refSvg = buildSingleSvg(refLap, refTitle, '#0066ff', '#222222');
            const cmpSvg = buildSingleSvg(compareLap, cmpTitle, '#ff0000', cmpColor);

            return `<div style="display:flex;gap:8px;align-items:flex-start;" class="two-maps">
${refSvg}
${cmpSvg}
</div>`;
        }


        function buildOverlayTrackMapSvg(refLap, compareLap, definitions, cornerDefs) {
            if (!refLap || !refLap.data || !refLap.data.mapX.length || !compareLap) return '';

            const laps = [refLap, compareLap];

            // Shared bounds
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            laps.forEach(lap => {
                lap.data.mapX.forEach(x => {
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                });
                lap.data.mapY.forEach(y => {
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                });
            });
            if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) {
                return '';
            }

            // ADD: pad bounds to keep line away from print margins
            const rawWidth = maxX - minX || 1;
            const rawHeight = maxY - minY || 1;
            const padFrac = 0.05; // 5% padding

            const padX = rawWidth * padFrac;
            const padY = rawHeight * padFrac;

            minX -= padX;
            maxX += padX;
            minY -= padY;
            maxY += padY;

            const width = maxX - minX || 1;
            const height = maxY - minY || 1;

            function toSvgX(x) { return ((x - minX) / width) * 1000; }
            function toSvgY(y) { return (1 - (y - minY) / height) * 700; } // 1000x700

            function getCornerSvgPositions(lap, cornerDefs) {
                if (!cornerDefs || !cornerDefs.length) return [];
                const d = lap.data.distance;
                const xs = lap.data.mapX;
                const ys = lap.data.mapY;
                const v = lap.data.speed;

                const out = [];
                cornerDefs.forEach(c => {
                    let bestIdx = -1;
                    let bestSpeed = Infinity;
                    for (let i = 0; i < d.length; i++) {
                        if (d[i] < c.dStart || d[i] > c.dEnd) continue;
                        if (v[i] < bestSpeed) {
                            bestSpeed = v[i];
                            bestIdx = i;
                        }
                    }
                    if (bestIdx >= 0) {
                        out.push({
                            id: c.id,
                            x: toSvgX(xs[bestIdx]),
                            y: toSvgY(ys[bestIdx])
                        });
                    }
                });
                return out;
            }

            const cornerLabels = getCornerSvgPositions(refLap, cornerDefs);


            let svg = `<svg class="placemat-svg-map overlay-map-svg" viewBox="0 0 1000 700" xmlns="http://www.w3.org/2000/svg"
                  style="width:100%;border:1px solid #444;background:#ffffff;">`

            // Helper: ABS with gap check
            function drawAbsSegments(lap, absColor, opacity, offset = 0) {
                const dists = lap.data.distance;
                const xs = lap.data.mapX;
                const ys = lap.data.mapY;
                const abs = lap.data.brakeABSactive || [];
                const times = lap.data.time || [];

                if (!dists.length || !abs.length) return;

                let inSeg = false;
                let segPoints = [];
                let lastIdx = -1;
                const MAX_DIST_GAP = 30;   // m
                const MAX_TIME_GAP = 1.0;  // s

                function flushSeg() {
                    if (segPoints.length < 2) return;
                    const pathData = segPoints.map((p, i) =>
                        (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ' ' + p.y.toFixed(1)
                    ).join(' ');
                    svg += `<path d="${pathData}" stroke="${absColor}"
                                 stroke-width="22" stroke-linecap="round" stroke-linejoin="round"
                                 fill="none" opacity="${opacity}"/>`;
                    segPoints = [];
                }

                for (let i = 0; i < dists.length; i++) {
                    const active = abs[i] > 0;
                    const px = toSvgX(xs[i]) + offset;  // Apply offset here
                    const py = toSvgY(ys[i]);

                    if (active) {
                        if (inSeg && lastIdx >= 0) {
                            const distGap = Math.abs(dists[i] - dists[lastIdx]);
                            const timeGap = (times.length > i && times.length > lastIdx)
                                ? Math.abs(times[i] - times[lastIdx])
                                : 0;
                            if (distGap > MAX_DIST_GAP || timeGap > MAX_TIME_GAP) {
                                flushSeg();
                                segPoints = [];
                            }
                        }
                        if (!inSeg) inSeg = true;
                        segPoints.push({ x: px, y: py });
                        lastIdx = i;
                    } else {
                        if (inSeg) {
                            inSeg = false;
                            flushSeg();
                            segPoints = [];
                            lastIdx = -1;
                        }
                    }
                }
                if (inSeg) flushSeg();
            }

            // Helper: racing line
            function drawLine(lap, stroke, width, opacity, offset = 0) {
                const xs = lap.data.mapX;
                const ys = lap.data.mapY;
                if (!xs.length) return;

                const pathData = xs.map((x, i) => {
                    const sx = (toSvgX(x) + offset).toFixed(1);
                    const sy = toSvgY(ys[i]).toFixed(1);
                    return (i === 0 ? 'M' : 'L') + sx + ' ' + sy;
                }).join(' ');

                svg += `<path d="${pathData}" stroke="${stroke}" stroke-width="${width}"
                             fill="none" stroke-linecap="round" stroke-linejoin="round"
                             opacity="${opacity}"/>`;
            }

            // Helper: min-speed X markers per sector
            function drawMinSpeedXs(lap, definitions, color, offset = 0) {
                const dists = lap.data.distance;
                const xs = lap.data.mapX;
                const ys = lap.data.mapY;
                const speeds = lap.data.speed || [];
                if (!definitions || !Array.isArray(definitions) || !dists.length || !speeds.length) return;

                definitions.forEach(def => {
                    const start = def.start;
                    const end = def.end;

                    let minSpd = Infinity;
                    let minIdx = -1;

                    for (let i = 0; i < dists.length; i++) {
                        const dist = dists[i];
                        if (dist < start || dist > end) continue;
                        const s = speeds[i];
                        if (s < minSpd) {
                            minSpd = s;
                            minIdx = i;
                        }
                    }

                    if (minIdx >= 0) {
                        const px = toSvgX(xs[minIdx]) + offset;
                        const py = toSvgY(ys[minIdx]);
                        const size = 20;

                        svg += `
<line x1="${(px - size).toFixed(1)}" y1="${(py - size).toFixed(1)}"
                  x2="${(px + size).toFixed(1)}" y2="${(py + size).toFixed(1)}"
                  stroke="${color}" stroke-width="6" stroke-linecap="round"/>
<line x1="${(px - size).toFixed(1)}" y1="${(py + size).toFixed(1)}"
                  x2="${(px + size).toFixed(1)}" y2="${(py - size).toFixed(1)}"
                  stroke="${color}" stroke-width="6" stroke-linecap="round"/>`;
                    }
                });
            }

            const refLineColor = '#222222';
            const refAbsColor = '#0066ff';
            const refMinSpeedCol = '#ffcc00';

            const cmpLineColor = (compareLap && compareLap.color) ? compareLap.color : '#777777';
            const cmpAbsColor = '#ff0000';
            const cmpMinSpeedCol = '#00cc66';

            // Draw in sensible z-order: lines first, then ABS, then markers
            drawLine(refLap, refLineColor, 4, 0.8, 0);  // Stacked with no offset
            drawLine(compareLap, cmpLineColor, 4, 0.8, 0);  // Stacked with no offset

            drawAbsSegments(refLap, refAbsColor, 0.65, -20);  // ABS offset left for reference
            drawAbsSegments(compareLap, cmpAbsColor, 0.65, +20);  // ABS offset right for compare

            drawMinSpeedXs(refLap, definitions, refMinSpeedCol, 0);  // Stacked if desired
            drawMinSpeedXs(compareLap, definitions, cmpMinSpeedCol, 0);  // Stacked if desired


            // Corner numbers on overlay
            cornerLabels.forEach(c => {
                svg += `
<circle cx="${c.x.toFixed(1)}" cy="${c.y.toFixed(1)}" r="12"
        fill="rgba(255,255,255,0.85)" stroke="#000" stroke-width="1"/>
<text x="${c.x.toFixed(1)}" y="${(c.y + 4).toFixed(1)}"
      font-size="18" text-anchor="middle" fill="#000">C${c.id}</text>`;
            });


            // Legend for Overlay Map
            svg += `
<g style="font-size: 18px; fill: #000000; transform: translate(20px, 20px);">
                <rect width="26" height="6" fill="${refLineColor}" />
                <text x="35" y="6">Ref Line</text>
                <rect y="20" width="26" height="6" fill="${refAbsColor}" />
                <text x="35" y="26">Ref ABS</text>
                <rect y="40" width="26" height="6" fill="${refMinSpeedCol}" />
                <text x="35" y="46">Ref Min Speed Corner</text>

                <rect y="60" width="26" height="6" fill="${cmpLineColor}" />
                <text x="35" y="66">Compare Line</text>
                <rect y="80" width="26" height="6" fill="${cmpAbsColor}" />
                <text x="35" y="86">Compare ABS</text>
                <rect y="100" width="26" height="6" fill="${cmpMinSpeedCol}" />
                <text x="35" y="106">Compare Min Speed Corner</text>
</g>`;

            svg += `</svg>`;
            return svg;
        }


        function openPlacematReport() {
            const selectedLaps = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
            const refLap = telemetryData.find(l => l.id === referenceLapId);

            if (!refLap || selectedLaps.length < 2) {
                alert("Select a reference lap and at least one comparison lap to print a placemat.");
                return;
            }

            const { definitions } = calculateSectors(selectedLaps, refLap);
            if (!definitions || definitions.length === 0) {
                alert("No sector information available.");
                return;
            }

            const compareLaps = selectedLaps.filter(l => l.id !== refLap.id);
            if (compareLaps.length === 0) {
                alert("No comparison laps selected (only the reference is visible).");
                return;
            }

            // NEW: build per‑corner definitions from the reference lap
            const cornerDefs = buildCornerDefinitions(refLap);

            // Existing sector metrics per lap
            const metricsByLap = {};
            [refLap, ...compareLaps].forEach(lap => {
                const lapEntry = {};
                definitions.forEach(def => {
                    lapEntry[def.id] = computeLapSectorMetrics(lap, def.start, def.end);
                });
                metricsByLap[lap.id] = lapEntry;
            });

            // NEW: per‑corner driving metrics per lap
            const cornerMetricsByLap = {};
            [refLap, ...compareLaps].forEach(lap => {
                cornerMetricsByLap[lap.id] = cornerDefs.map(c => ({
                    corner: c,
                    metrics: computeCornerDrivingMetrics(lap, c)
                }));
            });

            let html = `
<!DOCTYPE html>
<html>
<head>
                <meta charset="UTF-8">
                <title>Placemat Report</title>
<style>
                body { font-family: Arial, sans-serif; margin: 20px; color: #000; }
                h1, h2 { margin-bottom: 5px; }
                table { border-collapse: collapse; width: 100%; margin-bottom: 12px; font-size: 12px; }
                th, td { border: 1px solid #888; padding: 4px 6px; text-align: center; }
                th { background:#eee; }
                .faster { color: #0a0; font-weight:bold; }
                .slower { color: #c00; font-weight:bold; }
                .small { font-size: 11px; color:#555; }

                /* Base styles for all SVG maps (screen display) */
                .placemat-svg-map {
                    width: 100%;
                    height: auto; /* Let viewBox manage aspect ratio by default */
                    max-width: 100%;
                    display: block; /* Prevents extra space below SVG */
                }
                .placemat-svg-map.two-maps-svg { height: 50vh; max-height: 50vh; }
                .placemat-svg-map.overlay-map-svg { height: 85vh; max-height: 85vh; }
                .map-container { margin-top: 6px; } /* Apply general margin to map containers */

@media print {
              body { margin: 5mm; }

              /* Keep tables and the adjacent two-maps block together */
              table,
              .two-maps,
              .map-container {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
              }

              /* Fixed printed heights for SVG maps */
              .placemat-svg-map.two-maps-svg {
                height: 12.0cm !important;
                max-height: 12.0cm !important;
                display: block !important;
              }
              .placemat-svg-map.overlay-map-svg {
                height: 18.0cm !important;
                max-height: 18.0cm !important;
                display: block !important;
              }

              /* Ensure lap-block content (table + two-maps) stays together and occupies its page */
              .lap-block {
                display: block !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                page-break-after: auto !important;
                break-after: auto !important;
                clear: both !important;
                box-sizing: border-box !important;
                margin: 0 !important;
                padding: 0 !important;
                min-height: 11.5cm !important;
              }

              /* Force overlay to begin on the next page and avoid splitting */
              .overlay-block {
                display: block !important;
                page-break-before: always !important;
                break-before: page !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                clear: both !important;
                margin: 0 !important;
                padding: 0 !important;
              }

              /* Tidy margins so content doesn't float up */
              .lap-block,
              .overlay-block,
              .map-container {
                margin-top: 0 !important;
                margin-bottom: 0 !important;
                padding-bottom: 0 !important;
              }
}
</style>


</head>
<body>
<h1>Placemat – Driving Differences</h1>
<p class="small">
Reference: L${refLap.lapNumber} (${refLap.filenameWithoutExt}) – ${formatTime(refLap.lapTime)}
</p>
`;

            compareLaps.forEach(lap => {
                const mapsHtml = buildTwoTrackMapsSvg(refLap, lap, definitions, cornerDefs);

                html += `<div class="lap-block">`;

                html += `<h2>Compare Lap L${lap.lapNumber} (${lap.filenameWithoutExt}) – ${formatTime(lap.lapTime)}</h2>`;
                html += `
<table>
    <thead>
        <tr>
            <th>Sector</th>
            <th>Δ Time (s)</th>
            <th>Ref Time</th>
            <th>Lap Time</th>
            <th>Min Speed (km/h)</th>
            <th>Δ Min Speed</th>
            <th>Avg Speed (km/h)</th>
            <th>Max Brake (%)</th>
            <th>ABS Time Ref (s)</th>
            <th>ABS Time Lap (s)</th>
            <th>Δ ABS Time (s)</th>
            <th>Brake Point (m from S start)</th>
        </tr>
    </thead>
    <tbody>
`;

                definitions.forEach(def => {
                    const refM = metricsByLap[refLap.id][def.id];
                    const lapM = metricsByLap[lap.id][def.id];

                    let sectorDelta = 0;
                    if (refM && lapM) sectorDelta = lapM.sectorTime - refM.sectorTime;

                    const cls = sectorDelta < -0.01 ? 'faster' : (sectorDelta > 0.01 ? 'slower' : '');

                    const refTime = refM ? refM.sectorTime.toFixed(3) : '--';
                    const lapTime = lapM ? lapM.sectorTime.toFixed(3) : '--';

                    const refMinSpd = refM ? refM.minSpeed.toFixed(1) : '--';
                    const lapMinSpd = lapM ? lapM.minSpeed.toFixed(1) : '--';
                    const dMinSpd = (refM && lapM) ? (lapM.minSpeed - refM.minSpeed).toFixed(1) : '--';

                    const avgSpd = lapM ? lapM.avgSpeed.toFixed(1) : '--';
                    const maxBrake = lapM ? lapM.maxBrake.toFixed(0) : '--';

                    const refAbsTime = refM ? refM.absTime.toFixed(3) : '--';
                    const lapAbsTime = lapM ? lapM.absTime.toFixed(3) : '--';
                    let dAbsTime = '--';
                    if (refM && lapM) {
                        const diff = lapM.absTime - refM.absTime;
                        dAbsTime = (diff >= 0 ? '+' : '') + diff.toFixed(3);
                    }

                    let brakePointRef = refM && refM.brakePointDist != null ? (refM.brakePointDist - def.start).toFixed(1) : '--';
                    let brakePointLap = lapM && lapM.brakePointDist != null ? (lapM.brakePointDist - def.start).toFixed(1) : '--';

                    let brakePointText = '--';
                    if (brakePointRef !== '--' && brakePointLap !== '--') {
                        const diff = (parseFloat(brakePointLap) - parseFloat(brakePointRef)).toFixed(1);
                        const sign = diff > 0 ? '+' : '';
                        brakePointText = `${brakePointLap} (${sign}${diff})`;
                    } else if (brakePointLap !== '--') {
                        brakePointText = brakePointLap;
                    }

                    html += `
        <tr>
            <td>S${def.id}</td>
            <td class="${cls}">${sectorDelta >= 0 ? '+' : ''}${sectorDelta.toFixed(3)}</td>
            <td>${refTime}</td>
            <td>${lapTime}</td>
            <td>${lapMinSpd} / ${refMinSpd}</td>
            <td>${dMinSpd}</td>
            <td>${avgSpd}</td>
            <td>${maxBrake}</td>
            <td>${refAbsTime}</td>
            <td>${lapAbsTime}</td>
            <td>${dAbsTime}</td>
            <td>${brakePointText}</td>
        </tr>`;
                });

                html += `
    </tbody>
</table>
<div class="map-container">
${mapsHtml || '<p class="small">Track maps not available.</p>'}
</div>
</div>`; // end lap-block

                // add full-page overlay map for this comparison lap
                const overlayHtml = buildOverlayTrackMapSvg(refLap, lap, definitions, cornerDefs);
                html += `
<div class="overlay-block">
  <h2>Overlay Map – Ref vs L${lap.lapNumber} (${lap.filenameWithoutExt})</h2>
  <div class="map-container overlay-map-wrapper">
    ${overlayHtml || '<p class="small">Overlay track map not available.</p>'}
  </div>
</div>
`;

                // NEW: per‑corner table for THIS compare lap
                html += `
<h3>Corner‑by‑Corner Driving – L${lap.lapNumber} vs Ref</h3>
<table>
  <thead>
    <tr>
      <th>Corner</th>
      <th>Δ Brake Point (m)</th>
      <th>Δ Brake Peak (%)</th>
      <th>Δ Brake Ramp (10→90% s)</th>
      <th>Δ Turn‑in (m)</th>
      <th>Δ Min Speed (km/h)</th>
      <th>Δ Full Throttle (m)</th>
      <th>Δ ABS Time (s)</th>
    </tr>
  </thead>
  <tbody>
`;

                cornerDefs.forEach((c, idx) => {
                    const refM = cornerMetricsByLap[refLap.id][idx].metrics;
                    const lapM = cornerMetricsByLap[lap.id][idx].metrics;
                    if (!refM || !lapM) return;

                    const dBrakePt = (lapM.brakePointDist - refM.brakePointDist) || 0;
                    const dPeak = (lapM.brakePeak - refM.brakePeak) || 0;
                    const dRamp = (lapM.brakeTime10to90 - refM.brakeTime10to90) || 0;
                    const dTurnIn = (lapM.turnInDist - refM.turnInDist) || 0;
                    const dMinSpd = (lapM.minSpeed - refM.minSpeed) || 0;
                    const dFullThr = (lapM.fullThrDist - refM.fullThrDist) || 0;
                    const dAbs = (lapM.absTime - refM.absTime) || 0;

                    const clsCorner = v => v < -0.5 ? 'faster' : (v > 0.5 ? 'slower' : '');

                    html += `
    <tr>
      <td>C${c.id}</td>
      <td class="${clsCorner(-dBrakePt)}">${dBrakePt.toFixed(1)}</td>
      <td>${dPeak.toFixed(0)}</td>
      <td>${dRamp >= 0 ? '+' : ''}${dRamp.toFixed(3)}</td>
      <td>${dTurnIn.toFixed(1)}</td>
      <td class="${clsCorner(-dMinSpd)}">${dMinSpd.toFixed(1)}</td>
      <td>${dFullThr.toFixed(1)}</td>
      <td>${dAbs >= 0 ? '+' : ''}${dAbs.toFixed(3)}</td>
    </tr>`;
                });

                html += `</tbody></table>`;
            }); // end compareLaps.forEach

            // --- Driving / Tire / Load summary block (telemetry‑only, safe always) ---
            html += `
<hr style="margin:12px 0;">
<h2>Driving, Tire & Load Summary (Reference Lap)</h2>
<p class="small">
  Based on braking & cornering load models and tire surface temps for Ref L${refLap.lapNumber}.
</p>
<div style="margin-top:6px; font-size:12px;">
  ${buildBrakingLoadTableHtml(refLap)}
  <div style="height:8px;"></div>
  ${buildCorneringLoadTableHtml(refLap)}
  <div style="height:8px;"></div>
  ${buildCorneringTempSummaryHtml(refLap)}   <!-- ADD THIS LINE -->
</div>
`;

            html += `
</body>
</html>`;


            const win = window.open('', '_blank');
            if (win) {
                win.document.open();
                win.document.write(html);
                win.document.close();
                setTimeout(() => { win.print(); }, 100);
            } else {
                alert("Popup blocked – allow popups to print the placemat.");
            }
        }


        // --- Chart Zoom History ---
        let zoomHistory = [];
        const MAX_ZOOM_HISTORY_DEPTH = 10;

        function saveCurrentMasterZoom() {
            const chart = charts.delta;
            if (!chart || !chart.scales || !chart.scales.x) return;

            const scale = chart.scales.x;
            if (typeof scale.min !== 'number' || typeof scale.max !== 'number') return;

            const currentState = { min: scale.min, max: scale.max };

            if (zoomHistory.length === 0 ||
                zoomHistory[zoomHistory.length - 1].min !== currentState.min ||
                zoomHistory[zoomHistory.length - 1].max !== currentState.max) {

                if (zoomHistory.length >= MAX_ZOOM_HISTORY_DEPTH) {
                    zoomHistory.shift();
                }
                zoomHistory.push(currentState);
            }
        }

        // --- Charts & Map Sync ---
        function syncScales(sourceChart) {
            // --- NEW LOGIC: If the source of the zoom/pan is the histogram,
            // it operates independently and does not affect other charts.
            if (sourceChart === charts.svHistogram || sourceChart === charts.gforces) {
                // For histograms, we don't use 'master zoom history' in the same way,
                // so no need to call saveCurrentMasterZoom here.
                return;
            }

            const xMinDistance = sourceChart.scales.x.min;
            const xMaxDistance = sourceChart.scales.x.max;

            Object.values(charts).forEach(chart => {
                // --- NEW LOGIC: Skip the histogram chart when applying zoom/pan from other charts.
                if (chart === charts.svHistogram || chart === charts.gforces) {
                    return; // Do not apply external zoom/pan to the histogram
                }

                // If the current chart in the loop is the source chart, we don't need to update its scales
                // as they already reflect the change that triggered this sync.
                if (chart === sourceChart) return;

                // Existing logic for other charts (line charts and track map)
                if (chart.config.type !== 'scatter') {
                    if (chart.options.scales && chart.options.scales.x) {
                        chart.options.scales.x.min = xMinDistance;
                        chart.options.scales.x.max = xMaxDistance;
                    }
                } else { // Handle track map (scatter chart)
                    const currentRefLap = telemetryData.find(l => l.id === referenceLapId);

                    if (!currentRefLap || !currentRefLap.data || currentRefLap.data.distance.length === 0) {
                        chart.options.scales.x.min = undefined;
                        chart.options.scales.x.max = undefined;
                        chart.options.scales.y.min = undefined;
                        chart.options.scales.y.max = undefined;
                    } else {
                        let mapPointsInView = [];
                        for (let i = 0; i < currentRefLap.data.distance.length; i++) {
                            const dist = currentRefLap.data.distance[i];
                            if (dist >= xMinDistance && dist <= xMaxDistance) {
                                mapPointsInView.push({
                                    x: currentRefLap.data.mapX[i],
                                    y: currentRefLap.data.mapY[i]
                                });
                            }
                        }

                        if (mapPointsInView.length > 0) {
                            let newMinMapX = Math.min(...mapPointsInView.map(p => p.x));
                            let newMaxMapX = Math.max(...mapPointsInView.map(p => p.x));
                            let newMinMapY = Math.min(...mapPointsInView.map(p => p.y));
                            let newMaxMapY = Math.max(...mapPointsInView.map(p => p.y));

                            const rangeX = newMaxMapX - newMinMapX;
                            const rangeY = newMaxMapY - newMinMapY;
                            const paddingFactor = 0.1;
                            const paddingX = rangeX === 0 ? 0.01 : rangeX * paddingFactor;
                            const paddingY = rangeY === 0 ? 0.01 : rangeY * paddingFactor;

                            chart.options.scales.x.min = newMinMapX - paddingX;
                            chart.options.scales.x.max = newMaxMapX + paddingX;
                            chart.options.scales.y.min = newMinMapY - paddingY;
                            chart.options.scales.y.max = newMaxMapY + paddingY;
                        } else {
                            chart.options.scales.x.min = undefined;
                            chart.options.scales.x.max = undefined;
                            chart.options.scales.y.min = undefined;
                            chart.options.scales.y.max = undefined;
                        }
                    }
                }
                chart.update('none');
            });

            // This part is specific to the delta chart (master zoom for distance-based charts)
            if (sourceChart === charts.delta) {
                saveCurrentMasterZoom();
            }
        }


        const debouncedUpdateMapCursor = debounce((event, elements, chartInstance) => {
            if (!charts.map || !charts.map.data || !charts.map.data.datasets || charts.map.data.datasets.length === 0) {
                return;
            }

            const cursorDsIndex = charts.map.data.datasets.length - 1;

            if (elements && elements.length > 0) {
                const first = elements[0];

                let distance = null;
                if (first.element && first.element.$context) {
                    const ctx = first.element.$context;

                    // PREFER raw.d (distance) if present (G-force scatter),
                    // then fall back to raw.x (line charts use x = distance),
                    // then parsed.x as last resort.
                    if (ctx.raw && typeof ctx.raw.d === 'number') {
                        distance = ctx.raw.d;
                    } else if (ctx.raw && typeof ctx.raw.x === 'number') {
                        distance = ctx.raw.x;
                    } else if (ctx.parsed && typeof ctx.parsed.x === 'number') {
                        distance = ctx.parsed.x;
                    }
                }

                if (distance == null) {
                    const rect = chartInstance.canvas.getBoundingClientRect();
                    const xPixel = event.clientX - rect.left;
                    distance = chartInstance.scales.x.getValueForPixel(xPixel);
                }

                let lapForMap = telemetryData.find(l => l.id === referenceLapId);
                if (!lapForMap && defaultVisibleLapIds.size > 0) {
                    const firstVisibleLapId = Array.from(defaultVisibleLapIds)[0];
                    lapForMap = telemetryData.find(l => l.id === firstVisibleLapId);
                }

                if (lapForMap && typeof distance === 'number') {
                    const mapCoords = getInterpolatedMapCoords(lapForMap.data, distance);
                    if (mapCoords) {
                        if (!lastHoveredMapCoords || mapCoords.x !== lastHoveredMapCoords.x || mapCoords.y !== lastHoveredMapCoords.y) {
                            charts.map.data.datasets[cursorDsIndex].data = [{ x: mapCoords.x, y: mapCoords.y }];
                            charts.map.data.datasets[cursorDsIndex].pointBackgroundColor = lapForMap.color;
                            charts.map.data.datasets[cursorDsIndex].pointBorderColor = lapForMap.color;
                            charts.map.update('none');
                            lastHoveredMapCoords = mapCoords;
                        }
                        return;
                    }
                }
            }

            if (charts.map.data.datasets[cursorDsIndex] && charts.map.data.datasets[cursorDsIndex].data.length > 0) {
                charts.map.data.datasets[cursorDsIndex].data = [];
                charts.map.update('none');
                lastHoveredMapCoords = null;
            }
        }, 50);


        function panAllChartsX(stepFraction = 0.1, direction = 1) {
            const masterChart = charts.delta;
            if (!masterChart || !masterChart.scales || !masterChart.scales.x) return;

            const scale = masterChart.scales.x;
            if (scale.min == null || scale.max == null) return;

            const range = scale.max - scale.min;
            if (range <= 0) return;

            const shift = range * stepFraction * direction;
            const newMin = scale.min + shift;
            const newMax = scale.max + shift;

            masterChart.options.scales.x.min = newMin;
            masterChart.options.scales.x.max = newMax;
            masterChart.update('none');

            syncScales(masterChart);
        }

        function computeSVStats(rawVelocities) {
            if (!rawVelocities || rawVelocities.length === 0) return null;

            // Standard stats
            const mean = rawVelocities.reduce((s, v) => s + v, 0) / rawVelocities.length;
            const variance = rawVelocities.reduce((s, v) => s + (v - mean) ** 2, 0) / rawVelocities.length;
            const stdDev = Math.sqrt(variance);

            // --- NEW: Split Logic ---
            const SPLIT_VEL = 0.040; // 40mm/s split point
            const NOISE_FLOOR = 0.002; // 2mm/s noise floor

            let lsBumpCount = 0, lsRebCount = 0;
            let hsBumpCount = 0, hsRebCount = 0;

            // Track Max velocities to detect blowing through travel
            let maxBumpVel = 0;
            let maxRebVel = 0;

            rawVelocities.forEach(v => {
                // Track peaks
                if (v < maxBumpVel) maxBumpVel = v;
                if (v > maxRebVel) maxRebVel = v;

                // Categorize
                if (v > NOISE_FLOOR) {
                    // Rebound (Positive)
                    if (v < SPLIT_VEL) lsRebCount++;
                    else hsRebCount++;
                } else if (v < -NOISE_FLOOR) {
                    // Bump (Negative)
                    if (v > -SPLIT_VEL) lsBumpCount++;
                    else hsBumpCount++;
                }
            });

            const totalSamples = rawVelocities.length;

            return {
                mean,
                stdDev,
                max: Math.max(...rawVelocities),
                min: Math.min(...rawVelocities),
                // New granular stats
                lsBumpRatio: lsBumpCount / totalSamples,
                lsRebRatio: lsRebCount / totalSamples,
                hsBumpRatio: hsBumpCount / totalSamples,
                hsRebRatio: hsRebCount / totalSamples,
                maxBumpVel,
                maxRebVel
            };
        }


        function buildDynamicDamperTargetProfile(selectedLaps) {
            const wheels = ['LF', 'RF', 'LR', 'RR'];

            let sumMean = 0;
            let sumStdDev = 0;
            let sumBumpRatio = 0;
            let sumReboundRatio = 0;
            let count = 0;

            selectedLaps.forEach(lap => {
                if (!lap.svStats) return;
                wheels.forEach(w => {
                    const st = lap.svStats[w];
                    if (!st) return;
                    sumMean += st.mean;
                    sumStdDev += st.stdDev;
                    sumBumpRatio += st.bumpRatio;
                    sumReboundRatio += st.reboundRatio;
                    count++;
                });
            });

            if (count === 0) return null;

            const avgMean = sumMean / count;
            const avgStdDev = sumStdDev / count;
            const avgBumpRatio = sumBumpRatio / count;
            const avgReboundRatio = sumReboundRatio / count;

            return {
                meanTarget: avgMean,
                stdDevTarget: avgStdDev,
                bumpRatioTarget: avgBumpRatio,
                reboundRatioTarget: avgReboundRatio,

                meanTol: 0.01,             // allowable mean offset
                stdDevTolFraction: 0.25,   // ±25% range around target σ
                bumpReboundBalanceTol: 0.15
            };
        }


        function makeDamperRecommendation(stats, targetProfile) {
            if (!stats || !targetProfile) return 'No data';

            const recs = [];

            // 1) Mean offset vs target
            const meanDelta = stats.mean - targetProfile.meanTarget;
            if (meanDelta > targetProfile.meanTol) {
                recs.push('Shifted toward rebound vs selected-lap average. Try slightly softening rebound or stiffening bump.');
            } else if (meanDelta < -targetProfile.meanTol) {
                recs.push('Shifted toward bump vs selected-lap average. Try slightly softening bump or stiffening rebound.');
            }

            // 2) Spread / stdDev vs target σ
            const stdLow = targetProfile.stdDevTarget * (1 - targetProfile.stdDevTolFraction);
            const stdHigh = targetProfile.stdDevTarget * (1 + targetProfile.stdDevTolFraction);

            if (stats.stdDev < stdLow) {
                recs.push('Velocity range is tighter than average; damper likely stiffer here. Try softening both bump and rebound a bit.');
            } else if (stats.stdDev > stdHigh) {
                recs.push('Velocity range is wider than average; damper likely softer here. Consider stiffening both bump and rebound slightly.');
            }

            // 3) Bump vs rebound time vs target
            const bumpDelta = stats.bumpRatio - targetProfile.bumpRatioTarget;
            if (Math.abs(bumpDelta) > targetProfile.bumpReboundBalanceTol) {
                if (bumpDelta > 0) {
                    recs.push('Spends more time in bump than average. Try reducing bump or increasing rebound slightly.');
                } else {
                    recs.push('Spends more time in rebound than average. Try reducing rebound or increasing bump slightly.');
                }
            }

            if (recs.length === 0) {
                recs.push('Damper velocity profile is close to the average of the selected laps. Only fine-tune if you feel handling issues.');
            }

            return recs.join(' ');
        }


        function getBumpStopRecommendations(lap) {
            const recs = [];
            // Ensure we have ride height data
            if (!lap || !lap.data || !lap.data.rideHeightLF || !lap.data.rideHeightLF.length) return recs;

            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const minHeights = {};

            // 1. Find Minimum Ride Heights (in mm)
            wheels.forEach(w => {
                const arr = lap.data[`rideHeight${w}`];
                if (arr && arr.length > 0) {
                    // Convert m to mm and find min
                    let min = Infinity;
                    for (let i = 0; i < arr.length; i++) {
                        if (arr[i] < min) min = arr[i];
                    }
                    minHeights[w] = min * 1000; // Convert to mm
                }
            });

            // 2. Evaluate Thresholds
            // Critical bottoming threshold (mm). 
            // Set to roughly 1.5mm to allow for slight tire deflection/sensor margin.
            const BOTTOMING_THRESH = 1.5;

            wheels.forEach(w => {
                const minH = minHeights[w];
                if (minH === undefined) return;

                const paramName = `${w}_BumpRubberGap`; // e.g. LF_BumpRubberGap

                if (minH < BOTTOMING_THRESH) {
                    // Car is hitting the ground. 
                    recs.push({
                        param: paramName,
                        delta: -2.0, // Decrease gap by 2mm (or add 2mm packer)
                        explanation: `<strong>${w} Bottoming:</strong> Minimum ride height dropped to ${minH.toFixed(1)}mm. The chassis is scraping the track. <strong>Decrease Bump Rubber Gap</strong> (engage packers sooner) to support the aero load and protect the floor.`
                    });
                }
            });

            return recs;
        }


        function updateDamperRecommendations() {
            const container = document.getElementById('damper-rec-content');
            if (!container) return;

            const selectedLaps = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
            if (selectedLaps.length === 0) {
                container.textContent = 'No laps selected.';
                return;
            }

            // Show recommendations for reference lap, otherwise first visible
            const lap = telemetryData.find(l => l.id === referenceLapId) || selectedLaps[0];

            if (!lap.svStats || !lap.damperRecommendations) {
                container.textContent = 'No damper statistics available for selected lap.';
                return;
            }

            const wheels = ['LF', 'RF', 'LR', 'RR'];
            container.innerHTML = wheels.map(w => {
                const stats = lap.svStats[w];
                const rec = lap.damperRecommendations[w] || 'No recommendation.';
                if (!stats) return `<div><strong>${w}:</strong> No data.</div>`;

                return `
                        <div style="margin-bottom:6px;">
                            <strong>${w}:</strong><br>
<span style="color:#ccc;">mean:</span> ${(stats.mean * 1000).toFixed(1)} mm/s,
<span style="color:#ccc;">σ:</span> ${(stats.stdDev * 1000).toFixed(1)} mm/s
<br>
                            <span>${rec}</span>
                        </div>
                    `;
            }).join('');
        }


        function calculateSVHistogram(lap, wheelKey, minVel = -0.5, maxVel = 0.5, binSize = 0.01) {
            const velocities = lap.data[wheelKey]; // m/s
            if (!velocities || velocities.length === 0) return [];

            const validVelocities = velocities.filter(v => v > -5 && v < 5);
            if (validVelocities.length === 0) return [];

            const numBins = Math.ceil((maxVel - minVel) / binSize);
            const binMap = new Map(); // key in m/s

            for (let i = 0; i < validVelocities.length; i++) {
                const vel = validVelocities[i]; // m/s

                if (vel >= minVel && vel < maxVel) {
                    const binIndex = Math.floor((vel - minVel) / binSize);
                    const binCenterMs = minVel + (binIndex * binSize) + (binSize / 2); // m/s
                    const cleanCenterMs = parseFloat(binCenterMs.toFixed(3));
                    binMap.set(cleanCenterMs, (binMap.get(cleanCenterMs) || 0) + 1);
                }
            }

            // Output x in mm/s
            const histogramData = Array.from(binMap, ([xMs, y]) => ({
                x: xMs * 1000, // mm/s
                y
            })).sort((a, b) => a.x - b.x);

            return histogramData;
        }




        function initSVHistogramChart(canvasId, label, unit) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                parsing: {
                    xAxisKey: 'x',
                    yAxisKey: 'y'
                },
                scales: {
                    x: {
                        type: 'linear',
                        offset: false,
                        title: { display: true, text: 'Suspension Velocity (mm/s)', color: '#888' }, // CHANGED to #888
                        ticks: { color: '#888' },
                        grid: { color: '#333', offset: false }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: unit, color: '#888' }, // CHANGED to #888
                        ticks: { color: '#888' },
                        grid: { color: '#333' }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',  // Explicitly set position
                        align: 'center',  // Centers the legend items within the legend box
                        fullSize: true,   // IMPORTANT: Makes the legend span the full chart width
                        labels: { color: '#eee' } // KEEP legend labels light
                    },
                    title: {
                        display: true,
                        position: 'top',  // Explicitly set position
                        text: label,
                        color: '#eee', // KEEP main chart title light
                        align: 'center',  // Centers the title text within the title box
                        fullSize: true    // IMPORTANT: Makes the title span the full chart width
                    },
                    tooltip: {
                        callbacks: {
                            title: function (tooltipItems) {
                                const binCenterMm = tooltipItems[0].parsed.x;      // already mm/s now
                                const binSizeMm = 0.01 * 1000;                   // if binSize was 0.01 m/s
                                const binStart = binCenterMm - (binSizeMm / 2);
                                const binEnd = binCenterMm + (binSizeMm / 2);
                                return `Velocity: ${binStart.toFixed(0)} to ${binEnd.toFixed(0)} mm/s`;
                            },

                            label: function (tooltipItem) {
                                const datasetLabel = tooltipItem.dataset.label || '';
                                const value = tooltipItem.parsed.y;
                                return `${datasetLabel}: ${value} samples`;
                            }
                        }
                    },
                    zoom: {
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: 'x',
                            drag: { enabled: true },
                        },
                        pan: { enabled: true, mode: 'x' }
                    }
                }
            };

            const chart = new Chart(ctx, {
                type: 'bar',
                data: { datasets: [] },
                options: chartOptions
            });
            // Get the parent .chart-wrapper element
            const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
            if (chartWrapper) {
                addFullscreenButton(chartWrapper, chart);
            }
            return chart; // Return the chart instance
        }


        // Initialize all charts
        charts.delta = initLineChart('delta-chart', 'Time Delta (vs Reference)', 'sec');
        charts.map = initTrackMap();
        charts.speed = initLineChart('speed-chart', 'Speed', 'km/h');
        charts.inputs = initLineChart('throttle-brake-chart', 'Inputs', '%');
        charts.steering = initLineChart('steering-chart', 'Steering', 'rad');
        charts.rpm = initLineChart('rpm-gear-chart', 'RPM / Gear', 'val');
        charts.svHistogram = initSVHistogramChart('suspension-velocity-chart', 'Suspension Velocity Histogram', 'Samples');
        charts.gforces = initGForceScatterChart('gforce-scatter-chart', 'Combined G-Forces', 'G'); // NEW CHART INITIALIZATION
        charts.tempLF = initLineChart('temp-lf-chart', 'Tire Temp LF (Surface)', '°C');
        charts.tempRF = initLineChart('temp-rf-chart', 'Tire Temp RF (Surface)', '°C');
        charts.tempLR = initLineChart('temp-lr-chart', 'Tire Temp LR (Surface)', '°C');
        charts.tempRR = initLineChart('temp-rr-chart', 'Tire Temp RR (Surface)', '°C');
        charts.cornerLoad = initLineChart('corner-load-chart', 'Corner Loads (Reference Lap)', 'kN');
        charts.cornerLoadAll = initLineChart('corner-load-all-chart', 'Corner Loads – All Selected Laps', 'kN');
        charts.rideHeightLF = initLineChart('ride-height-lf-chart', 'Ride Height LF (Reference Lap)', 'mm');
        charts.rideHeightRF = initLineChart('ride-height-rf-chart', 'Ride Height RF (Reference Lap)', 'mm');
        charts.rideHeightLR = initLineChart('ride-height-lr-chart', 'Ride Height LR (Reference Lap)', 'mm');
        charts.rideHeightRR = initLineChart('ride-height-rr-chart', 'Ride Height RR (Reference Lap)', 'mm');

        // ENABLE legend for reference corner‑load chart like G‑force/histogram
        if (charts.cornerLoad && charts.cornerLoad.options.plugins) {
            charts.cornerLoad.options.plugins.legend = {
                display: true,
                position: 'top',
                align: 'center',
                fullSize: true,
                labels: {
                    color: '#eee',
                    boxWidth: 12,
                    boxHeight: 12,
                }
            };
            // keep title as is (initLineChart already set it), or adjust if you like
        }

        function initLineChart(canvasId, label, unit) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'index', intersect: false },
                onHover: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, elements, chartInstance),
                onLeave: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, null, chartInstance),
                scales: {
                    x: { type: 'linear', title: { display: true, text: 'Distance (m)' }, ticks: { color: '#888' }, grid: { color: '#333' } },
                    y: { title: { display: true, text: unit }, ticks: { color: '#888' }, grid: { color: '#333' } }
                },
                elements: {
                    point: {
                        hoverRadius: 0
                    }
                },
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: label, color: '#eee' },
                    tooltip: {
                        enabled: false,
                        mode: 'nearest',
                        intersect: false,
                        caretPadding: 10,
                        position: 'offsetCursor',
                        callbacks: {
                            title: function (tooltipItems) {
                                if (tooltipItems.length === 0) return '';
                                const distance = tooltipItems[0].parsed.x;
                                return `Distance: ${distance.toFixed(1)} m`;
                            },
                            label: function (tooltipItem) {
                                const lapId = tooltipItem.dataset.lapId;
                                if (lapId === -1) return '';

                                const lap = telemetryData.find(l => l.id === lapId);
                                if (!lap) return '';

                                const value = tooltipItem.parsed.y;
                                let formattedValue = '';
                                const lapInfo = `L${lap.lapNumber} (${lap.filenameWithoutExt})`;

                                // Add custom formatting for Ride Height if needed
                                if (tooltipItem.dataset.label.includes('Ride Height')) {
                                    formattedValue = `${lapInfo} Ride Height: ${value.toFixed(1)} mm`;
                                }
                                // ... existing custom formatting ...
                                else if (tooltipItem.dataset.label.includes('Speed')) {
                                    formattedValue = `${lapInfo} Speed: ${value.toFixed(1)} km/h`;
                                } else if (tooltipItem.dataset.label.includes('Thr')) {
                                    formattedValue = `${lapInfo} Throttle: ${value.toFixed(1)} %`;
                                } else if (tooltipItem.dataset.label.includes('Brk')) {
                                    formattedValue = `${lapInfo} Brake: ${value.toFixed(1)} %`;
                                } else if (tooltipItem.dataset.label.includes('Steering')) {
                                    formattedValue = `${lapInfo} Steering: ${(value * 180 / Math.PI).toFixed(1)} deg`;
                                } else if (tooltipItem.dataset.label.includes('RPM')) {
                                    formattedValue = `${lapInfo} RPM: ${value.toFixed(0)}`;
                                } else if (tooltipItem.dataset.label.includes('Gear')) {
                                    formattedValue = `${lapInfo} Gear: ${value.toFixed(0)}`;
                                } else if (tooltipItem.dataset.label.includes('Delta')) {
                                    const sign = value > 0 ? '+' : '';
                                    formattedValue = `${lapInfo} Delta: ${sign}${value.toFixed(3)} s`;
                                } else if (tooltipItem.dataset.label.includes('ABS Active')) {
                                    formattedValue = `${lapInfo} ABS Active`;
                                } else if (tooltipItem.dataset.label.includes('Reference')) {
                                    formattedValue = `${lapInfo} Delta: 0.000 s`;
                                } else {
                                    formattedValue = `${lapInfo} ${tooltipItem.dataset.label.replace(`L${lap.lapNumber} `, '').replace(` (${lap.filename})`, '')}: ${value.toFixed(2)}`;
                                }
                                return formattedValue;
                            },
                        }
                    },
                    zoom: {
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: 'x',
                            drag: {
                                enabled: true,
                                borderColor: 'rgba(255,255,255,0.3)',
                                borderWidth: 1,
                                backgroundColor: 'rgba(255,255,255,0.1)',
                                threshold: 5
                            },
                            onZoomComplete: ({ chart }) => { syncScales(chart); },
                            onZoom: ({ chart }) => syncScales(chart)
                        },
                        pan: {
                            enabled: false
                        }
                    },
                    annotation: { annotations: {} }
                }
            };

            // CUSTOM Y-AXIS SCALING FOR RIDE HEIGHT CHARTS
            if (canvasId.startsWith('ride-height-')) {
                chartOptions.scales.y.min = 0; // Ride height cannot be negative
                // Dynamic max based on typical values, or a fixed reasonable upper bound
                chartOptions.scales.y.max = 100; // Max 50mm for example, adjust as needed
                chartOptions.scales.y.title.text = 'Ride Height (mm)';
                chartOptions.plugins.legend = { display: true, position: 'top', labels: { color: '#eee' } }; // Show legend for clarity
            }

            if (canvasId === 'throttle-brake-chart') {
                chartOptions.scales.y.min = 0;
                chartOptions.scales.y.max = 100;
            }

            const chart = new Chart(ctx, {
                type: 'line',
                data: { datasets: [] },
                options: chartOptions
            });
            // Get the parent .chart-wrapper element
            const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
            if (chartWrapper) {
                addFullscreenButton(chartWrapper, chart);
                // --- START NEW CODE FOR HELP ICON ---
                if (canvasId.startsWith('ride-height-')) {
                    const helpIconDiv = document.createElement('div');
                    helpIconDiv.className = 'chart-help-icon';
                    helpIconDiv.textContent = '?';
                    helpIconDiv.title = `Ride Height Charts:
- Shows the vertical distance (in mm) from the car's chassis to the ground at each wheel.
- X axis: distance (m) around the track.
- Y axis: ride height (mm).

Red Dashed Line (Chassis Scraping Threshold):
- Indicates a critical minimum ride height (e.g., 1.0mm) where the car's chassis might physically contact the track surface. Persistent contact can cause damage or unpredictable handling.

Yellow Dashed Line (Bump Stop Engagement):
- Represents the ride height (in mm) at which the suspension's bump stops begin to engage. These provide progressive stiffness at the end of suspension travel.
- Its value is directly read from the 'Bump Rubber Gap' setting in your car's setup (in millimeters).
- Note: This yellow line might not be visible if the 'Bump Rubber Gap' value in the car setup is greater than the chart's maximum Y-axis value (e.g., >50mm), as it falls outside the displayed range.`;

                    // Prepend the help icon to the chart wrapper
                    chartWrapper.prepend(helpIconDiv);
                }
                // --- END NEW CODE FOR HELP ICON ---
            }
            return chart; // Return the chart instance
        }


        // Custom tooltip positioner: offset tooltip from the mouse
        Chart.Tooltip.positioners.offsetCursor = function (elements, position) {
            // position.x / position.y is the mouse location
            const offsetX = 16;   // move tooltip right
            const offsetY = -16;  // move tooltip up
            return {
                x: position.x + offsetX,
                y: position.y + offsetY
            };
        };

        function initTrackMap() {
            const ctx = document.getElementById('track-map-chart').getContext('2d');

            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }

            const chart = new Chart(ctx, { // <-- Declare 'chart' here
                type: 'scatter',
                data: { datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: { display: false, grid: { drawOnChartArea: false } },
                        y: { display: false, grid: { drawOnChartArea: false } }
                    },
                    plugins: { legend: { display: false }, tooltip: { enabled: false } },
                    elements: { point: { radius: 0 }, line: { borderWidth: 2 } }
                }
            });

            // Get the parent .chart-wrapper element
            const chartWrapper = document.getElementById('track-map-chart').closest('.chart-wrapper');
            if (chartWrapper) {
                addFullscreenButton(chartWrapper, chart);
            }
            return chart; // Return the chart instance
        }


        function toggleTooltips(enabled) {
            Object.values(charts).forEach(chart => {
                if (!chart.options.plugins || !chart.options.plugins.tooltip) return;

                const isGForce = chart.canvas && chart.canvas.id === 'gforce-scatter-chart';
                const isTrackMap = chart.canvas && chart.canvas.id === 'track-map-chart';

                // Never show tooltips on the track map
                if (isTrackMap) {
                    chart.options.plugins.tooltip.enabled = false;
                    chart.update('none');
                    return;
                }

                // Enable/disable on all non-map charts, including G-force
                if (chart.config.type !== 'scatter' || isGForce) {
                    chart.options.plugins.tooltip.enabled = enabled;
                    chart.update('none');
                }
            });
        }


        function updateCharts() {
            const selectedLaps = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
            const refLap = telemetryData.find(l => l.id === referenceLapId);

            const sectorData = calculateSectors(selectedLaps, refLap);
            if (refLap) updateSectorTable(sectorData);
            else document.getElementById('sector-body').innerHTML =
                '<tr><td colspan="3" style="text-align:center;color:#888;">No reference lap selected.</td></tr>';

            const createDataset = (lap, dataKey, label, color, borderDash = []) => ({
                label: `L${lap.lapNumber} ${label} (${lap.filenameWithoutExt})`,
                data: lap.data[dataKey].map((val, i) => ({ x: lap.data.distance[i], y: val })),
                borderColor: color,
                borderWidth: 1.5,
                borderDash: borderDash,
                pointRadius: 0,
                tension: 0.1,
                lapId: lap.id
            });

            // 1. Time Delta Chart
            if (refLap && selectedLaps.length > 0) {
                charts.delta.data.datasets = selectedLaps.map(lap => {
                    if (lap.id === refLap.id) {
                        return {
                            label: `Reference L${lap.lapNumber}`,
                            data: lap.data.distance.map(d => ({ x: d, y: 0 })),
                            borderColor: '#666',
                            borderWidth: 1,
                            pointRadius: 0,
                            lapId: lap.id
                        };
                    }
                    const deltas = calculateTimeDelta(lap, refLap);
                    return {
                        label: `Delta L${lap.lapNumber} vs Ref`,
                        data: refLap.data.distance.map((dist, i) => ({ x: dist, y: deltas[i] })),
                        borderColor: lap.color,
                        borderWidth: 1.5,
                        pointRadius: 0,
                        lapId: lap.id
                    };
                });
            } else {
                charts.delta.data.datasets = [];
            }

            // 2. Standard Telemetry Charts
            charts.speed.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'speed', 'Speed', lap.color)
            );

            let inputsDatasets = [];
            selectedLaps.forEach(lap => {
                inputsDatasets.push(createDataset(lap, 'throttle', 'Thr', lap.color));
                inputsDatasets.push(createDataset(lap, 'brake', 'Brk', lap.color, [5, 5]));
            });
            charts.inputs.data.datasets = inputsDatasets;

            charts.steering.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'steering', 'Steering', lap.color)
            );

            charts.tempLF.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'tempLF', 'Temp LF', lap.color)
            );
            charts.tempRF.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'tempRF', 'Temp RF', lap.color)
            );
            charts.tempLR.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'tempLR', 'Temp LR', lap.color)
            );
            charts.tempRR.data.datasets = selectedLaps.map(lap =>
                createDataset(lap, 'tempRR', 'Temp RR', lap.color)
            );

            charts.rpm.data.datasets = selectedLaps.map(lap => {
                const rpmDataset = createDataset(lap, 'rpm', 'RPM', lap.color);
                const gearDataset = createDataset(lap, 'gear', 'Gear', lap.color, [2, 2]);
                gearDataset.yAxisID = 'y1';
                return [rpmDataset, gearDataset];
            }).flat();

            if (charts.rpm.options.scales.y1 === undefined &&
                charts.rpm.data.datasets.some(ds => ds.yAxisID === 'y1')) {
                charts.rpm.options.scales.y1 = {
                    type: 'linear',
                    position: 'right',
                    title: { display: true, text: 'Gear', color: '#888' },
                    grid: { drawOnChartArea: false },
                    ticks: { color: '#888', stepSize: 1, precision: 0 }
                };
            } else if (charts.rpm.options.scales.y1 &&
                !charts.rpm.data.datasets.some(ds => ds.yAxisID === 'y1')) {
                delete charts.rpm.options.scales.y1;
            }

            // RIDE HEIGHT CHARTS
            const rhCharts = {
                LF: charts.rideHeightLF,
                RF: charts.rideHeightRF,
                LR: charts.rideHeightLR,
                RR: charts.rideHeightRR
            };
            const rhDataKeys = {
                LF: 'rideHeightLF',
                RF: 'rideHeightRF',
                LR: 'rideHeightLR',
                RR: 'rideHeightRR'
            };
            const rhSetupKeys = {
                LF: 'LF_BumpRubberGap',
                RF: 'RF_BumpRubberGap',
                LR: 'LR_BumpRubberGap',
                RR: 'RR_BumpRubberGap'
            };

            if (refLap) {
                ['LF', 'RF', 'LR', 'RR'].forEach(corner => {
                    const chart = rhCharts[corner];
                    const dataKey = rhDataKeys[corner];
                    const setupKey = rhSetupKeys[corner];

                    if (chart && refLap.data[dataKey] && refLap.data[dataKey].length > 0) {
                        // Ride Height data (convert meters to millimeters)
                        chart.data.datasets = [{
                            label: `L${refLap.lapNumber} Ride Height (${corner})`,
                            data: refLap.data[dataKey].map((val, i) => ({ x: refLap.data.distance[i], y: val * 1000 })), // meters to mm
                            borderColor: refLap.color,
                            borderWidth: 1.5,
                            pointRadius: 0,
                            tension: 0.1,
                            lapId: refLap.id
                        }];

                        const annotations = {};

                        // Add Bump Rubber Gap line if available in setup
                        const bumpRubberGapVal = parseFloat(refLap.setup?.[setupKey]);
                        if (!isNaN(bumpRubberGapVal)) {
                            // The bumpRubberGapVal is usually in mm already from setup.
                            // We need to determine the STATIC ride height where this gap is defined.
                            // For simplicity, let's assume the bumpRubberGap itself is the *threshold*
                            // in mm from the ground where the bump stops engage *relative to the chassis*.
                            // A more complex model might subtract it from a static ride height, but for visualization
                            // of a "gap" value, putting a line at that value is direct.

                            annotations.bumpGapLine = {
                                type: 'line',
                                yMin: bumpRubberGapVal,
                                yMax: bumpRubberGapVal,
                                borderColor: 'rgba(255, 193, 7, 0.7)', // Accent color (yellow)
                                borderWidth: 2,
                                borderDash: [6, 6],
                                label: {
                                    display: true,
                                    content: `Bump Stop Engages (Gap: ${bumpRubberGapVal.toFixed(1)}mm)`,
                                    position: 'start',
                                    backgroundColor: 'rgba(255, 193, 7, 0.2)',
                                    color: '#ffc107',
                                    font: { size: 10 }
                                }
                            };
                        }

                        // Add a "chassis scraping" threshold line (e.g., 1.0mm from ground)
                        const scrapingThreshold = 1.0; // mm
                        annotations.scrapingLine = {
                            type: 'line',
                            yMin: scrapingThreshold,
                            yMax: scrapingThreshold,
                            borderColor: 'rgba(220, 53, 69, 0.7)', // Red for danger
                            borderWidth: 2,
                            borderDash: [2, 2],
                            label: {
                                display: true,
                                content: `Chassis Scraping Threshold (${scrapingThreshold.toFixed(1)}mm)`,
                                position: 'end',
                                backgroundColor: 'rgba(220, 53, 69, 0.2)',
                                color: '#dc3545',
                                font: { size: 10 }
                            }
                        };

                        chart.options.plugins.annotation.annotations = annotations;
                    } else if (chart) {
                        chart.data.datasets = [];
                        chart.options.plugins.annotation.annotations = {};
                    }
                    chart.update(); // Update each ride height chart individually
                });
            } else {
                // Clear all ride height charts if no reference lap
                ['LF', 'RF', 'LR', 'RR'].forEach(corner => {
                    const chart = rhCharts[corner];
                    if (chart) {
                        chart.data.datasets = [];
                        chart.options.plugins.annotation.annotations = {};
                        chart.update();
                    }
                });
            }

            // --- SUSPENSION VELOCITY HISTOGRAM (FIXED SCALING, RANGE, AND CENTERING) ---
            const svDatasets = [];
            const wheelKeys = ['shockVelLF', 'shockVelRF', 'shockVelLR', 'shockVelRR'];
            const wheelNames = ['LF', 'RF', 'LR', 'RR'];
            const wheelColors = { 'LF': '#007bff', 'RF': '#ffc107', 'LR': '#28a745', 'RR': '#dc3545' };

            // Define a more generous, yet realistic, range for damper velocity (in m/s)
            const HIST_MIN = -2000;    // -2.0 m/s
            const HIST_MAX = 2000;    //  2.0 m/s
            const HIST_BIN = 10;       // 10 mm/s per bin

            let globalMinVel = Infinity;
            let globalMaxVel = -Infinity;

            selectedLaps.forEach(lap => {
                if (!lap.svStats) lap.svStats = {};

                wheelKeys.forEach((key, i) => {
                    const rawVelocities = lap.data[key];
                    if (!rawVelocities || rawVelocities.length === 0) return;

                    // 1) Stats for recommendations
                    const stats = computeSVStats(rawVelocities);
                    lap.svStats[wheelNames[i]] = stats;

                    // 2) Histogram for plotting (keep your existing logic)
                    const histData = calculateSVHistogram(lap, key);
                    if (histData.length > 0) {
                        svDatasets.push({
                            label: `L${lap.lapNumber} ${wheelNames[i]}`,
                            data: histData,
                            backgroundColor: wheelColors[wheelNames[i]] + '80',
                            borderColor: wheelColors[wheelNames[i]],
                            borderWidth: 1,
                            barPercentage: 1,
                            categoryPercentage: 1,
                            lapId: lap.id
                        });
                    }
                });
            });

            // --- Damper target + recommendations based on selected laps ---
            const dynamicTarget = buildDynamicDamperTargetProfile(selectedLaps);

            selectedLaps.forEach(lap => {
                if (!lap.svStats) return;
                if (!lap.damperRecommendations) lap.damperRecommendations = {};

                ['LF', 'RF', 'LR', 'RR'].forEach(w => {
                    const stats = lap.svStats[w];
                    lap.damperRecommendations[w] = makeDamperRecommendation(stats, dynamicTarget);
                });
            });

            // Update the recommendations panel
            updateDamperRecommendations();

            charts.svHistogram.data.datasets = []; // Explicitly clear
            charts.svHistogram.data.datasets = svDatasets; // Assign new

            // Set scale to be symmetrical around zero, based on the largest absolute velocity.
            if (globalMinVel !== Infinity && globalMaxVel !== -Infinity && svDatasets.length > 0) {
                const maxAbsoluteVelocity = Math.max(Math.abs(globalMinVel), Math.abs(globalMaxVel));

                // Calculate padding based on the determined range
                const rangeForPadding = maxAbsoluteVelocity * 2;
                const padding = Math.max(rangeForPadding * 0.1, 0.05); // Minimum padding of 0.05 m/s

                charts.svHistogram.options.scales.x.min = -(maxAbsoluteVelocity + padding);
                charts.svHistogram.options.scales.x.max = (maxAbsoluteVelocity + padding);
            } else {
                // Fallback defaults if no valid data found
                charts.svHistogram.options.scales.x.min = HIST_MIN;
                charts.svHistogram.options.scales.x.max = HIST_MAX;
            }

            charts.svHistogram.options.scales.y.min = 0;
            charts.svHistogram.update();
            // --- END SUSPENSION VELOCITY HISTOGRAM ---

            // --- G-Force Scatter Plot (NEW BLOCK) ---
            const gForceDatasets = [];
            let globalMinLatG = Infinity, globalMaxLatG = -Infinity;
            let globalMinLongG = Infinity, globalMaxLongG = -Infinity;

            // Use visible laps only
            selectedLaps.forEach(lap => {
                if (!lap.data.gForceLat || !lap.data.gForceLong || lap.data.gForceLat.length === 0) return;
                if (!lap.data.distance || lap.data.distance.length === 0) return;

                const data = [];
                const len = Math.min(
                    lap.data.gForceLat.length,
                    lap.data.gForceLong.length,
                    lap.data.distance.length
                );

                for (let i = 0; i < len; i++) {
                    const longG = lap.data.gForceLong[i];
                    const latG = lap.data.gForceLat[i];
                    const d = lap.data.distance[i];  // distance along lap at this sample

                    if (longG < globalMinLongG) globalMinLongG = longG;
                    if (longG > globalMaxLongG) globalMaxLongG = longG;
                    if (latG < globalMinLatG) globalMinLatG = latG;
                    if (latG > globalMaxLatG) globalMaxLatG = latG;

                    data.push({ x: longG, y: latG, d }); // <-- include distance
                }

                if (data.length > 0) {
                    gForceDatasets.push({
                        label: `L${lap.lapNumber} G-Forces`,
                        data,
                        borderColor: lap.color,
                        backgroundColor: lap.color + '40',
                        pointRadius: 1.5,
                        pointHoverRadius: 5,
                        lapId: lap.id
                    });
                }
            });

            charts.gforces.data.datasets = [];
            charts.gforces.data.datasets = gForceDatasets;

            // then axis min/max logic...
            charts.gforces.update();

            // Set symmetrical scales around zero for G-forces
            if (globalMinLatG !== Infinity && globalMaxLatG !== -Infinity && gForceDatasets.length > 0) {
                const maxAbsoluteLatG = Math.max(Math.abs(globalMinLatG), Math.abs(globalMaxLatG));
                const maxAbsoluteLongG = Math.max(Math.abs(globalMinLongG), Math.abs(globalMaxLongG));

                const paddingFactor = 0.1;
                const latGExtent = maxAbsoluteLatG + (maxAbsoluteLatG * paddingFactor);
                const longGExtent = maxAbsoluteLongG + (maxAbsoluteLongG * paddingFactor);

                // Use the largest of the two extents to ensure both axes are symmetrical and cover all data
                const overallMaxAbsG = Math.max(latGExtent, longGExtent);

                charts.gforces.options.scales.x.min = -overallMaxAbsG;
                charts.gforces.options.scales.x.max = overallMaxAbsG;
                charts.gforces.options.scales.y.min = -overallMaxAbsG;
                charts.gforces.options.scales.y.max = overallMaxAbsG;
            } else {
                // Fallback defaults if no valid G-force data
                charts.gforces.options.scales.x.min = -2;
                charts.gforces.options.scales.x.max = 2;
                charts.gforces.options.scales.y.min = -2;
                charts.gforces.options.scales.y.max = 2;
            }
            charts.gforces.update();
            // --- END G-Force Scatter Plot ---


            // 3. Track Map & Cursor
            const mapDatasets = selectedLaps.map(lap => ({
                label: `L${lap.lapNumber} (${lap.filenameWithoutExt})`,
                data: lap.data.mapX.map((x, i) => ({ x: x, y: lap.data.mapY[i] })),
                borderColor: lap.color,
                borderWidth: 2,
                showLine: true,
                pointRadius: 0,
                lapId: lap.id
            }));

            mapDatasets.push({
                label: 'Cursor',
                data: [],
                pointRadius: 6,
                pointBackgroundColor: 'white',
                pointBorderColor: 'white',
                lapId: -1
            });
            charts.map.data.datasets = mapDatasets;

            let globalMinX = Infinity, globalMaxX = -Infinity;
            let globalMinY = Infinity, globalMaxY = -Infinity;

            if (selectedLaps.length > 0) {
                selectedLaps.forEach(lap => {
                    lap.data.mapX.forEach(val => {
                        globalMinX = Math.min(globalMinX, val);
                        globalMaxX = Math.max(globalMaxX, val);
                    });
                    lap.data.mapY.forEach(val => {
                        globalMinY = Math.min(globalMinY, val);
                        globalMaxY = Math.max(globalMaxY, val);
                    });
                });

                const mapPaddingX = (globalMaxX === -Infinity) ? 0 : (globalMaxX - globalMinX) * 0.1;
                const mapPaddingY = (globalMaxY === -Infinity) ? 0 : (globalMaxY - globalMinY) * 0.1;

                charts.map.options.scales.x.min = globalMinX - mapPaddingX;
                charts.map.options.scales.x.max = globalMaxX + mapPaddingX;
                charts.map.options.scales.y.min = globalMinY - mapPaddingY;
                charts.map.options.scales.y.max = globalMaxY + mapPaddingY;
            } else {
                charts.map.options.scales.x.min = undefined;
                charts.map.options.scales.x.max = undefined;
                charts.map.options.scales.y.min = undefined;
                charts.map.options.scales.y.max = undefined;
            }

            // 4. Sector Lines Annotations
            let sectorAnnotations = {};
            if (sectorData && sectorData.definitions && refLap) {
                sectorData.definitions.forEach((sec, i) => {
                    sectorAnnotations[`sec_${i}`] = {
                        type: 'line',
                        xMin: sec.end,
                        xMax: sec.end,
                        borderColor: '#444',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        label: {
                            display: true,
                            content: `S${sec.id}`,
                            position: 'start',
                            color: '#666'
                        }
                    };
                });
            }

            // 5. ABS Areas (box annotations on inputs chart)
            let absAnnotations = {};
            if (showAbsAreas) {
                selectedLaps.forEach(lap => {
                    const dist = lap.data.distance;
                    const absArr = lap.data.brakeABSactive || [];
                    if (!dist.length || !absArr.length) return;

                    let inSegment = false;
                    let segStart = null;

                    for (let i = 0; i < dist.length; i++) {
                        const active = absArr[i] > 0;
                        if (active && !inSegment) {
                            inSegment = true;
                            segStart = dist[i];
                        } else if (!active && inSegment) {
                            inSegment = false;
                            const segEnd = dist[i];
                            const id = `abs_${lap.id}_${segStart.toFixed(3)}`;
                            absAnnotations[id] = {
                                type: 'box',
                                xMin: segStart,
                                xMax: segEnd,
                                yMin: 0,
                                yMax: 100,
                                backgroundColor: 'rgba(255, 0, 0, 0.25)',
                                borderWidth: 0,
                                drawTime: 'beforeDatasetsDraw'
                            };
                        }
                    }

                    if (inSegment) {
                        const segEnd = dist[dist.length - 1];
                        const id = `abs_${lap.id}_${segStart.toFixed(3)}_end`;
                        absAnnotations[id] = {
                            type: 'box',
                            xMin: segStart,
                            xMax: segEnd,
                            yMin: 0,
                            yMax: 100,
                            backgroundColor: 'rgba(255, 0, 0, 0.25)',
                            borderWidth: 0,
                            drawTime: 'beforeDatasetsDraw'
                        };
                    }
                });
            }

            charts.delta.options.plugins.annotation.annotations = sectorAnnotations;
            charts.speed.options.plugins.annotation.annotations = sectorAnnotations;
            charts.steering.options.plugins.annotation.annotations = sectorAnnotations;
            charts.rpm.options.plugins.annotation.annotations = sectorAnnotations;

            charts.inputs.options.plugins.annotation.annotations = {
                ...sectorAnnotations,
                ...absAnnotations
            };

            // --- Corner Loads chart (kN vs distance) ---
            // For clarity, show the reference lap if available; otherwise first visible lap.
            let loadLap = refLap || selectedLaps[0] || null;

            if (loadLap && loadLap.data.normalLoadFL && loadLap.data.normalLoadFL.length) {
                const dist = loadLap.data.distance;
                const makeLoadDs = (arr, label, color) => ({
                    label,
                    data: arr.map((val, i) => ({ x: dist[i], y: val / 1000 })), // N -> kN
                    borderColor: color,
                    borderWidth: 1.5,
                    pointRadius: 0,
                    tension: 0.1,
                    lapId: loadLap.id
                });

                charts.cornerLoad.data.datasets = [
                    makeLoadDs(loadLap.data.normalLoadFL, 'LF Load', '#ff7f7f'),
                    makeLoadDs(loadLap.data.normalLoadFR, 'RF Load', '#ffbf7f'),
                    makeLoadDs(loadLap.data.normalLoadLR, 'LR Load', '#7fbfff'),
                    makeLoadDs(loadLap.data.normalLoadRR, 'RR Load', '#7fff7f'),
                ];
            } else {
                charts.cornerLoad.data.datasets = [];
            }

            // --- Corner Loads – all selected laps ---
            const loadAllDatasets = [];

            selectedLaps.forEach(lap => {
                if (!lap.data.normalLoadFL || !lap.data.normalLoadFL.length) return;

                const dist = lap.data.distance;
                const baseColor = lap.color;

                const makeDs = (arr, cornerLabel, color, dash = []) => ({
                    label: `L${lap.lapNumber} ${cornerLabel}`,
                    data: arr.map((val, i) => ({ x: dist[i], y: val / 1000 })), // N -> kN
                    borderColor: color,
                    borderWidth: 1.0,
                    borderDash: dash,
                    pointRadius: 0,
                    tension: 0.1,
                    lapId: lap.id
                });

                // You can choose which corners to include to manage clutter.
                loadAllDatasets.push(makeDs(lap.data.normalLoadFL, 'LF', baseColor));
                loadAllDatasets.push(makeDs(lap.data.normalLoadFR, 'RF', baseColor, [4, 2]));
                loadAllDatasets.push(makeDs(lap.data.normalLoadLR, 'LR', baseColor, [2, 2]));
                loadAllDatasets.push(makeDs(lap.data.normalLoadRR, 'RR', baseColor, [6, 2]));
            });

            charts.cornerLoadAll.data.datasets = loadAllDatasets;



            Object.values(charts).forEach(chart => {
                if (chart.config.type !== 'scatter' && chart.options.scales && chart.options.scales.x) {
                    // Do not reset X-axis min/max for the SV histogram here
                    if (chart.canvas.id !== 'suspension-velocity-chart') {
                        chart.options.scales.x.min = undefined;
                        chart.options.scales.x.max = undefined;
                    }
                }
                // Only update charts not updated already (svHistogram is updated above)
                if (chart.canvas.id !== 'suspension-velocity-chart') {
                    chart.update();
                }
            });

            if (charts.delta) {
                syncScales(charts.delta);
            }
        }


        // --- New initGForceScatterChart function ---
        function initGForceScatterChart(canvasId, label, unit) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                parsing: {
                    xAxisKey: 'x',
                    yAxisKey: 'y'
                },
                interaction: { mode: 'nearest', intersect: false },
                onHover: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, elements, chartInstance),
                onLeave: (e, elements, chartInstance) => debouncedUpdateMapCursor(e, null, chartInstance),
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: { display: true, text: 'Longitudinal G (' + unit + ')', color: '#888' }, // Gray axis title
                        ticks: { color: '#888' },
                        grid: { color: '#333' }
                    },
                    y: {
                        type: 'linear',
                        position: 'left',
                        title: { display: true, text: 'Lateral G (' + unit + ')', color: '#888' }, // Gray axis title
                        ticks: { color: '#888' },
                        grid: { color: '#333' }
                    }
                },
                elements: {
                    point: {
                        radius: 1.5, // Small points for scatter
                        hoverRadius: 4
                    },
                    line: {
                        borderWidth: 0 // No line connecting points for scatter by default
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        align: 'center',
                        fullSize: true,
                        labels: { color: '#eee' } // Keep legend labels light
                    },
                    title: {
                        display: true,
                        position: 'top',
                        text: label,
                        color: '#eee', // Keep main chart title light
                        align: 'center',
                        fullSize: true
                    },
                    tooltip: {
                        enabled: false, // start with tooltips off; checkbox will control this
                        callbacks: {
                            title: function (tooltipItems) {
                                return `G-Forces`; // Shorter title for tooltip
                            },
                            label: function (tooltipItem) {
                                const lapId = tooltipItem.dataset.lapId;
                                const lap = telemetryData.find(l => l.id === lapId);
                                const lapInfo = lap ? `L${lap.lapNumber} (${lap.filenameWithoutExt})` : '';
                                return `${lapInfo} Lat: ${tooltipItem.parsed.y.toFixed(2)} G, Long: ${tooltipItem.parsed.x.toFixed(2)} G`;
                            }
                        }
                    },
                    zoom: {
                        zoom: {
                            wheel: { enabled: true },
                            pinch: { enabled: true },
                            mode: 'xy', // Zoom on both X and Y axes for scatter
                            drag: { enabled: true },
                        },
                        pan: { enabled: true, mode: 'xy' } // Pan on both X and Y axes
                    }
                }
            };

            const chart = new Chart(ctx, {
                type: 'scatter', // Use scatter chart type
                data: { datasets: [] },
                options: chartOptions
            });

            const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
            if (chartWrapper) {
                addFullscreenButton(chartWrapper, chart);
            }
            return chart;
        }



        // --- Full reset of charts ---
        function performFullReset() {
            // Reset zoom for all charts that have the plugin, except the independent histogram
            Object.values(charts).forEach(chart => {
                if (chart && chart.canvas.id !== 'suspension-velocity-chart' && chart.canvas.id !== 'gforce-scatter-chart' && chart.zoom && chart.zoom.resetZoom) {
                    chart.zoom.resetZoom();
                }
            });

            // This will update all charts' data and responsive behavior should handle initial drawing
            updateCharts();
            zoomHistory = [];
        }




        function applyZoomState(min, max) {
            const masterChart = charts.delta;
            if (!masterChart || !masterChart.options.scales || !masterChart.options.scales.x) return;

            masterChart.options.scales.x.min = min;
            masterChart.options.scales.x.max = max;
            masterChart.update('none');

            syncScales(masterChart);
        }

        // --- Reset Zoom button with hold functionality ---
        let resetZoomTimer;
        const HOLD_DURATION = 500; // ms

        document.getElementById('reset-zoom').addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                let isLongPress = false;
                resetZoomTimer = setTimeout(() => {
                    isLongPress = true;
                    performFullReset(); // Long press performs a full reset
                    resetZoomTimer = null;
                }, HOLD_DURATION);

                const mouseUpHandler = () => {
                    clearTimeout(resetZoomTimer);
                    if (!isLongPress) {
                        if (zoomHistory.length > 1) {
                            zoomHistory.pop();
                            const previousState = zoomHistory[zoomHistory.length - 1];
                            applyZoomState(previousState.min, previousState.max); // Short press "undoes" using history
                        } else {
                            // If no history, or only initial state, perform a full reset for all zoomable charts
                            performFullReset();
                        }
                    }
                    document.removeEventListener('mouseup', mouseUpHandler);
                    document.removeEventListener('mouseleave', mouseLeaveHandler);
                    resetZoomTimer = null;
                };

                const mouseLeaveHandler = () => {
                    clearTimeout(resetZoomTimer);
                    document.removeEventListener('mouseup', mouseUpHandler);
                    document.removeEventListener('mouseleave', mouseLeaveHandler);
                    resetZoomTimer = null;
                };

                document.addEventListener('mouseup', mouseUpHandler);
                document.addEventListener('mouseleave', mouseLeaveHandler);
            }
        });


        document.addEventListener('DOMContentLoaded', () => {
            const toggleTooltipsCheckbox = document.getElementById('toggle-tooltips');
            const toggleAbsAreasCheckbox = document.getElementById('toggle-abs-areas');

            toggleTooltipsCheckbox.checked = false;
            toggleTooltips(toggleTooltipsCheckbox.checked);

            toggleAbsAreasCheckbox.checked = false;
            showAbsAreas = toggleAbsAreasCheckbox.checked;

            toggleTooltipsCheckbox.addEventListener('change', (event) => {
                toggleTooltips(event.target.checked);
            });

            toggleAbsAreasCheckbox.addEventListener('change', (event) => {
                showAbsAreas = event.target.checked;
                updateCharts();
            });

            // NEW: placemat button
            document.getElementById('print-placemat')
                .addEventListener('click', openPlacematReport);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                panAllChartsX(0.1, -1);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                panAllChartsX(0.1, 1);
            }
        });

        document.getElementById('buy-coffee-btn').addEventListener('click', function () {
            window.open('https://www.buymeacoffee.com/mhmatthew', '_blank', 'noopener');
        });


        document.addEventListener('DOMContentLoaded', () => {
            // --- Globals for AI model ---
            let trainingRows = [];
            let perParamModels = {};
            const MIN_SAMPLES_FOR_PARAM = 8;

            // Setup variants
            let trainingHeaders = [];
            let trainingSetupVariants = {};
            let currentSetupKey = null;
            let baselineSetupSnapshot = null;
            let proposedSetupSnapshot = null;

            // --- DOM Elements ---
            const loadCsvBtn = document.getElementById('load-training-csv');
            const trainingFileInput = document.getElementById('training-file-input');
            const openSetupBtn = document.getElementById('open-setup-assistant');
            const closeSetupBtn = document.getElementById('close-setup-modal');
            const setupModal = document.getElementById('setup-modal');
            const setupResultEl = document.getElementById('setup-result');
            const aiLoadMeta = document.getElementById('ai-load-meta');
            const aiLoadBraking = document.getElementById('ai-load-braking');  
            const aiLoadCornering = document.getElementById('ai-load-cornering'); 
            const aiLoadToggle = document.getElementById('ai-load-toggle');
            const aiLoadDetails = document.getElementById('ai-load-details');

            if (aiLoadToggle && aiLoadDetails) {
                aiLoadToggle.addEventListener('click', () => {
                    const isCollapsed = aiLoadDetails.classList.toggle('collapsed');
                    aiLoadToggle.textContent = isCollapsed
                        ? 'Show braking & cornering load tables'
                        : 'Hide braking & cornering load tables';
                });
            }

            function updateAiLoadBlocks() {
                const refLap = telemetryData.find(l => l.id === referenceLapId)
                    || telemetryData.find(l => defaultVisibleLapIds.has(l.id));

                // ---- summary meta (you may already have updateAiLoadMeta; inline it here or call that)
                if (!refLap || !refLap.loadSummary) {
                    if (aiLoadMeta) aiLoadMeta.innerHTML =
                        '<span style="color:#888;">No load model data for current lap.</span>';
                    if (aiLoadBraking) {
                        aiLoadBraking.innerHTML = buildBrakingLoadTableHtml(refLap);
                    }
                    if (aiLoadCornering) {
                        aiLoadCornering.innerHTML = buildCorneringLoadTableHtml(refLap);
                    }
                    if (aiLoadDetails) aiLoadDetails.classList.add('collapsed');
                    if (aiLoadToggle) {
                        aiLoadToggle.textContent = 'Show braking & cornering load tables';
                    }
                    return;
                }

                const s = refLap.loadSummary;
                const f2 = x => x ? x.toFixed(2) : '0.00';

                if (aiLoadMeta) {
                    aiLoadMeta.innerHTML = `
            <div style="font-weight:600; color:#ccc; margin-bottom:2px;">
                Load snapshot – Ref L${refLap.lapNumber}
            </div>
            <div>
                <span style="color:#888;">Mean (kN):</span>
                LF ${f2(s.FL?.mean_kN)} · RF ${f2(s.FR?.mean_kN)} ·
                LR ${f2(s.LR?.mean_kN)} · RR ${f2(s.RR?.mean_kN)}
            </div>
            <div>
                <span style="color:#888;">Peak (kN):</span>
                LF ${f2(s.FL?.max_kN)} · RF ${f2(s.FR?.max_kN)} ·
                LR ${f2(s.LR?.max_kN)} · RR ${f2(s.RR?.max_kN)}
            </div>
        `;
                }

                // ---- braking loads table (with comparison to other selected laps + slowest lap)
                const selectedLapsForLoads = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
                const otherLaps = selectedLapsForLoads.filter(l => l.id !== refLap.id);

                const brakeStatsRef = computePhaseLoadStats(refLap, isHeavyBraking);
                const brakeStatsOthers = otherLaps.length
                    ? averagePhaseLoadAcrossLaps(otherLaps, isHeavyBraking)
                    : null;

                let slowestLapBraking = null;
                if (selectedLapsForLoads.length > 0) {
                    const slowest = selectedLapsForLoads.reduce((a, b) =>
                        (!a || b.lapTime > a.lapTime ? b : a), null);
                    slowestLapBraking = slowest ? computePhaseLoadStats(slowest, isHeavyBraking) : null;
                }

                if (aiLoadBraking) {
                    const totalCountRef =
                        (brakeStatsRef?.LF?.count || 0) + (brakeStatsRef?.RF?.count || 0) +
                        (brakeStatsRef?.LR?.count || 0) + (brakeStatsRef?.RR?.count || 0);

                    if (!brakeStatsRef || totalCountRef === 0) {
                        aiLoadBraking.innerHTML =
                            '<div style="color:#888;">Braking loads: not enough data.</div>';
                    } else {
                        aiLoadBraking.innerHTML = `
    <div style="font-weight:600; margin-top:4px; margin-bottom:2px;">Braking Loads (kN)</div>
    <table style="width:100%; border-collapse:collapse; font-size:0.72rem;">
        <thead>
            <tr>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Tyre</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Ref Mean</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Ref Peak</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Others Mean</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Others Peak</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Slowest Mean</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Slowest Peak</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Δ Others–Slowest (Mean)</th>
            </tr>
        </thead>
        <tbody>
            ${['LF', 'RF', 'LR', 'RR'].map(w => {
                            const ref = brakeStatsRef[w] || { mean_kN: 0, max_kN: 0 };
                            const oth = brakeStatsOthers ? (brakeStatsOthers[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                            const slow = slowestLapBraking ? (slowestLapBraking[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                            const deltaOthersSlow = oth.mean_kN - slow.mean_kN;
                            const sign = deltaOthersSlow > 0 ? '+' : '';
                            return `
                <tr>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${w}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${f2(ref.mean_kN)}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${f2(ref.max_kN)}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${brakeStatsOthers ? f2(oth.mean_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${brakeStatsOthers ? f2(oth.max_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${slowestLapBraking ? f2(slow.mean_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${slowestLapBraking ? f2(slow.max_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">
                        ${brakeStatsOthers && slowestLapBraking ? (sign + f2(deltaOthersSlow)) : '–'}
                    </td>
                </tr>`;
                        }).join('')}
        </tbody>
    </table>`;
                    }
                }


                // ---- cornering loads table (with comparison to other selected laps + slowest lap)
                const cornerStatsRef = computePhaseLoadStats(refLap, isCornering);
                const cornerStatsOthers = otherLaps.length
                    ? averagePhaseLoadAcrossLaps(otherLaps, isCornering)
                    : null;
                const slowestLapCornering = (function () {
                    if (!selectedLapsForLoads.length) return null;
                    const slowest = selectedLapsForLoads.reduce((a, b) =>
                        (!a || b.lapTime > a.lapTime ? b : a), null);
                    return slowest ? computePhaseLoadStats(slowest, isCornering) : null;
                })();

                if (aiLoadCornering) {
                    const totalCountRefC =
                        (cornerStatsRef?.LF?.count || 0) + (cornerStatsRef?.RF?.count || 0) +
                        (cornerStatsRef?.LR?.count || 0) + (cornerStatsRef?.RR?.count || 0);

                    if (!cornerStatsRef || totalCountRefC === 0) {
                        aiLoadCornering.innerHTML =
                            '<div style="color:#888;">Cornering loads: not enough data.</div>';
                    } else {
                        aiLoadCornering.innerHTML = `
    <div style="font-weight:600; margin-top:4px; margin-bottom:2px;">Cornering Loads (kN)</div>
    <table style="width:100%; border-collapse:collapse; font-size:0.72rem;">
        <thead>
            <tr>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Tyre</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Ref Mean</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Ref Peak</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Others Mean</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Others Peak</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Slowest Mean</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Slowest Peak</th>
                <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Δ Others–Slowest (Mean)</th>
            </tr>
        </thead>
        <tbody>
            ${['LF', 'RF', 'LR', 'RR'].map(w => {
                            const ref = cornerStatsRef[w] || { mean_kN: 0, max_kN: 0 };
                            const oth = cornerStatsOthers ? (cornerStatsOthers[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                            const slow = slowestLapCornering ? (slowestLapCornering[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                            const deltaOthersSlow = oth.mean_kN - slow.mean_kN;
                            const sign = deltaOthersSlow > 0 ? '+' : '';
                            return `
                <tr>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${w}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${f2(ref.mean_kN)}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${f2(ref.max_kN)}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${cornerStatsOthers ? f2(oth.mean_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${cornerStatsOthers ? f2(oth.max_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${slowestLapCornering ? f2(slow.mean_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${slowestLapCornering ? f2(slow.max_kN) : '–'}</td>
                    <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">
                        ${cornerStatsOthers && slowestLapCornering ? (sign + f2(deltaOthersSlow)) : '–'}
                    </td>
                </tr>`;
                        }).join('')}
        </tbody>
    </table>`;
                    }
                }
            }


            const aiModalInner = document.querySelector('#setup-modal .ai-setup-modal');
            const aiFullscreenBtn = document.getElementById('ai-setup-fullscreen-toggle');

            if (aiFullscreenBtn && aiModalInner) {
                aiFullscreenBtn.addEventListener('click', () => {
                    const isFs = aiModalInner.classList.toggle('fullscreen');
                    aiFullscreenBtn.textContent = isFs ? '🗗' : '⛶';
                    aiFullscreenBtn.title = isFs ? 'Exit fullscreen' : 'Toggle fullscreen';
                });
            }


            // Setup Visualization Elements
            const variantSelect = document.getElementById('ai-setup-variant-select');
            const variantWrapper = document.getElementById('ai-setup-variant-wrapper');
            const baselineMeta = document.getElementById('ai-setup-baseline-meta');
            const runSetupBtn = document.getElementById('run-setup-ai');
            const autoRecommendBtn = document.getElementById('auto-recommend-ai');
            const resetProposedBtn = document.getElementById('reset-proposed-ai');
            const autoRecommendFastestBtn = document.getElementById('auto-recommend-fastest');

            // --- Pit Card Modal Logic ---
            const openPitCardBtn = document.getElementById('open-pit-card-modal');
            const closePitCardBtn = document.getElementById('close-pit-card-modal');
            const pitCardModal = document.getElementById('pit-card-modal');
            const pitCardTrackInput = document.getElementById('pit-card-track');
            const pitCardBaselineInput = document.getElementById('pit-card-baseline');
            const pitCardNotes = pitCardModal.querySelector('.notes'); // Get the notes div within the modal

            openPitCardBtn.addEventListener('click', () => {
                pitCardModal.style.display = 'flex';

                // Attempt to pre-fill Track and Baseline from telemetry
                if (telemetryData.length > 0) {
                    const firstLap = telemetryData[0];
                    const sessionInfo = parseSessionInfo(firstLap.sessionInfoStr);

                    // Track Name
                    if (sessionInfo.trackName) {
                        pitCardTrackInput.value = sessionInfo.trackName;
                    } else {
                        pitCardTrackInput.value = ''; // Clear if no data
                    }

                    // Baseline from fastest overall lap
                    const fastestOverallLap = telemetryData.find(l => l.lapMetadata.isFastestOverall) ||
                        telemetryData.reduce((best, l) => (l.lapMetadata.isConsideredValid && l.lapTime < best.lapTime ? l : best), { lapTime: Infinity });

                    if (fastestOverallLap && fastestOverallLap.lapTime !== Infinity) {
                        pitCardBaselineInput.value = formatTime(fastestOverallLap.lapTime);
                    } else {
                        pitCardBaselineInput.value = ''; // Clear if no data
                    }
                } else {
                    pitCardTrackInput.value = '';
                    pitCardBaselineInput.value = '';
                }

                // Focus the notes input on open (if that's desired)
                if (pitCardNotes) {
                    setTimeout(() => pitCardNotes.focus(), 100);
                }
            });

            closePitCardBtn.addEventListener('click', () => {
                pitCardModal.style.display = 'none';
            });

            // Close when clicking outside the pit-card-content
            pitCardModal.addEventListener('click', (e) => {
                if (e.target === pitCardModal) {
                    pitCardModal.style.display = 'none';
                }
            });


            // --- CSV Helpers ---
            function parseCsvLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (inQuotes) {
                        if (ch === '"') {
                            if (i + 1 < line.length && line[i + 1] === '"') { current += '"'; i++; }
                            else { inQuotes = false; }
                        } else { current += ch; }
                    } else {
                        if (ch === '"') { inQuotes = true; }
                        else if (ch === ',') { result.push(current); current = ''; }
                        else { current += ch; }
                    }
                }
                result.push(current);
                return result;
            }

            function parseCsvToObjects(text) {
                const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
                if (lines.length === 0) return { headers: [], rows: [] };
                const headers = parseCsvLine(lines[0]);
                const rows = [];
                for (let i = 1; i < lines.length; i++) {
                    const cols = parseCsvLine(lines[i]);
                    if (cols.length === 0) continue;
                    const obj = {};
                    headers.forEach((h, idx) => {
                        obj[h] = (idx < cols.length) ? cols[idx] : "";
                    });
                    rows.push(obj);
                }
                return { headers, rows };
            }

            function simpleLinearRegression(xs, ys) {
                const n = xs.length;
                let sumX = 0, sumY = 0, sumXX = 0, sumXY = 0;
                for (let i = 0; i < n; i++) {
                    const x = xs[i], y = ys[i];
                    sumX += x; sumY += y;
                    sumXX += x * x;
                    sumXY += x * y;
                }
                const denom = (n * sumXX - sumX * sumX) || 1;
                const b = (n * sumXY - sumX * sumY) / denom;
                const a = (sumY - b * sumX) / n;
                return { a, b };
            }

            function buildPerParameterModels(rows) {
                const models = {};
                if (!rows.length) return models;
                const headers = Object.keys(rows[0]);
                if (!headers.includes('lapTime')) return models;

                const numericCols = headers.filter(h => h !== 'lapTime' && h !== 'file' && h !== 'lapNumber');

                numericCols.forEach(col => {
                    const xs = [];
                    const ys = [];
                    rows.forEach(r => {
                        const y = parseFloat(r.lapTime);
                        const x = parseFloat(r[col]);
                        if (!isNaN(x) && !isNaN(y)) {
                            xs.push(x);
                            ys.push(y);
                        }
                    });
                    if (xs.length < 5) return;
                    const { a, b } = simpleLinearRegression(xs, ys);
                    models[col] = { a, b, n: xs.length };
                });
                return models;
            }

            function buildSetupVariants(headers, rows) {
                const hasSetupName = headers.includes('setupName');
                const variants = {};

                rows.forEach(r => {
                    const key = (hasSetupName && r.setupName && r.setupName.trim())
                        ? r.setupName.trim()
                        : (r.file && r.file.trim()) || 'Unknown setup';

                    if (!variants[key]) variants[key] = { key, rows: [] };
                    variants[key].rows.push(r);
                });
                return variants;
            }

            function extractSetupSnapshot(headers, variantRows) {
                if (!variantRows || !variantRows.length) return {};
                const r = variantRows[0];
                const snap = {};
                headers.forEach(h => { snap[h] = r[h]; });
                return snap;
            }

            // --- 1. Load CSV Logic ---
            loadCsvBtn.addEventListener('click', () => { trainingFileInput.click(); });

            trainingFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = () => {
                    const text = reader.result;
                    const parsed = parseCsvToObjects(text);
                    trainingHeaders = parsed.headers;
                    const rows = parsed.rows.slice(1);

                    if (!rows.length || rows.length < 4) {
                        alert('Training CSV requires at least 4 data rows.');
                        return;
                    }

                    trainingRows = rows;
                    perParamModels = buildPerParameterModels(rows);
                    trainingSetupVariants = buildSetupVariants(trainingHeaders, rows);

                    // Populate Variant Dropdown
                    variantSelect.innerHTML = '';
                    const variantKeys = Object.keys(trainingSetupVariants);
                    variantKeys.forEach(k => {
                        const opt = document.createElement('option');
                        opt.value = k;
                        opt.textContent = `${k} (${trainingSetupVariants[k].rows.length} laps)`;
                        variantSelect.appendChild(opt);
                    });

                    if (variantKeys.length > 0) {
                        variantWrapper.style.display = 'block';
                        currentSetupKey = variantKeys[0];
                    }

                    alert(`Loaded ${rows.length} laps. AI ready.`);
                };
                reader.readAsText(file);
            });

            // --- 2. Setup View Updating ---
            function updateSetupView() {
                if (!currentSetupKey || !trainingSetupVariants[currentSetupKey]) return;

                const variant = trainingSetupVariants[currentSetupKey];
                baselineSetupSnapshot = extractSetupSnapshot(trainingHeaders, variant.rows);

                // If proposed is null, init it. If existing, we reset it to baseline
                // ONLY if the user switches base setups (optional behavior, usually safer to reset).
                proposedSetupSnapshot = { ...baselineSetupSnapshot };

                baselineMeta.textContent = `${variant.rows.length} laps in this configuration.`;

                renderSetupCar('ai-setup-car-baseline', baselineSetupSnapshot, baselineSetupSnapshot, false);
                renderSetupCar('ai-setup-car-proposed', proposedSetupSnapshot, baselineSetupSnapshot, true);
            }

            variantSelect.addEventListener('change', (e) => {
                currentSetupKey = e.target.value;
                updateSetupView();
                setupResultEl.textContent = ''; // Clear old predictions
                updateAiLoadBlocks();
            });

            window.onProposedInputChange = (e) => {
                const input = e.target;
                const param = input.dataset.param;
                const val = input.value;
                if (param) {
                    proposedSetupSnapshot[param] = val;
                    renderSetupCar('ai-setup-car-proposed', proposedSetupSnapshot, baselineSetupSnapshot, true);
                }
            };

            // --- 3. Modal Controls ---
            openSetupBtn.addEventListener('click', () => {
                if (!trainingRows.length) {
                    alert('Load training CSV first.');
                    return;
                }
                setupResultEl.textContent = '';
                setupModal.style.display = 'flex';
                updateSetupView();
                updateAiLoadBlocks();
            });


            closeSetupBtn.addEventListener('click', () => { setupModal.style.display = 'none'; });
            setupModal.addEventListener('click', (e) => {
                if (e.target === setupModal) setupModal.style.display = 'none';
            });

            // --- UPDATED: Auto-Recommend Button Listener ---
            autoRecommendBtn.addEventListener('click', () => {
                // 1. Validation Checks
                if (!trainingRows.length) {
                    setupResultEl.innerHTML = '<div style="color:#f88;">Load training CSV first to get setup recommendations.</div>';
                    return;
                }
                if (!baselineSetupSnapshot) {
                    setupResultEl.innerHTML = '<div style="color:#f88;">No baseline setup loaded. Please select a setup variant from the dropdown.</div>';
                    return;
                }

                // 2. Initialize
                proposedSetupSnapshot = { ...baselineSetupSnapshot }; // Reset to baseline
                let allRecommendations = []; // This will collect all {param, delta, explanation} objects
                let htmlSummaryOutput = ''; // For the summary lines (Driver Feedback, Telemetry Analysis titles)
                let htmlDetailedRecommendations = ''; // For the individual recs with explanations
                let warnings = [];

                // Find the current reference lap (or first visible lap) to analyze
                const refLap = telemetryData.find(l => l.id === referenceLapId) || telemetryData.find(l => defaultVisibleLapIds.has(l.id));

                if (!refLap) {
                    setupResultEl.innerHTML = `<div style="font-size:0.8em; font-style:italic; margin-top:10px; color:#f88;">Please select a reference lap in the "Laps" panel to perform setup analysis.</div>`;
                    return;
                }

                // Determine car configuration for specific temp targets
                const sessionInfo = parseSessionInfo(refLap.sessionInfoStr);
                const carName = sessionInfo.carScreenName || 'Unknown Car';

                let carConfig = Object.values(tireTargetsByCar).find(cfg => carName.toLowerCase().includes(cfg.label.toLowerCase())) || null;

                if (!carConfig) {
                    warnings.push(`No specific tire temperature targets for car: "${carName}". Using generic GT3 thresholds.`);
                    carConfig = GENERIC_GT3_CAR_CONFIG;
                }


                // --- A. DRIVER FEEDBACK / SYMPTOM BASED LOGIC ---
                const symptomVal = document.getElementById('ai-symptom').value;
                const symptomText = document.getElementById('ai-symptom').selectedOptions[0].text;
                const symptomRecs = getAutoRecommendations(symptomVal);

                if (symptomRecs.length > 0) {
                    htmlSummaryOutput += `<div style="font-weight:600; margin-bottom:4px; color:#ffc107;">Driver Feedback (${symptomText}):</div>`;
                    symptomRecs.forEach(rec => allRecommendations.push(rec));
                } else {
                    htmlSummaryOutput += `<div style="font-size:0.8em; font-style:italic; margin-bottom:4px; color:#888;">No specific symptom-based recommendations generated.</div>`;
                }

                // --- B. STATIC OMI ANALYSIS ---
                const hasOmiData = Object.values(refLap.tireTempsStatic || {}).some(val => val !== null && (val.O !== 0 || val.M !== 0 || val.I !== 0));

                if (hasOmiData) {
                    const omiRecs = tireTempsStaticEvaluator(carName, refLap); // Pass carName string
                    if (omiRecs.length > 0) {
                        htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#17a2b8;">Setup Analysis (Static OMI Temps from Pit Stop):</div>`;
                        omiRecs.forEach(rec => allRecommendations.push(rec));
                    } else {
                        htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#28a745;">Setup Analysis (Static OMI Temps from Pit Stop): All OMI temperatures within optimal range.</div>`;
                    }
                } else {
                    htmlSummaryOutput += `<div style="font-size:0.8em; font-style:italic; margin-top:10px; color:#888;">(Static OMI tire temperature data is not available for this lap, as it's typically only recorded at pit stops. Dynamic temperature analysis below is more relevant for flying laps.)</div>`;
                }

                // --- C. DYNAMIC BRAKING TEMP ANALYSIS (General) ---
                if (refLap.data.brake && refLap.data.brake.length > 0 && refLap.data.tempLF && refLap.data.tempLF.length > 0) {
                    const brakingStats = calculateDrivingPhaseTempStats(refLap, isHeavyBraking);
                    if (brakingStats.LF.count < 10) {
                        htmlSummaryOutput += `<div style="font-size:0.8em; font-style:italic; margin-top:10px; color:#888;">(Insufficient data points for general heavy braking phase temperature analysis.)</div>`;
                    } else {
                        const brakingRecs = getBrakingTempRecommendations(refLap, brakingStats, carConfig);
                        if (brakingRecs.length > 0) {
                            htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#e06666;">Telemetry Analysis (Tire Surface Temps during Heavy Braking):</div>`;
                            brakingRecs.forEach(rec => allRecommendations.push(rec));
                        } else {
                            htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#28a745;">Telemetry Analysis (Tire Surface Temps during Heavy Braking): Tires look balanced and within range during heavy braking.</div>`;
                        }
                    }
                } else {
                    htmlSummaryOutput += `<div style="font-size:0.8em; font-style:italic; margin-top:10px; color:#888;">(Brake pedal or tire temperature telemetry data not available for reference lap to analyze general braking temperatures.)</div>`;
                }


                // --- D. DYNAMIC CORNERING TEMP ANALYSIS ---
                htmlSummaryOutput += buildCorneringTempSummaryHtml(refLap);

                // --- E. DAMPER VELOCITY ANALYSIS (NEW) ---
                if (refLap.svStats) {
                    const damperRecs = getDamperRecommendations(refLap);
                    if (damperRecs.length > 0) {
                        htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#a0a0a0;">Telemetry Analysis (Damper Velocities):</div>`;
                        damperRecs.forEach(rec => allRecommendations.push(rec));
                    } else {
                        htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#28a745;">Telemetry Analysis (Damper Velocities): Damper histograms show good symmetry and range.</div>`;
                    }
                } else {
                    htmlSummaryOutput += `<div style="font-size:0.8em; font-style:italic; margin-top:10px; color:#888;">(Damper velocity statistics not available.)</div>`;
                }

                // --- F. BUMP STOP / RIDE HEIGHT ANALYSIS (NEW) ---
                const bumpStopRecs = getBumpStopRecommendations(refLap);
                if (bumpStopRecs.length > 0) {
                    htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#ff9900;">Telemetry Analysis (Ride Height & Bump Stops):</div>`;
                    bumpStopRecs.forEach(rec => allRecommendations.push(rec));
                } else {
                    htmlSummaryOutput += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#28a745;">Telemetry Analysis (Ride Height): No critical bottoming detected.</div>`;
                }


                // --- G. DYNAMIC BRAKING TEMP ANALYSIS PER SECTOR (NEW SECTION with comparisons) ---
                let brakingPerSectorHtml = '';
                if (refLap.data.brake && refLap.data.brake.length > 0 && refLap.data.tempLF && refLap.data.tempLF.length > 0) {
                    const maxTrackDistance = refLap.data.distance[refLap.data.distance.length - 1];
                    const effectiveMaxDistance = (maxTrackDistance > 0 && Number.isFinite(maxTrackDistance)) ? maxTrackDistance : 1000;

                    const sectorDefs = [
                        { id: 1, start: 0, end: effectiveMaxDistance / 3 },
                        { id: 2, start: effectiveMaxDistance / 3, end: (effectiveMaxDistance / 3) * 2 },
                        { id: 3, start: (effectiveMaxDistance / 3) * 2, end: effectiveMaxDistance }
                    ];

                    const wheels = ['LF', 'RF', 'LR', 'RR'];

                    const refLapBrakingData = getBrakingTempAnalysisPerSector(refLap, sectorDefs, carConfig);

                    const allValidLaps = telemetryData.filter(l => l.lapMetadata.isConsideredValid && l.lapMetadata.isComplete);

                    let fastestLap = null;
                    let slowestLap = null;

                    if (allValidLaps.length > 0) {
                        fastestLap = allValidLaps.reduce((prev, current) => (prev.lapTime < current.lapTime) ? prev : current);
                        slowestLap = allValidLaps.reduce((prev, current) => (prev.lapTime > current.lapTime) ? prev : current);
                    }

                    const allLapsBrakingResults = allValidLaps.map(lap => getBrakingTempAnalysisPerSector(lap, sectorDefs, carConfig));
                    const avgAllLapsBrakingData = averageBrakingStatsAcrossLaps(allLapsBrakingResults, sectorDefs);

                    const fastestLapBrakingData = fastestLap ? getBrakingTempAnalysisPerSector(fastestLap, sectorDefs, carConfig) : null;
                    const slowestLapBrakingData = slowestLap ? getBrakingTempAnalysisPerSector(slowestLap, sectorDefs, carConfig) : null;

                    brakingPerSectorHtml += `
        <div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#e06666;">
            Telemetry Analysis (Tire Surface Temps during Heavy Braking per Sector):
        </div>
        <div style="font-size:0.75em; color:#aaa; margin-bottom:8px;">
            Numbers are Avg / Peak °C during heavy braking. Higher peaks may indicate lockup.
        </div>
    `;

                    sectorDefs.forEach(sectorDef => {
                        const sectorId = `S${sectorDef.id}`;

                        brakingPerSectorHtml += `
    <div style="margin-bottom:10px;">
        <div style="font-size:0.9em; font-weight:bold; color:#ccc; margin-bottom:4px;">${sectorId}</div>
        <table style="width:100%; border-collapse:collapse; font-size:0.75em; margin-left:4px;">
            <thead>
                <tr>
                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444;">Tyre</th>

                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444; color:#66b0ff;">
                        Ref L${refLap.lapNumber}<br><span style="font-weight:normal;">Avg / Peak</span>
                    </th>

                    ${fastestLap ? `
                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444; color:#7dd37d;">
                        Fastest L${fastestLap.lapNumber}<br><span style="font-weight:normal;">Avg / Peak</span>
                    </th>
                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444; color:#7dd37d;">
                        Δ Ref–Fast<br><span style="font-weight:normal;">Avg / Peak</span>
                    </th>` : ''}

                    ${slowestLap ? `
                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444; color:#ff7f7f;">
                        Slowest L${slowestLap.lapNumber}<br><span style="font-weight:normal;">Avg / Peak</span>
                    </th>
                    ${fastestLap ? `
                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444; color:#ff7f7f;">
                        Δ Slow–Fast<br><span style="font-weight:normal;">Avg / Peak</span>
                    </th>` : ''}` : ''}

                    ${allValidLaps.length > 1 ? `
                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444; color:#ffd666;">
                        Avg ${allValidLaps.length} laps<br><span style="font-weight:normal;">Avg / Peak</span>
                    </th>
                    ${fastestLap ? `
                    <th style="text-align:center; padding:2px 4px; border-bottom:1px solid #444; color:#ffd666;">
                        Δ Avg–Fast<br><span style="font-weight:normal;">Avg / Peak</span>
                    </th>` : ''}` : ''}
                </tr>
            </thead>
            <tbody>
`;



                        wheels.forEach(w => {
                            const refStats = refLapBrakingData[sectorId] ? refLapBrakingData[sectorId][w] : { avg: 0, max: 0, count: 0 };
                            const fastStats = fastestLapBrakingData && fastestLapBrakingData[sectorId] ? fastestLapBrakingData[sectorId][w] : null;
                            const slowStats = slowestLapBrakingData && slowestLapBrakingData[sectorId] ? slowestLapBrakingData[sectorId][w] : null;
                            const avgAllStats = avgAllLapsBrakingData[sectorId] ? avgAllLapsBrakingData[sectorId][w] : null;

                            const fmt = s => (s && s.count > 0)
                                ? `${s.avg.toFixed(1)}° / ${s.max.toFixed(1)}°`
                                : 'N/A';

                            const fmtDelta = (base, fast) => {
                                if (!base || !fast || base.count === 0 || fast.count === 0) return 'N/A';
                                const dAvg = base.avg - fast.avg;
                                const dPeak = base.max - fast.max;
                                const signA = dAvg > 0 ? '+' : '';
                                const signP = dPeak > 0 ? '+' : '';
                                return `${signA}${dAvg.toFixed(1)}° / ${signP}${dPeak.toFixed(1)}°`;
                            };

                            brakingPerSectorHtml += `
        <tr>
            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333;">${w}</td>

            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333; color:#66b0ff;">
                ${fmt(refStats)}
            </td>

            ${fastestLap ? `
            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333; color:#7dd37d;">
                ${fmt(fastStats)}
            </td>
            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333; color:#7dd37d;">
                ${fmtDelta(refStats, fastStats)}
            </td>` : ''}

            ${slowestLap ? `
            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333; color:#ff7f7f;">
                ${fmt(slowStats)}
            </td>
            ${fastestLap ? `
            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333; color:#ff7f7f;">
                ${fmtDelta(slowStats, fastStats)}
            </td>` : ''}` : ''}

            ${allValidLaps.length > 1 ? `
            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333; color:#ffd666;">
                ${fmt(avgAllStats)}
            </td>
            ${fastestLap ? `
            <td style="text-align:center; padding:2px 4px; border-bottom:1px solid #333; color:#ffd666;">
                ${fmtDelta(avgAllStats, fastStats)}
            </td>` : ''}` : ''}
        </tr>
    `;
                        });


                        // anomalies for this sector (ref lap only)
                        const anomalies = refLapBrakingData[sectorId]?.anomalies || [];
                        brakingPerSectorHtml += `
                    </tbody>
                </table>
                ${anomalies.length ? `
                    <div style="margin-top:4px; margin-left:4px; font-size:0.75em; color:#ff8089;">
                        ${anomalies.map(a => `<div>• ${a}</div>`).join('')}
                    </div>` : ''}
            </div>
        `;
                    });
                } else {
                    brakingPerSectorHtml += `
        <div style="font-size:0.8em; font-style:italic; margin-top:10px; color:#888;">
            (Brake pedal or tire temperature telemetry data not available for reference lap to analyze braking temperatures per sector.)
        </div>`;
                }


                // --- Now, process all collected recommendations and display them ---
                if (allRecommendations.length > 0) {

                    // 1. Apply to Snapshot (if baseline exists)
                    allRecommendations.forEach(rec => {
                        const { param, delta } = rec;
                        const baselineValue = numericOrNull(baselineSetupSnapshot[param]);

                        if (baselineValue !== null) {
                            const currentPropVal = numericOrNull(proposedSetupSnapshot[param]);
                            // Apply delta
                            if (currentPropVal !== null) {
                                proposedSetupSnapshot[param] = (currentPropVal + delta).toFixed(3);
                            } else {
                                proposedSetupSnapshot[param] = (baselineValue + delta).toFixed(3);
                            }
                        } else {
                            // NEW: If baseline is missing (common for dampers), we still want to visualize the change
                            // We explicitly set the proposed value to a string indicating the change
                            if (proposedSetupSnapshot[param] === undefined || proposedSetupSnapshot[param] === "") {
                                const sign = delta > 0 ? "+" : "";
                                proposedSetupSnapshot[param] = `[Rec: ${sign}${delta}]`;
                            }
                        }
                    });

                    // 2. Generate HTML Display
                    htmlDetailedRecommendations += `<div style="font-weight:600; margin-top:12px; margin-bottom:4px;">Proposed Setup Changes:</div>`;

                    allRecommendations.forEach(rec => {
                        const { param, delta, explanation } = rec;
                        const baselineValue = numericOrNull(baselineSetupSnapshot[param]);
                        const proposedValue = proposedSetupSnapshot[param];

                        // LOGIC UPDATE: Show recommendation if Value Changed OR if Baseline was missing/unknown
                        const isValueChange = (baselineValue !== null && numericOrNull(proposedValue) !== null && Math.abs(proposedValue - baselineValue) > 0.001);
                        const isMissingBaseline = (baselineValue === null);

                        if (isValueChange || isMissingBaseline) {
                            const deltaSign = delta > 0 ? '+' : '';

                            // Formatting the header based on whether we have numbers or just a suggestion
                            let headerText = "";
                            if (isValueChange) {
                                headerText = `${param}: ${deltaSign}${delta} (New: ${parseFloat(proposedValue).toFixed(0)})`;
                            } else {
                                headerText = `${param}: Recommended ${deltaSign}${delta} click(s) (Baseline unknown)`;
                            }

                            htmlDetailedRecommendations += `
                        <div style="background:#2f2f2f; padding:6px; border-radius:3px; margin-bottom:5px; border-left: 3px solid var(--accent-color);">
                            <div style="display:flex; justify-content:space-between; font-size:0.75rem; color:#ccc; font-weight:bold;">
                                <span>${headerText}</span>
                            </div>
                            <div style="font-size:0.7rem; color:#aaa; margin-top:4px; line-height:1.4;">
                                ${explanation}
                            </div>
                        </div>
                    `;
                        }
                    });
                }



                if (warnings.length > 0) {
                    htmlSummaryOutput += `<div style="margin-top:10px; color:#e84; font-size:0.75rem;"><strong>Warnings:</strong><br>${warnings.join('<br>')}</div>`;
                }

                // 4. Update UI: Combine summary, per-sector braking analysis, and detailed recommendations
                renderSetupCar('ai-setup-car-proposed', proposedSetupSnapshot, baselineSetupSnapshot, true);
                setupResultEl.innerHTML = htmlSummaryOutput + brakingPerSectorHtml + htmlDetailedRecommendations + `<div style="color:#888; margin-top:10px; font-size:0.75rem;">Click "Analyze Proposed Changes" to see predicted lap time impact.</div>`;
            });



            // --- New: Auto-Recommend Fastest Setup Button Listener ---
            autoRecommendFastestBtn.addEventListener('click', () => {
                if (!trainingRows.length) {
                    setupResultEl.innerHTML = '<div style="color:#f88;">Load training CSV first to find the fastest setup.</div>';
                    return;
                }
                if (!baselineSetupSnapshot) {
                    setupResultEl.innerHTML = '<div style="color:#f88;">No baseline setup loaded. Select a setup variant to compare against.</div>';
                    return;
                }

                let fastestVariantKey = null;
                let minAvgLapTime = Infinity;
                let fastestLapCount = 0;
                let fastestLapFileName = '';

                // Iterate through all stored setup variants
                for (const key in trainingSetupVariants) {
                    const variant = trainingSetupVariants[key];
                    // Filter for valid lap times associated with this setup variant
                    const validLaps = variant.rows.filter(r =>
                        !isNaN(parseFloat(r.lapTime)) && parseFloat(r.lapTime) > 0
                    );

                    if (validLaps.length > 0) {
                        const sumLapTime = validLaps.reduce((sum, r) => sum + parseFloat(r.lapTime), 0);
                        const avgLapTime = sumLapTime / validLaps.length;

                        if (avgLapTime < minAvgLapTime) {
                            minAvgLapTime = avgLapTime;
                            fastestVariantKey = key;
                            fastestLapCount = validLaps.length;
                            // Take filename from first lap in the variant
                            fastestLapFileName = validLaps[0].file || 'Unknown File';
                        }
                    }
                }

                if (fastestVariantKey === null) {
                    setupResultEl.innerHTML = '<div style="color:#f88;">Could not identify a fastest setup from the loaded data. Ensure there are valid lap times.</div>';
                    return;
                }

                const fastestVariant = trainingSetupVariants[fastestVariantKey];
                const fastestSetupSnapshot = extractSetupSnapshot(trainingHeaders, fastestVariant.rows);

                // Set the proposed setup to be the fastest one found
                proposedSetupSnapshot = { ...fastestSetupSnapshot };

                // Re-render the proposed car grid with the new values
                renderSetupCar('ai-setup-car-proposed', proposedSetupSnapshot, baselineSetupSnapshot, true);

                // Provide feedback to the user
                let feedbackHtml = `
                    <div style="background:#28a745; color:white; padding:8px; border-radius:3px; margin-bottom:10px; font-weight:bold;">
                        Fastest Setup Identified!
                    </div>
                    <div style="font-size:0.8rem; color:#ccc; margin-bottom:8px;">
                        The AI analyzed your loaded data and found that setup variant
                        <strong>"${fastestVariantKey}"</strong> (from file: ${fastestLapFileName})
                        resulted in the fastest average lap time of <strong>${minAvgLapTime.toFixed(3)}s</strong>
                        over ${fastestLapCount} laps.
                        <br><br>
                        This setup has been loaded into the "Proposed Changes" column.
                        Compare it against your current baseline to see the differences and then click
                        "Analyze Proposed Changes" to evaluate the predicted impact.
                    </div>
                `;
                setupResultEl.innerHTML = feedbackHtml;
            });

            document.getElementById('reset-proposed-ai').addEventListener('click', () => {
                if (!baselineSetupSnapshot) {
                    alert('No baseline loaded.');
                    return;
                }
                // Reset proposed to baseline copy
                proposedSetupSnapshot = { ...baselineSetupSnapshot };
                // Re-render proposed UI
                renderSetupCar('ai-setup-car-proposed', proposedSetupSnapshot, baselineSetupSnapshot, true);
                // Clear previous analysis
                const setupResultEl = document.getElementById('setup-result');
                if (setupResultEl) setupResultEl.innerHTML = '';
            });


            // --- 4. Prediction Logic (Weighted & Dampened) ---
            runSetupBtn.addEventListener('click', () => {
                const symptomSel = document.getElementById('ai-symptom');
                const symptomText = symptomSel.selectedOptions[0].text;
                const symptomVal = symptomSel.value;

                let totalTimeDelta = 0;
                let cumulativeChangesHtml = [];
                let warnings = [];
                let changeCount = 0; // Track number of active changes

                // 1. Define Weights to dampen exaggerated regression models
                // Values < 1.0 reduce the impact. Aero needs heavy dampening as regression 
                // often over-correlates drag with total lap time.
                const paramWeights = {
                    'RearWingAngle': 0.10,      // Heavily dampen wing (prevents +8s errors)
                    'FrontDownforce': 0.15,
                    'FrontRhAtSpeed': 0.20,     // Rake changes are sensitive
                    'RearRhAtSpeed': 0.20,
                    'BrakePressureBias': 0.30,
                    'ArbBlades_Front': 0.40,
                    'RearArbBlades': 0.40,
                                        // NEW: Damper weights (Dampers are subtle, keep weights low)
                    'Front_LSC': 0.25, 'Rear_LSC': 0.25,
                    'Front_LSR': 0.25, 'Rear_LSR': 0.25,
                    'Front_HSC': 0.15, 'Rear_HSC': 0.15, // High speed is often noisy in data
                    'Front_HSR': 0.15, 'Rear_HSR': 0.15,

                    'default': 0.50             // General dampener for everything else

                };

                // Compare Proposed vs Baseline
                for (const key in proposedSetupSnapshot) {
                    const baseVal = parseFloat(baselineSetupSnapshot[key]);
                    const propVal = parseFloat(proposedSetupSnapshot[key]);

                    // Skip non-numeric or identical values
                    if (isNaN(baseVal) || isNaN(propVal) || Math.abs(propVal - baseVal) < 0.001) continue;

                    const delta = propVal - baseVal;
                    const model = perParamModels[key];

                    if (!model) {
                        warnings.push(`No model for <b>${key}</b> (ignoring).`);
                        continue;
                    }

                    // Count this as an active change
                    changeCount++;

                    // 2. Apply Weighted Calculation
                    // Get weight for this specific param, or use default
                    let weight = paramWeights[key] || paramWeights['default'];

                    // Further dampen if sample size is small
                    if (model.n < 12) weight *= 0.5;

                    let rawPrediction = model.b * delta;

                    // 3. Apply Hard Cap per parameter (Sanity Check)
                    // Prevents any single setting change from predicting > 1.5s gain/loss
                    // strictly based on noisy linear regression
                    const MAX_SINGLE_IMPACT = 1.2;
                    if (Math.abs(rawPrediction) > 10) {
                        // If raw prediction is absurd (e.g. 10s), the model is likely broken. 
                        // Crush the weight significantly.
                        weight *= 0.05;
                    }

                    let predictedChange = rawPrediction * weight;

                    // Clamp the result
                    predictedChange = Math.max(-MAX_SINGLE_IMPACT, Math.min(MAX_SINGLE_IMPACT, predictedChange));

                    totalTimeDelta += predictedChange;

                    // Generate combined HTML for this change
                    const paramSummary = `
                        <div style="display:flex; justify-content:space-between; font-size:0.75rem; color:#ccc;">
                            <span>${key}: ${delta > 0 ? '+' : ''}${delta.toFixed(2)}</span>
                            <span>${predictedChange > 0 ? '+' : ''}${predictedChange.toFixed(3)}s</span>
                        </div>
                    `;
                    const explanation = getDynamicExplanation(key, delta, symptomVal);

                    cumulativeChangesHtml.push(`
                        <div style="background:#2f2f2f; padding:6px; border-radius:3px; margin-bottom:5px;">
                            ${paramSummary}
                            <div style="font-size:0.7rem; color:#888; margin-top:4px;">
                                ${explanation}
                            </div>
                        </div>
                    `);
                }

                // 4. Cumulative Diminishing Returns
                // If making 5 changes, the 5th change is less effective than if done alone.
                // We multiply the total by a factor that shrinks as count grows.
                if (changeCount > 1) {
                    const complexityFactor = 1 / (1 + (0.15 * (changeCount - 1))); // e.g., 3 changes = / 1.3
                    totalTimeDelta *= complexityFactor;
                }

                if (cumulativeChangesHtml.length === 0) {
                    setupResultEl.innerHTML = '<div style="color:#f88;">No setup changes detected. Modify values in the "Proposed Changes" grid.</div>';
                    return;
                }

                // General advice for symptoms (hardcoded expert knowledge)
                let symptomAdvice = "";
                switch (symptomVal) {
                    case 'entry_understeer': symptomAdvice = "Fixes: Softer Front Spring/ARB, More Front Wing, Stiffer Rear."; break;
                    case 'mid_understeer': symptomAdvice = "Fixes: Softer Front Spring, Stiffer Rear ARB/Spring, More Rake."; break;
                    case 'exit_understeer': symptomAdvice = "Fixes: Softer Front Rebound, Stiffer Rear Spring."; break;
                    case 'entry_oversteer': symptomAdvice = "Fixes: Stiffer Front, Softer Rear Spring/ARB, More Rear Wing."; break;
                    case 'mid_oversteer': symptomAdvice = "Fixes: Stiffer Front ARB, Softer Rear Spring, Less Rake."; break;
                    case 'exit_oversteer': symptomAdvice = "Fixes: Softer Rear Spring/Bump, Less Diff Preload, Less Rear ARB."; break;
                    case 'traction': symptomAdvice = "Fixes: Softer Rear Spring, Lower Rear Ride Height, Less Diff Preload."; break;
                    case 'brake_instability': symptomAdvice = "Fixes: More Front Bias, Stiffer Front Springs, Less Rear Rebound."; break;
                    default: symptomAdvice = "Consider general setup principles for this symptom."; break;
                }

                const sign = totalTimeDelta > 0 ? '+' : '';
                const verdictColor = totalTimeDelta < -0.05 ? '#4f4' : (totalTimeDelta > 0.05 ? '#f44' : '#ccc');
                const verdict = totalTimeDelta < -0.05 ? 'FASTER' : (totalTimeDelta > 0.05 ? 'SLOWER' : 'NEUTRAL');

                setupResultEl.innerHTML = `
                    <div style="margin-bottom:8px; padding-bottom:8px; border-bottom:1px solid #444;">
                        <strong>Symptom:</strong> ${symptomText}<br>
                        <em style="color:#aaa; font-size:0.75rem;">${symptomAdvice}</em>
                    </div>
                    <div style="margin-bottom:8px;">
                        <strong>Analysis of Proposed Changes:</strong>
                        ${cumulativeChangesHtml.join('')}
                        ${warnings.length ? `<div style="margin-top:4px; color:#e84; font-size:0.7rem;"><strong>Warnings:</strong><br>${warnings.join('<br>')}</div>` : ''}
                    </div>
                    <div style="font-size:1.1em; font-weight:bold; color:${verdictColor}; text-align:right;">
                        Net Prediction: ${sign}${totalTimeDelta.toFixed(3)}s (${verdict})
                    </div>
                `;
            });
        });


        const CAR_SETUP_FIELDS = {
            LF: {
                title: 'Left Front',
                spring: 'LF_SpringRate',
                ride: 'LF_RideHeight',
                camber: 'LF_Camber',
                press: 'LF_StartingPressure',
                bumpGap: 'LF_BumpRubberGap' 
            },
            RF: {
                title: 'Right Front',
                spring: 'RF_SpringRate',
                ride: 'RF_RideHeight',
                camber: 'RF_Camber',
                press: 'RF_StartingPressure',
                bumpGap: 'RF_BumpRubberGap' 
            },
            LR: {
                title: 'Left Rear',
                spring: 'LR_SpringRate',
                ride: 'LR_RideHeight',
                camber: 'LR_Camber',
                press: 'LR_StartingPressure',
                bumpGap: 'LR_BumpRubberGap' 
            },
            RR: {
                title: 'Right Rear',
                spring: 'RR_SpringRate',
                ride: 'RR_RideHeight',
                camber: 'RR_Camber',
                press: 'RR_StartingPressure',
                bumpGap: 'RR_BumpRubberGap' 
            },
            CENTER: {
                frontArb: 'ArbBlades_Front',
                rearArb: 'RearArbBlades',
                brakeBias: 'BrakePressureBias',
                diffPreload: 'DiffPreload',
                rearWing: 'RearWingAngle',
                fuel: 'FuelLevel_Rear'
            },
            // NEW: Damper Fields (by axle)
            DAMPERS: {
                f_lsc: 'Front_LSC',
                f_hsc: 'Front_HSC',
                f_lsr: 'Front_LSR',
                f_hsr: 'Front_HSR',
                r_lsc: 'Rear_LSC',
                r_hsc: 'Rear_HSC',
                r_lsr: 'Rear_LSR',
                r_hsr: 'Rear_HSR'
            }
        };


        // Average phase-based load stats across multiple laps (weighted by sample count)
        function averagePhaseLoadAcrossLaps(laps, phaseFilterFn) {
            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const acc = {
                LF: { sumMean: 0, sumCount: 0, max: 0 },
                RF: { sumMean: 0, sumCount: 0, max: 0 },
                LR: { sumMean: 0, sumCount: 0, max: 0 },
                RR: { sumMean: 0, sumCount: 0, max: 0 }
            };

            laps.forEach(lap => {
                const stats = computePhaseLoadStats(lap, phaseFilterFn);
                if (!stats) return;
                wheels.forEach(w => {
                    const s = stats[w];
                    if (!s || !s.count) return;
                    acc[w].sumMean += s.mean_kN * s.count;
                    acc[w].sumCount += s.count;
                    if (s.max_kN > acc[w].max) acc[w].max = s.max_kN;
                });
            });

            const out = {};
            wheels.forEach(w => {
                if (!acc[w].sumCount) {
                    out[w] = { mean_kN: 0, max_kN: 0, count: 0 };
                } else {
                    out[w] = {
                        mean_kN: acc[w].sumMean / acc[w].sumCount,
                        max_kN: acc[w].max,
                        count: acc[w].sumCount
                    };
                }
            });
            return out;
        }


        // NEW: generic phase-based load stats (uses isHeavyBraking / isCornering)
        function computePhaseLoadStats(lap, phaseFilterFn) {
            if (!lap || !lap.data || !lap.data.normalLoadFL || !lap.data.normalLoadFL.length) return null;

            const n = lap.data.time.length;
            const keys = ['normalLoadFL', 'normalLoadFR', 'normalLoadLR', 'normalLoadRR'];
            const labels = ['LF', 'RF', 'LR', 'RR'];

            const totals = labels.reduce((acc, l) => {
                acc[l] = { sumN: 0, maxN: 0, count: 0 };
                return acc;
            }, {});

            for (let i = 0; i < n; i++) {
                if (!phaseFilterFn(lap, i)) continue;

                keys.forEach((k, idx) => {
                    const val = lap.data[k][i];
                    if (!Number.isFinite(val)) return;
                    const lbl = labels[idx];
                    const s = totals[lbl];
                    s.sumN += val;
                    s.count += 1;
                    if (val > s.maxN) s.maxN = val;
                });
            }

            const out = {};
            labels.forEach(lbl => {
                const s = totals[lbl];
                if (s.count === 0) {
                    out[lbl] = { mean_kN: 0, max_kN: 0, count: 0 };
                } else {
                    out[lbl] = {
                        mean_kN: (s.sumN / s.count) / 1000,
                        max_kN: s.maxN / 1000,
                        count: s.count
                    };
                }
            });
            return out;
        }

        function buildBrakingLoadTableHtml(refLap) {
            const selectedLapsForLoads = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
            const otherLaps = selectedLapsForLoads.filter(l => l.id !== refLap.id);

            const brakeStatsRef = computePhaseLoadStats(refLap, isHeavyBraking);
            const brakeStatsOthers = otherLaps.length
                ? averagePhaseLoadAcrossLaps(otherLaps, isHeavyBraking)
                : null;

            let slowestLapBraking = null;
            if (selectedLapsForLoads.length > 0) {
                const slowest = selectedLapsForLoads.reduce((a, b) =>
                    (!a || b.lapTime > a.lapTime ? b : a), null);
                slowestLapBraking = slowest ? computePhaseLoadStats(slowest, isHeavyBraking) : null;
            }

            const f2 = x => x ? x.toFixed(2) : '0.00';

            const totalCountRef =
                (brakeStatsRef?.LF?.count || 0) + (brakeStatsRef?.RF?.count || 0) +
                (brakeStatsRef?.LR?.count || 0) + (brakeStatsRef?.RR?.count || 0);

            if (!brakeStatsRef || totalCountRef === 0) {
                return '<div style="color:#888;">Braking loads: not enough data.</div>';
            }

            return `
<div style="font-weight:600; margin-top:4px; margin-bottom:2px;">Braking Loads (kN)</div>
<table style="width:100%; border-collapse:collapse; font-size:0.72rem;">
  <thead>
    <tr>
      <th>Tyre</th>
      <th>Ref Mean</th>
      <th>Ref Peak</th>
      <th>Others Mean</th>
      <th>Others Peak</th>
      <th>Slowest Mean</th>
      <th>Slowest Peak</th>
      <th>Δ Others–Slowest (Mean)</th>
    </tr>
  </thead>
  <tbody>
    ${['LF', 'RF', 'LR', 'RR'].map(w => {
                const ref = brakeStatsRef[w] || { mean_kN: 0, max_kN: 0 };
                const oth = brakeStatsOthers ? (brakeStatsOthers[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                const slow = slowestLapBraking ? (slowestLapBraking[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                const deltaOthersSlow = oth.mean_kN - slow.mean_kN;
                const sign = deltaOthersSlow > 0 ? '+' : '';
                return `
      <tr>
        <td>${w}</td>
        <td>${f2(ref.mean_kN)}</td>
        <td>${f2(ref.max_kN)}</td>
        <td>${brakeStatsOthers ? f2(oth.mean_kN) : '–'}</td>
        <td>${brakeStatsOthers ? f2(oth.max_kN) : '–'}</td>
        <td>${slowestLapBraking ? f2(slow.mean_kN) : '–'}</td>
        <td>${slowestLapBraking ? f2(slow.max_kN) : '–'}</td>
        <td>${(brakeStatsOthers && slowestLapBraking) ? (sign + f2(deltaOthersSlow)) : '–'}</td>
      </tr>`;
            }).join('')}
  </tbody>
</table>`;
        }

        function buildCorneringLoadTableHtml(refLap) {
            const selectedLapsForLoads = telemetryData.filter(l => defaultVisibleLapIds.has(l.id));
            const otherLaps = selectedLapsForLoads.filter(l => l.id !== refLap.id);

            const cornerStatsRef = computePhaseLoadStats(refLap, isCornering);
            const cornerStatsOthers = otherLaps.length
                ? averagePhaseLoadAcrossLaps(otherLaps, isCornering)
                : null;
            const f2 = x => x ? x.toFixed(2) : '0.00';

            let slowestLapCornering = null;
            if (selectedLapsForLoads.length > 0) {
                const slowest = selectedLapsForLoads.reduce((a, b) =>
                    (!a || b.lapTime > a.lapTime ? b : a), null);
                slowestLapCornering = slowest ? computePhaseLoadStats(slowest, isCornering) : null;
            }

            const totalCountRefC =
                (cornerStatsRef?.LF?.count || 0) + (cornerStatsRef?.RF?.count || 0) +
                (cornerStatsRef?.LR?.count || 0) + (cornerStatsRef?.RR?.count || 0);

            if (!cornerStatsRef || totalCountRefC === 0) {
                return '<div style="color:#888;">Cornering loads: not enough data.</div>';
            }

            return `
<div style="font-weight:600; margin-top:4px; margin-bottom:2px;">Cornering Loads (kN)</div>
<table style="width:100%; border-collapse:collapse; font-size:0.72rem;">
  <thead>
    <tr>
      <th>Tyre</th>
      <th>Ref Mean</th>
      <th>Ref Peak</th>
      <th>Others Mean</th>
      <th>Others Peak</th>
      <th>Slowest Mean</th>
      <th>Slowest Peak</th>
      <th>Δ Others–Slowest (Mean)</th>
    </tr>
  </thead>
  <tbody>
    ${['LF', 'RF', 'LR', 'RR'].map(w => {
                const ref = cornerStatsRef[w] || { mean_kN: 0, max_kN: 0 };
                const oth = cornerStatsOthers ? (cornerStatsOthers[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                const slow = slowestLapCornering ? (slowestLapCornering[w] || { mean_kN: 0, max_kN: 0 }) : { mean_kN: 0, max_kN: 0 };
                const deltaOthersSlow = oth.mean_kN - slow.mean_kN;
                const sign = deltaOthersSlow > 0 ? '+' : '';
                return `
      <tr>
        <td>${w}</td>
        <td>${f2(ref.mean_kN)}</td>
        <td>${f2(ref.max_kN)}</td>
        <td>${cornerStatsOthers ? f2(oth.mean_kN) : '–'}</td>
        <td>${cornerStatsOthers ? f2(oth.max_kN) : '–'}</td>
        <td>${slowestLapCornering ? f2(slow.mean_kN) : '–'}</td>
        <td>${slowestLapCornering ? f2(slow.max_kN) : '–'}</td>
        <td>${(cornerStatsOthers && slowestLapCornering) ? (sign + f2(deltaOthersSlow)) : '–'}</td>
      </tr>`;
            }).join('')}
  </tbody>
</table>`;
        }


        function buildCorneringTempSummaryHtml(refLap) {
            const hasSteer = Array.isArray(refLap.data.steering) && refLap.data.steering.length > 0;
            const hasTemps = Array.isArray(refLap.data.tempLF) && refLap.data.tempLF.length > 0;
            const wheels = ['LF', 'RF', 'LR', 'RR'];

            if (!hasSteer || !hasTemps) {
                return `
<div style="font-size:0.8em; font-style:italic; margin-top:4px; color:#888;">
    (Steering or tire temperature telemetry not available to analyze cornering temperatures.)
</div>`;
            }

            const refCornerStats = calculateDrivingPhaseTempStats(refLap, isCornering);
            if (!refCornerStats) {
                return `
<div style="font-size:0.8em; font-style:italic; margin-top:4px; color:#888;">
    (No samples matched the cornering filter; cannot analyze cornering temperatures.)
</div>`;
            }

            const refSamplesTotal =
                (refCornerStats.LF?.count || 0) +
                (refCornerStats.RF?.count || 0) +
                (refCornerStats.LR?.count || 0) +
                (refCornerStats.RR?.count || 0);

            if (refSamplesTotal < 8) {
                return `
<div style="font-size:0.8em; font-style:italic; margin-top:4px; color:#888;">
    (Very few samples matched the cornering filter; cornering temperature analysis is not reliable.)
</div>`;
            }

            // build comparison set: all valid laps
            const allValidLaps = telemetryData.filter(l => l.lapMetadata.isConsideredValid && l.lapMetadata.isComplete);

            let fastestLap = null;
            let slowestLap = null;
            if (allValidLaps.length > 0) {
                fastestLap = allValidLaps.reduce((best, cur) => (cur.lapTime < best.lapTime ? cur : best));
                slowestLap = allValidLaps.reduce((best, cur) => (cur.lapTime > best.lapTime ? cur : best));
            }

            const fastCornerStats = fastestLap ? calculateDrivingPhaseTempStats(fastestLap, isCornering) : null;
            const slowCornerStats = slowestLap ? calculateDrivingPhaseTempStats(slowestLap, isCornering) : null;

            function averageCorneringAcrossLaps(laps) {
                if (!laps || laps.length === 0) return null;
                const agg = {};
                wheels.forEach(w => { agg[w] = { avgSum: 0, maxSum: 0, count: 0 }; });

                laps.forEach(lap => {
                    const s = calculateDrivingPhaseTempStats(lap, isCornering);
                    if (!s) return;
                    wheels.forEach(w => {
                        const sw = s[w];
                        if (sw && sw.count > 0) {
                            agg[w].avgSum += sw.avg;
                            agg[w].maxSum += sw.max;
                            agg[w].count++;
                        }
                    });
                });

                const out = {};
                wheels.forEach(w => {
                    const a = agg[w];
                    if (a.count > 0) {
                        out[w] = {
                            avg: a.avgSum / a.count,
                            max: a.maxSum / a.count,
                            count: a.count
                        };
                    } else {
                        out[w] = { avg: 0, max: 0, count: 0 };
                    }
                });
                return out;
            }

            const avgCornerStats = averageCorneringAcrossLaps(allValidLaps);

            const fmt = s => (s && s.count > 0)
                ? `${s.avg.toFixed(1)}° / ${s.max.toFixed(1)}°`
                : 'N/A';

            const fmtDelta = (base, fast) => {
                if (!base || !fast || base.count === 0 || fast.count === 0) return 'N/A';
                const dAvg = base.avg - fast.avg;
                const dPeak = base.max - fast.max;
                const signA = dAvg > 0 ? '+' : '';
                const signP = dPeak > 0 ? '+' : '';
                return `${signA}${dAvg.toFixed(1)}° / ${signP}${dPeak.toFixed(1)}°`;
            };

            return `
<div style="font-weight:600; margin-top:12px; margin-bottom:4px; color:#6fa8dc;">
    Telemetry Analysis (Tire Surface Temps during Cornering per Lap)
</div>
<div style="font-size:0.9em; margin-top:4px; color:#ccc;">
<table style="width:100%; border-collapse:collapse; font-size:0.8em; margin-top:4px;">
    <thead>
        <tr>
            <th>Tyre</th>
            <th style="color:#66b0ff;">
                Ref L${refLap.lapNumber}<br><span style="font-weight:normal;">Avg / Peak</span>
            </th>
            ${fastestLap ? `
            <th style="color:#7dd37d;">
                Fastest L${fastestLap.lapNumber}<br><span style="font-weight:normal;">Avg / Peak</span>
            </th>
            <th style="color:#7dd37d;">
                Δ Ref–Fast<br><span style="font-weight:normal;">Avg / Peak</span>
            </th>` : ''}
            ${slowestLap ? `
            <th style="color:#ff7f7f;">
                Slowest L${slowestLap.lapNumber}<br><span style="font-weight:normal;">Avg / Peak</span>
            </th>
            ${fastestLap ? `
            <th style="color:#ff7f7f;">
                Δ Slow–Fast<br><span style="font-weight:normal;">Avg / Peak</span>
            </th>` : ''}` : ''}
            ${allValidLaps.length > 1 ? `
            <th style="color:#ffd666;">
                Avg ${allValidLaps.length} laps<br><span style="font-weight:normal;">Avg / Peak</span>
            </th>
            ${fastestLap ? `
            <th style="color:#ffd666;">
                Δ Avg–Fast<br><span style="font-weight:normal;">Avg / Peak</span>
            </th>` : ''}` : ''}
        </tr>
    </thead>
    <tbody>
        ${wheels.map(w => {
                const refS = refCornerStats[w];
                const fastS = fastCornerStats ? fastCornerStats[w] : null;
                const slowS = slowCornerStats ? slowCornerStats[w] : null;
                const avgS = avgCornerStats ? avgCornerStats[w] : null;

                return `
        <tr>
            <td>${w}</td>
            <td style="color:#66b0ff;">${fmt(refS)}</td>
            ${fastestLap ? `
            <td style="color:#7dd37d;">${fmt(fastS)}</td>
            <td style="color:#7dd37d;">${fmtDelta(refS, fastS)}</td>` : ''}
            ${slowestLap ? `
            <td style="color:#ff7f7f;">${fmt(slowS)}</td>
            ${fastestLap ? `
            <td style="color:#ff7f7f;">${fmtDelta(slowS, fastS)}</td>` : ''}` : ''}
            ${allValidLaps.length > 1 ? `
            <td style="color:#ffd666;">${fmt(avgS)}</td>
            ${fastestLap ? `
            <td style="color:#ffd666;">${fmtDelta(avgS, fastS)}</td>` : ''}` : ''}
        </tr>`;
            }).join('')}
    </tbody>
</table>
</div>`;
        }



        // --- NEW: Calculate Driving Phase Temperature Stats ---
        // This generalizes the stats calculation based on a filter function
        function calculateDrivingPhaseTempStats(lap, filterFunction) {
            if (!lap || !lap.data || !lap.data.tempLF || !lap.data.tempLF.length) return null;

            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const phaseStats = {};

            wheels.forEach(w => {
                const tempArr = lap.data[`temp${w}`];
                if (!tempArr || tempArr.length === 0) {
                    phaseStats[w] = { temps: [], avg: 0, max: 0, count: 0 };
                    return;
                }

                let sum = 0;
                let max = -Infinity;
                const relevantTemps = [];

                for (let i = 0; i < tempArr.length; i++) {
                    // Only consider points that match the filter (e.g., braking, cornering)
                    // and have a reasonable temperature (not 0 or sensor error)
                    if (filterFunction(lap, i) && tempArr[i] > 20) {
                        const val = tempArr[i];
                        relevantTemps.push(val);
                        sum += val;
                        if (val > max) max = val;
                    }
                }

                phaseStats[w] = {
                    temps: relevantTemps, // Keep raw temps for potential advanced analysis (like std dev, etc.)
                    avg: relevantTemps.length > 0 ? sum / relevantTemps.length : 0,
                    max: relevantTemps.length > 0 ? max : 0,
                    count: relevantTemps.length
                };
            });

            return phaseStats;
        }

        // --- Filter Functions for Driving Phases ---
        // Heavy braking: keep as-is
        const isHeavyBraking = (lap, i) => lap.data.brake[i] > 30;

        // Cornering: works even if gForceLat is missing; uses steering + speed as fallback
        const isCornering = (lap, i) => {
            const hasG = Array.isArray(lap.data.gForceLat) && lap.data.gForceLat.length > i;
            const latG = hasG ? (lap.data.gForceLat[i] ?? 0) : 0;
            const steerRad = lap.data.steering[i] ?? 0;
            const speedKph = lap.data.speed[i] ?? 0;

            // Ignore pit / crawl speeds
            if (speedKph < 40) return false;

            if (hasG) {
                // Use G + steering when available
                return (
                    Math.abs(latG) > 0.6 ||                                // ~0.6G+
                    (Math.abs(latG) > 0.3 && Math.abs(steerRad) > 0.10)    // ~0.3G+ & >~6°
                );
            } else {
                // Fallback: steering + speed only
                return Math.abs(steerRad) > 0.12; // ~7°+ steering at race speed
            }
        };


        /**
 * Calculates average and max tire temperatures for specified wheels during
 * phases defined by a filter function, within each sector.
 *
 * @param {object} lap The reference lap telemetry data.
 * @param {Array<object>} sectorDefinitions Array of objects {id, start, end} for sectors.
 * @param {object} carConfig Car-specific configuration including braking temp thresholds.
 * @returns {object} Structured object with per-sector braking stats and anomalies.
 */
        function getBrakingTempAnalysisPerSector(lap, sectorDefinitions, carConfig) {
            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const wheelLabels = { LF: 'Left Front', RF: 'Right Front', LR: 'Left Rear', RR: 'Right Rear' };
            const results = {};

            sectorDefinitions.forEach(sectorDef => {
                const currentSectorData = {
                    LF: [], RF: [], LR: [], RR: []
                };
                const sectorAnomalies = [];

                // Collect all braking temp samples within this sector
                for (let i = 0; i < lap.data.distance.length; i++) {
                    const dist = lap.data.distance[i];
                    if (dist >= sectorDef.start && dist <= sectorDef.end) {
                        if (isHeavyBraking(lap, i) && lap.data.tempLF[i] > 20) { // Check for valid temp > 20C
                            wheels.forEach(w => {
                                currentSectorData[w].push(lap.data[`temp${w}`][i]);
                            });
                        }
                    }
                }

                const sectorStats = {};
                wheels.forEach(w => {
                    const temps = currentSectorData[w];
                    sectorStats[w] = {
                        avg: temps.length > 0 ? temps.reduce((sum, t) => sum + t, 0) / temps.length : 0,
                        max: temps.length > 0 ? Math.max(...temps) : 0,
                        count: temps.length
                    };
                });

                // --- Anomaly Detection for this sector ---
                if (carConfig && carConfig.brakingTemps) {
                    const btCfg = carConfig.brakingTemps;

                    // Individual tire peak temp check (potential lockup/overwork)
                    wheels.forEach(w => {
                        const stats = sectorStats[w];
                        if (!stats || stats.count === 0) return;

                        const peakThreshold = w.includes('F') ? btCfg.frontPeakMax : btCfg.rearPeakMax;
                        if (stats.max > peakThreshold + 10) { // +10C buffer for anomaly
                            sectorAnomalies.push(
                                `${wheelLabels[w]} peaked significantly high (${stats.max.toFixed(1)}°C) during braking. This strongly indicates a momentary lockup or severe overheating.`
                            );
                        }
                    });

                    // Left-Right Balance on Front Axle
                    if (sectorStats.LF.count > 0 && sectorStats.RF.count > 0) {
                        const lfMax = sectorStats.LF.max;
                        const rfMax = sectorStats.RF.max;
                        const diff = Math.abs(lfMax - rfMax);

                        if (diff > btCfg.frontDiffMax + 5) { // +5C buffer
                            const hotterIsLF = lfMax > rfMax;
                            const hotterLabel = hotterIsLF ? 'Left Front' : 'Right Front';
                            const colderLabel = hotterIsLF ? 'Right Front' : 'Left Front';
                            const hotterVal = hotterIsLF ? lfMax : rfMax;
                            const colderVal = hotterIsLF ? rfMax : lfMax;

                            sectorAnomalies.push(
                                `Front axle braking temps unbalanced: ${hotterLabel} peak (${hotterVal.toFixed(1)}°C) ` +
                                `is ${diff.toFixed(1)}°C higher than ${colderLabel} (${colderVal.toFixed(1)}°C). ` +
                                `Check brake bias, suspension, or driver input.`
                            );
                        }
                    }

                    // Left-Right Balance on Rear Axle
                    if (sectorStats.LR.count > 0 && sectorStats.RR.count > 0) {
                        const lrMax = sectorStats.LR.max;
                        const rrMax = sectorStats.RR.max;
                        const diff = Math.abs(lrMax - rrMax);

                        if (diff > btCfg.rearDiffMax + 5) { // +5C buffer
                            const hotterIsLR = lrMax > rrMax;
                            const hotterLabel = hotterIsLR ? 'Left Rear' : 'Right Rear';
                            const colderLabel = hotterIsLR ? 'Right Rear' : 'Left Rear';
                            const hotterVal = hotterIsLR ? lrMax : rrMax;
                            const colderVal = hotterIsLR ? rrMax : lrMax;

                            sectorAnomalies.push(
                                `Rear axle braking temps unbalanced: ${hotterLabel} peak (${hotterVal.toFixed(1)}°C) ` +
                                `is ${diff.toFixed(1)}°C higher than ${colderLabel} (${colderVal.toFixed(1)}°C). ` +
                                `Check suspension or driver input.`
                            );
                        }
                    }
                }


                results[`S${sectorDef.id}`] = { ...sectorStats, anomalies: sectorAnomalies };
            });

            return results;
        }

        // NEW: default vehicle parameters for load model
        const g_CONST = 9.80665;

        // If you know exact values per car, you can branch by car name here.
        function buildVehicleParamsFromSetup(lap) {
            // Static corner weights from setup (already parsed)
            const WFL0 = parseFloat((lap.setup?.LF_CornerWeight || '0').toString().replace(/[^\d.-]/g, '')) || 0;
            const WFR0 = parseFloat((lap.setup?.RF_CornerWeight || '0').toString().replace(/[^\d.-]/g, '')) || 0;
            const WLR0 = parseFloat((lap.setup?.LR_CornerWeight || '0').toString().replace(/[^\d.-]/g, '')) || 0;
            const WRR0 = parseFloat((lap.setup?.RR_CornerWeight || '0').toString().replace(/[^\d.-]/g, '')) || 0;

            const W_static = WFL0 + WFR0 + WLR0 + WRR0; // N
            if (!W_static) return null;

            let m_chassis = W_static / g_CONST; // kg, approximate chassis mass w/o fuel

            // crude fuel mass estimation (if available)
            let fuelMass = 0;
            if (lap.setup?.FuelLevel_Rear) {
                const fuelL = parseFloat(lap.setup.FuelLevel_Rear.toString().replace(/[^\d.-]/g, '')) || 0;
                fuelMass = fuelL * 0.75; // ~0.75 kg/L
            }

            const m_total = m_chassis + fuelMass;

            // Aero balance from setup
            const frontDfPct = parseFloat((lap.setup?.FrontDownforce || '').toString().replace(/[^\d.-]/g, '')) || 39.0; // %
            const frontDfFrac = frontDfPct / 100;
            const rearDfFrac = 1 - frontDfFrac;

            // Generic GT3 geometry (meters) – adjust if you have car‑specific data
            const wheelbase = 2.6;
            const trackF = 1.6;
            const trackR = 1.6;
            const hCg = 0.30;

            // Roll stiffness split – start with slight front bias
            const KphiF = 0.55;
            const KphiR = 0.45;

            // A reference aero load at a reference speed (completely heuristic);
            // only relative trends matter if you’re comparing laps/setups.
            const D_ref = 3500;      // N total downforce at v_ref
            const v_ref = 70 / 3.6;  // 70 km/h in m/s (arbitrary)

            return {
                m_total,
                WFL0, WFR0, WLR0, WRR0,
                frontDfFrac,
                rearDfFrac,
                wheelbase,
                trackF,
                trackR,
                hCg,
                KphiF,
                KphiR,
                D_ref,
                v_ref
            };
        }

        // NEW: compute per‑sample normal loads for a lap
        function computeNormalLoadsForLap(lap, vp) {
            if (!vp) return;
            const {
                m_total,
                WFL0, WFR0, WLR0, WRR0,
                frontDfFrac, rearDfFrac,
                wheelbase, trackF, trackR,
                hCg, KphiF, KphiR,
                D_ref, v_ref
            } = vp;

            const n = lap.data.time.length;
            if (!n) return;

            for (let i = 0; i < n; i++) {
                const v_kph = lap.data.speed[i] || 0;
                const v = v_kph / 3.6;
                const axG = lap.data.gForceLong[i] || 0;
                const ayG = lap.data.gForceLat[i] || 0;

                const ax = axG * g_CONST;
                const ay = ayG * g_CONST;

                // aero magnitude ~ v^2 (capped for sanity)
                const vRatio = Math.max(0, Math.min(3, v / v_ref));
                const D = D_ref * vRatio * vRatio;
                const DF = D * frontDfFrac;
                const DR = D * rearDfFrac;

                const WFL_base = WFL0 + DF / 2;
                const WFR_base = WFR0 + DF / 2;
                const WLR_base = WLR0 + DR / 2;
                const WRR_base = WRR0 + DR / 2;

                // longitudinal transfer
                const dW_long = m_total * ax * hCg / wheelbase;
                const dWF_long = -dW_long;
                const dWR_long = dW_long;

                const dWFL_long = dWF_long / 2;
                const dWFR_long = dWF_long / 2;
                const dWLR_long = dWR_long / 2;
                const dWRR_long = dWR_long / 2;

                // lateral transfer
                const sign = ay >= 0 ? 1 : -1;
                const dWf_lat = m_total * ay * hCg * KphiF / trackF;
                const dWr_lat = m_total * ay * hCg * KphiR / trackR;

                const dWLF_lat = sign * dWf_lat / 2;
                const dWFR_lat = -sign * dWf_lat / 2;
                const dWLR_lat = sign * dWr_lat / 2;
                const dWRR_lat = -sign * dWr_lat / 2;

                // Remove the 'sign' constant and its usage for dWLF_lat, dWFR_lat, etc.
                // The dWf_lat and dWr_lat variables already carry the sign of lateral acceleration.
                // Lateral load transfers *opposite* to the direction of acceleration.

                // Example: If ay > 0 (acceleration to the right, so a left turn),
                // then dWf_lat > 0 and dWr_lat > 0.
                // Left wheels (inside) should LOSE load.
                // Right wheels (outside) should GAIN load.

                // Therefore:
                lap.data.normalLoadFL[i] = WFL_base + dWFL_long - dWf_lat / 2; // Subtract dWf_lat from LF
                lap.data.normalLoadFR[i] = WFR_base + dWFR_long + dWf_lat / 2; // Add dWf_lat to RF
                lap.data.normalLoadLR[i] = WLR_base + dWLR_long - dWr_lat / 2; // Subtract dWr_lat from LR
                lap.data.normalLoadRR[i] = WRR_base + dWLR_long + dWr_lat / 2; // Add dWr_lat to RR

            }
        }

        // NEW: per‑lap summary (mean and peak load per corner, in kN)
        function buildLoadSummaryForLap(lap) {
            const keys = ['normalLoadFL', 'normalLoadFR', 'normalLoadLR', 'normalLoadRR'];
            const labels = ['FL', 'FR', 'LR', 'RR'];
            const out = {};

            keys.forEach((k, idx) => {
                const arr = lap.data[k] || [];
                if (!arr.length) {
                    out[labels[idx]] = { mean_kN: 0, max_kN: 0 };
                    return;
                }
                let sum = 0;
                let max = -Infinity;
                for (let i = 0; i < arr.length; i++) {
                    const v = arr[i];
                    sum += v;
                    if (v > max) max = v;
                }
                out[labels[idx]] = {
                    mean_kN: (sum / arr.length) / 1000,
                    max_kN: max / 1000
                };
            });

            lap.loadSummary = out;
        }


        // --- NEW HELPER: Calculate Stats for Surface Temps ---
        function calculateLapTempStats(lap) {
            if (!lap || !lap.data || !lap.data.tempLF || !lap.data.tempLF.length) return null;

            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const stats = {};

            wheels.forEach(w => {
                const arr = lap.data[`temp${w}`]; // Access data.tempLF, data.tempRF, etc.
                if (!arr || arr.length === 0) {
                    stats[w] = { avg: 0, max: 0 };
                    return;
                }

                let sum = 0;
                let max = -Infinity;
                // Filter out 0 or absurdly low values (pit lane/glitches)
                let validCount = 0;

                for (let i = 0; i < arr.length; i++) {
                    const val = arr[i];
                    if (val > 20) { // Assume active track time is > 20°C
                        sum += val;
                        if (val > max) max = val;
                        validCount++;
                    }
                }

                stats[w] = {
                    avg: validCount > 0 ? sum / validCount : 0,
                    max: validCount > 0 ? max : 0
                };
            });

            return stats;
        }

        /**
 * Averages per-sector braking temperature stats across multiple laps.
 * Designed to work with the output format of `getBrakingTempAnalysisPerSector`.
 *
 * @param {Array<object>} lapsBrakingResultsArray An array where each element is the result
 *                                                of `getBrakingTempAnalysisPerSector` for one lap.
 * @param {Array<object>} sectorDefinitions Array of objects {id, start, end} for sectors.
 * @returns {object} Aggregated object with average avg and max temps per wheel per sector.
 */
        function averageBrakingStatsAcrossLaps(lapsBrakingResultsArray, sectorDefinitions) {
            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const aggregatedAverages = {};

            if (!lapsBrakingResultsArray || lapsBrakingResultsArray.length === 0) {
                return aggregatedAverages;
            }

            sectorDefinitions.forEach(sectorDef => {
                const sectorId = `S${sectorDef.id}`;
                const sectorAgg = {
                    LF: { avgSum: 0, maxSum: 0, count: 0 },
                    RF: { avgSum: 0, maxSum: 0, count: 0 },
                    LR: { avgSum: 0, maxSum: 0, count: 0 },
                    RR: { avgSum: 0, maxSum: 0, count: 0 }
                };

                lapsBrakingResultsArray.forEach(lapResult => {
                    const sectorData = lapResult[sectorId];
                    if (sectorData) {
                        wheels.forEach(w => {
                            if (sectorData[w] && sectorData[w].count > 0) {
                                sectorAgg[w].avgSum += sectorData[w].avg;
                                sectorAgg[w].maxSum += sectorData[w].max; // Summing maxes to get an average max
                                sectorAgg[w].count++;
                            }
                        });
                    }
                });

                aggregatedAverages[sectorId] = {};
                wheels.forEach(w => {
                    if (sectorAgg[w].count > 0) {
                        aggregatedAverages[sectorId][w] = {
                            avg: sectorAgg[w].avgSum / sectorAgg[w].count,
                            max: sectorAgg[w].maxSum / sectorAgg[w].count,
                            count: sectorAgg[w].count
                        };
                    } else {
                        aggregatedAverages[sectorId][w] = { avg: 0, max: 0, count: 0 };
                    }
                });
            });

            return aggregatedAverages;
        }


        // --- NEW: Generate Setup Changes based on Surface Temps ---
        function getTempBasedRecommendations(stats) {
            const recs = [];
            if (!stats) return recs;

            // Generic GT3 Surface Temp Targets (Celsius)
            const TARGET_AVG_MIN = 75;
            const TARGET_AVG_MAX = 95;
            const TARGET_MAX_PEAK = 115; // Momentary peak during cornering

            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const wheelLabels = { LF: 'Left Front', RF: 'Right Front', LR: 'Left Rear', RR: 'Right Rear' };

            wheels.forEach(w => {
                const s = stats[w];
                const pressureParam = `${w}_StartingPressure`;
                const camberParam = `${w}_Camber`; // Assuming Camber variable name

                // 1. Check Averages (Pressure)
                if (s.avg > TARGET_AVG_MAX) {
                    // Too Hot -> Lower Pressure
                    recs.push({
                        param: pressureParam,
                        delta: -1.0, // psi (or whatever unit sim uses)
                        explanation: `${wheelLabels[w]} Surface Avg is ${s.avg.toFixed(1)}°C (High). Reducing starting pressure helps reduce the "ballooning" effect and contact patch heat generation.`
                    });
                } else if (s.avg < TARGET_AVG_MIN) {
                    // Too Cold -> Higher Pressure
                    recs.push({
                        param: pressureParam,
                        delta: +1.0,
                        explanation: `${wheelLabels[w]} Surface Avg is ${s.avg.toFixed(1)}°C (Low). Increasing starting pressure stiffens the carcass and generates heat faster.`
                    });
                }

                // 2. Check Peaks (Camber/Scrubbing indication)
                if (s.max > TARGET_MAX_PEAK) {
                    recs.push({
                        param: camberParam,
                        delta: 0.2, // Move closer to positive/0 to reduce edge heating
                        explanation: `${wheelLabels[w]} is spiking to ${s.max.toFixed(1)}°C in corners. This extreme peak suggests the tire is being overworked or dragging on an edge. Reducing negative camber slightly might distribute the load better.`
                    });
                }
            });

            return recs;
        }

        // --- NEW: Braking Temp Recommendations ---
        function getBrakingTempRecommendations(lap, brakingStats, carConfig) {
            const recs = [];
            if (!brakingStats || !carConfig || !carConfig.brakingTemps) return recs;

            const btCfg = carConfig.brakingTemps;
            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const wheelLabels = { LF: 'Left Front', RF: 'Right Front', LR: 'Left Rear', RR: 'Right Rear' };

            // Axle Averages (for bias assessment)
            const avgFrontBrakeTemp = (brakingStats.LF.avg + brakingStats.RF.avg) / 2;
            const avgRearBrakeTemp = (brakingStats.LR.avg + brakingStats.RR.avg) / 2;

            // Check overall brake bias balance (Front vs. Rear Temps)
            if (brakingStats.LF.count > 0 && brakingStats.RF.count > 0 && brakingStats.LR.count > 0 && brakingStats.RR.count > 0) {
                if (avgFrontBrakeTemp > btCfg.frontPeakMax * 1.1 && avgRearBrakeTemp < btCfg.rearPeakMax * 0.9) {
                    recs.push({
                        param: 'BrakePressureBias',
                        delta: -0.5, // Shift bias rearward
                        explanation: `Excessive front tire temps (${avgFrontBrakeTemp.toFixed(1)}°C avg) during braking suggest too much brake bias to the front. Consider shifting brake bias slightly rearward to balance load and reduce front overheating.`
                    });
                } else if (avgRearBrakeTemp > btCfg.rearPeakMax * 1.1 && avgFrontBrakeTemp < btCfg.frontPeakMax * 0.9) {
                    recs.push({
                        param: 'BrakePressureBias',
                        delta: +0.5, // Shift bias forward
                        explanation: `Excessive rear tire temps (${avgRearBrakeTemp.toFixed(1)}°C avg) during braking suggest too much brake bias to the rear. Consider shifting brake bias slightly forward to prevent rear lockup and overheating.`
                    });
                }
            }


            wheels.forEach(w => {
                const s = brakingStats[w];
                const pressureParam = `${w}_StartingPressure`; // This is an OMI-related adjustment, but can apply to general temp issues

                if (s.count === 0) return; // No braking data for this wheel

                // Individual wheel overheating during braking
                if (w.includes('F')) { // Front wheels
                    if (s.max > btCfg.frontPeakMax + 10) { // +10 for a buffer
                        recs.push({
                            param: pressureParam, // Often overpressure or camber related for high peaks
                            delta: -0.5, // Small reduction
                            explanation: `${wheelLabels[w]} peaked at ${s.max.toFixed(1)}°C during braking (too high for front). This could indicate momentary lockup or aggressive load. A slight pressure reduction might offer more grip and compliance.`
                        });
                    }
                } else { // Rear wheels
                    if (s.max > btCfg.rearPeakMax + 10) {
                        recs.push({
                            param: pressureParam,
                            delta: -0.5,
                            explanation: `${wheelLabels[w]} peaked at ${s.max.toFixed(1)}°C during braking (too high for rear). This could indicate rear instability or lockup. A slight pressure reduction might improve stability.`
                        });
                    }
                }

                // Left/Right Balance on an axle during braking
                // This is tricky without knowing if the braking was straight. We'll simplify.
                // If one side is significantly hotter than the other AND braking stats are available for both
                const isLeft = w === 'LF' || w === 'LR';
                const otherSide = isLeft ? (w.includes('F') ? 'RF' : 'RR') : (w.includes('F') ? 'LF' : 'LR');
                const otherStats = brakingStats[otherSide];

                if (otherStats && otherStats.count > 0) {
                    const diff = Math.abs(s.max - otherStats.max);
                    const threshold = w.includes('F') ? btCfg.frontDiffMax : btCfg.rearDiffMax;
                    if (diff > threshold + 5) { // +5 buffer
                        // This could indicate a brake imbalance, warped disc, or suspension issue.
                        // For simplicity, we'll suggest a general check, or a very minor pressure adjustment.
                        recs.push({
                            param: pressureParam,
                            delta: (s.max > otherStats.max) ? -0.2 : 0.2, // Minor adjustment to hotter tire
                            explanation: `${wheelLabels[w]} is significantly hotter (${s.max.toFixed(1)}°C vs ${otherStats.max.toFixed(1)}°C) during braking. This suggests a side-to-side imbalance in braking force or load transfer. Consider checking brake system, suspension settings, or a minor pressure adjustment.`
                        });
                    }
                }
            });

            return recs;
        }

        // --- NEW: Cornering Temp Recommendations ---
        function getCorneringTempRecommendations(lap, corneringStats, carConfig) {
            const recs = [];
            if (!corneringStats || !carConfig || !carConfig.corneringTemps) return recs;

            const ctCfg = carConfig.corneringTemps;
            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const wheelLabels = { LF: 'Left Front', RF: 'Right Front', LR: 'Left Rear', RR: 'Right Rear' };

            wheels.forEach(w => {
                const s = corneringStats[w];
                const camberParam = `${w}_Camber`;
                const springParam = `${w}_SpringRate`; // Could also be ARB

                if (s.count === 0) return; // No cornering data for this wheel

                // Identify "outer" and "inner" tires in general terms during cornering.
                // This is simplified and assumes roughly equal distribution left/right.
                // A more complex system would need to determine left/right corners.
                // For simplicity here, we'll check all wheels against outer/inner bounds.

                // Is this tire getting too hot (likely scrubbing/overworked)?
                if (s.avg > ctCfg.outerAvgMax + 5) { // +5 buffer
                    recs.push({
                        param: springParam,
                        delta: (w.includes('F') ? 0.5 : -0.5), // Stiffen front, soften rear
                        explanation: `${wheelLabels[w]} is significantly hot (${s.avg.toFixed(1)}°C avg) during cornering. This suggests the tire is being overworked or scrubbing excessively. Consider adjusting spring rate (${w.includes('F') ? 'stiffer front' : 'softer rear'}) or ARB to control load transfer.`
                    });
                }

                // Is this tire too cold (not being worked enough)?
                else if (s.avg < ctCfg.innerAvgMin - 5 && s.max < ctCfg.outerAvgMin) { // -5 buffer, and ensure max isn't even hitting outer min
                    recs.push({
                        param: springParam,
                        delta: (w.includes('F') ? -0.5 : 0.5), // Soften front, stiffen rear
                        explanation: `${wheelLabels[w]} is too cold (${s.avg.toFixed(1)}°C avg) during cornering. This suggests it's not being loaded enough. Consider adjusting spring rate (${w.includes('F') ? 'softer front' : 'stiffer rear'}) or ARB to increase load transfer to this tire.`
                    });
                }

                // Camber recommendations based on peak cornering temps
                if (s.max > ctCfg.peakMax + 10) { // Very high peak temp, possible inner/outer shoulder overload
                    recs.push({
                        param: camberParam,
                        delta: 0.2, // Reduce negative camber
                        explanation: `${wheelLabels[w]} spiked to ${s.max.toFixed(1)}°C during cornering. This indicates extreme load or scrubbing on a specific part of the tire. A slight reduction in negative camber might spread the load more evenly and reduce peak temperatures.`
                    });
                }
            });

            return recs;
        }


        function numericOrNull(v) {
            if (v === null || v === undefined || v === '') return null;
            const n = parseFloat(v);
            return isNaN(n) ? null : n;
        }

        // --- NEW/UPDATED: per‑car tire temp/gradient targets ---
        const tireTargetsByCar = {
            porsche992gt3r: {
                label: 'Porsche 911 GT3 R',
                frontAvg: { min: 80, max: 92 },
                rearAvg: { min: 88, max: 105 },
                ioFront: { min: 8, max: 18 },
                ioRear: { min: 5, max: 15 },
                midGood: 4, // |M‑edges| <= 4 good
                midWarn: 7, // >7 = strongly off

                // Specific braking temp thresholds (°C) <--- ADD THIS BLOCK
                brakingTemps: {
                    frontPeakMax: 110, // Max acceptable peak temp for front during braking
                    rearPeakMax: 95,   // Max acceptable peak temp for rear during braking
                    frontDiffMax: 8,   // Max acceptable difference between LF/RF peak temps during braking
                    rearDiffMax: 6,    // Max acceptable difference between LR/RR peak temps during braking
                },
                // Specific cornering temp thresholds (°C) <--- ADD THIS BLOCK
                corneringTemps: {
                    outerAvgMin: 90,
                    outerAvgMax: 105,
                    innerAvgMin: 70, // Min acceptable average for less loaded inner tire
                    innerAvgMax: 85,
                    sideDiffMax: 20, // Max acceptable difference between L/R on same axle during cornering
                    peakMax: 120,    // Absolute max peak temp during cornering
                }
            },
            ferrari296gt3: {
                label: 'Ferrari 296 GT3',
                frontAvg: { min: 82, max: 95 },
                rearAvg: { min: 85, max: 100 },
                ioFront: { min: 5, max: 15 },
                ioRear: { min: 3, max: 12 },
                midGood: 4,
                midWarn: 7,

                // Specific braking temp thresholds (°C) <--- ADD THIS BLOCK
                brakingTemps: {
                    frontPeakMax: 105,
                    rearPeakMax: 90,
                    frontDiffMax: 7,
                    rearDiffMax: 5,
                },
                // Specific cornering temp thresholds (°C) <--- ADD THIS BLOCK
                corneringTemps: {
                    outerAvgMin: 85,
                    outerAvgMax: 100,
                    innerAvgMin: 65,
                    innerAvgMax: 80,
                    sideDiffMax: 18,
                    peakMax: 115,
                }
            }
        };


        // --- Add this Generic Fallback config. Place this near tireTargetsByCar if not already present ---
        // --- Generic Fallback Car Config (for unknown cars) ---
        const GENERIC_GT3_CAR_CONFIG = {
            label: 'Generic GT3',
            frontAvg: { min: 80, max: 92 },
            rearAvg: { min: 88, max: 105 },
            ioFront: { min: 6, max: 16 },
            ioRear: { min: 4, max: 14 },
            midGood: 4,
            midWarn: 7,
            brakingTemps: { // <--- ADD THIS BLOCK
                frontPeakMax: 100,
                rearPeakMax: 85,
                frontDiffMax: 7,
                rearDiffMax: 5
            },
            corneringTemps: { // <--- ADD THIS BLOCK
                outerAvgMin: 80,
                outerAvgMax: 95,
                innerAvgMin: 60,
                innerAvgMax: 75,
                sideDiffMax: 15,
                peakMax: 110
            }
        };



        // Call after you've populated lap.tireTempsStatic.{LF,RF,LR,RR} from *_LastTempsOMI
        // and lap.setup.*_StartingPressure / *_LastHotPressure / TreadRemaining.
        //
        // Returns: array of short, plain‑English hints for Porsche 911 GT3 R or Ferrari 296 GT3.
        // Safe no‑op for other cars (returns []).

        // --- UPDATED: Generate Setup Changes based on Static OMI Temps ---
        function tireTempsStaticEvaluator(carName, lap) { // Changed to accept carName as first argument
            if (!lap || !lap.tireTempsStatic) return [];

            // --- 1) Car‑specific thresholds ---
            const carKey = (carName || '').toLowerCase();
            let cfg;

            if (carKey.includes('porsche') && carKey.includes('gt3')) {
                cfg = tireTargetsByCar.porsche992gt3r;
            } else if (carKey.includes('ferrari') && carKey.includes('296')) {
                cfg = tireTargetsByCar.ferrari296gt3;
            } else {
                return []; // not a supported GT3 – exit quietly
            }

            const hints = []; // Now collecting objects
            const wheels = ['LF', 'RF', 'LR', 'RR'];
            const sideLabel = { LF: 'left‑front', RF: 'right‑front', LR: 'left‑rear', RR: 'right‑rear' };
            const axle = w => (w[1] === 'F' ? 'front' : 'rear');

            // helper: grab static O/M/I/avg data
            function tt(w) { return lap.tireTempsStatic[w] || null; }

            // helper: pressures if present
            function getPressures(w) {
                return {
                    start: parseFloat(lap.setup?.[`${w}_StartingPressure`] ?? ''),
                    hot: parseFloat(lap.setup?.[`${w}_LastHotPressure`] ?? ''),
                };
            }

            // helper: tread remaining if present (0–100%)
            function getTread(w) {
                const v = lap.setup?.[`${w}_TreadRemaining`];
                const n = typeof v === 'string' ? parseFloat(v) : (typeof v === 'number' ? v : NaN);
                return Number.isFinite(n) ? n : null;
            }

            // --- 2) Per‑wheel evaluations ---

            wheels.forEach(w => {
                const d = tt(w);
                if (!d) return;

                const ax = axle(w);
                const isFront = ax === 'front';
                const isRear = ax === 'rear';

                const avg = d.avg;
                const io = d.insideMinusOutside;   // I - O
                const me = d.middleMinusEdges;     // M - (I+O)/2

                const press = getPressures(w);
                const tread = getTread(w);

                // 2a) Avg temp window
                if (isFront) {
                    if (avg < cfg.frontAvg.min - 3) {
                        hints.push({ param: `${w}_StartingPressure`, delta: -0.5, explanation: `The ${sideLabel[w]} carcass is cool at ~${avg.toFixed(1)}°C (below the ${cfg.label} front target of ${cfg.frontAvg.min}–${cfg.frontAvg.max}°C). Consider slightly lower pressure or working the fronts harder with setup (softer front ARB/springs) or driving.` });
                    } else if (avg > cfg.frontAvg.max + 3) {
                        hints.push({ param: `${w}_Camber`, delta: 0.1, explanation: `The ${sideLabel[w]} carcass is hot at ~${avg.toFixed(1)}°C (above the ${cfg.label} front target of ${cfg.frontAvg.min}–${cfg.frontAvg.max}°C). Check for over‑aggressive camber or pressure, and consider small reductions to load or camber on that corner.` });
                    }
                } else if (isRear) {
                    if (avg < cfg.rearAvg.min - 3) {
                        hints.push({ param: `${w}_StartingPressure`, delta: -0.5, explanation: `The ${sideLabel[w]} carcass is relatively cool at ~${avg.toFixed(1)}°C (rear target for the ${cfg.label} is ${cfg.rearAvg.min}–${cfg.rearAvg.max}°C). You may have unused rear grip – consider slightly lower rear pressures or a softer rear to help traction.` });
                    } else if (avg > cfg.rearAvg.max + 3) {
                        hints.push({ param: `${w}_Camber`, delta: 0.1, explanation: `The ${sideLabel[w]} carcass is running hot at ~${avg.toFixed(1)}°C (above the ${cfg.label} rear target of ${cfg.rearAvg.min}–${cfg.rearAvg.max}°C). That corner is likely over‑worked – consider easing camber or rear stiffness, or a small pressure reduction if middle is hottest.` });
                    }
                }

                // 2b) Camber via Inside‑Outside
                if (isFront) {
                    if (io > cfg.ioFront.max + 2) {
                        hints.push({ param: `${w}_Camber`, delta: 0.2, explanation: `On the ${sideLabel[w]}, the inner carcass is much hotter than the outer (Δ inside‑outside ≈ ${io.toFixed(1)}°C, above the ${cfg.label} front camber target). This usually means too much front camber or too flat a platform – try reducing camber slightly on that front corner.` });
                    } else if (io < cfg.ioFront.min - 2) {
                        hints.push({ param: `${w}_Camber`, delta: -0.2, explanation: `On the ${sideLabel[w]}, inside vs outside carcass temps are nearly flat (Δ ≈ ${io.toFixed(1)}°C, below the ${cfg.label} front camber target). You may be rolling onto the outside shoulder; a touch more front camber or roll stiffness can help mid‑corner grip.` });
                    }
                } else if (isRear) {
                    if (io > cfg.ioRear.max + 2) {
                        hints.push({ param: `${w}_Camber`, delta: 0.2, explanation: `On the ${sideLabel[w]}, the inner carcass is much hotter than the outer (Δ inside‑outside ≈ ${io.toFixed(1)}°C, above the ${cfg.label} rear camber target). This often indicates too much rear camber and can hurt traction – consider reducing rear camber slightly on that side.` });
                    } else if (io < cfg.ioRear.min - 2) {
                        hints.push({ param: `${w}_Camber`, delta: -0.2, explanation: `On the ${sideLabel[w]}, inside vs outside carcass temps are very even or outer‑biased (Δ ≈ ${io.toFixed(1)}°C, below the ${cfg.label} rear camber target). If rear stability is good but you lack lateral grip, a little more rear camber may help.` });
                    }
                }

                // 2c) Pressure via Middle‑Edges
                const absME = Math.abs(me);
                if (absME > cfg.midGood) {
                    if (me > cfg.midGood) {
                        const dir = press.start ? ` (cold ${press.start.toFixed(1)}, hot ${isNaN(press.hot) ? 'n/a' : press.hot.toFixed(1)})` : '';
                        hints.push({ param: `${w}_StartingPressure`, delta: -0.5, explanation: `On the ${sideLabel[w]}, the middle carcass is hotter than the edges (M‑edges ≈ +${me.toFixed(1)}°C${dir}). That usually means pressure slightly high – try a small reduction in starting pressure on this tyre.` });
                    } else if (me < -cfg.midGood) {
                        const dir = press.start ? ` (cold ${press.start.toFixed(1)}, hot ${isNaN(press.hot) ? 'n/a' : press.hot.toFixed(1)})` : '';
                        hints.push({ param: `${w}_StartingPressure`, delta: 0.5, explanation: `On the ${sideLabel[w]}, the edges are hotter than the middle (M‑edges ≈ ${me.toFixed(1)}°C${dir}). That usually means pressure slightly low – try a small increase in starting pressure on this tyre.` });
                    }
                }

                // 2d) Wear sanity check (if available)
                if (tread !== null && tread < 80 && avg > cfg.rearAvg.min - 2) {
                    hints.push({ param: `${w}_Camber`, delta: 0.1, explanation: `Tread remaining on the ${sideLabel[w]} is down to about ${tread.toFixed(0)}%. Combined with temps in the current range, this corner is working hard over a stint – consider easing camber or pressure a touch if long‑run balance is an issue.` });
                }
            });

            // --- 3) Axle‑level balance hints (front vs rear) ---

            const frontTemps = ['LF', 'RF'].map(tt).filter(Boolean).map(d => d.avg);
            const rearTemps = ['LR', 'RR'].map(tt).filter(Boolean).map(d => d.avg);
            if (frontTemps.length === 2 && rearTemps.length === 2) {
                const fAvg = (frontTemps[0] + frontTemps[1]) / 2;
                const rAvg = (rearTemps[0] + rearTemps[1]) / 2;
                const diff = rAvg - fAvg;

                if (cfg.label.includes('Porsche')) {
                    if (diff > 12) {
                        hints.push({ param: 'RearArbBlades', delta: 0.5, explanation: `On this ${cfg.label}, rear carcass temps are on average ~${diff.toFixed(1)}°C hotter than the fronts. That’s a strong rear bias and often means the car is front‑limited – consider helping the fronts (slightly lower front pressures, softer front ARB/springs, or a small rear wing reduction if high‑speed understeer is the main complaint).` });
                    } else if (diff < 4) {
                        hints.push({ param: 'RearArbBlades', delta: -0.5, explanation: `Front and rear carcass temps on this ${cfg.label} are very similar (rear‑front Δ ≈ ${diff.toFixed(1)}°C). That can be fine, but this car is normally a bit rear‑biased; if you feel rear instability, check that you haven’t over‑reduced rear camber/pressure or over‑stiffened the rear.` });
                    }
                } else if (cfg.label.includes('Ferrari')) {
                    if (diff > 10) {
                        hints.push({ param: 'RearArbBlades', delta: 0.5, explanation: `Rear carcass temps on the ${cfg.label} are ~${diff.toFixed(1)}°C hotter than the fronts. If you have traction fade or oversteer on exit, consider easing rear camber or stiffness, or adding a click of rear wing.` });
                    } else if (diff < -5) {
                        hints.push({ param: 'FrontRhAtSpeed', delta: 0.001, explanation: `Front carcass temps on the ${cfg.label} are hotter than the rears by about ${(-diff).toFixed(1)}°C. If you feel front instability or early front wear, look at slightly reducing front camber or pressure, or shifting some balance rearward (rear ARB/springs or wing).` });
                    }
                }
            }

            return hints;
        }

        function renderSetupCar(containerId, snapshot, baseline, isEditable) {
            const el = document.getElementById(containerId);
            if (!el) return;
            const base = baseline || snapshot || {};
            const snap = snapshot || {};

            function fieldBlock(label, colName) {
                const baseVal = base[colName] ?? '';
                const curVal = snap[colName] ?? '';
                const baseNum = numericOrNull(baseVal);
                const curNum = numericOrNull(curVal);
                let deltaHtml = '';
                if (baseNum !== null && curNum !== null && curNum !== baseNum) {
                    const d = curNum - baseNum;
                    const sign = d > 0 ? '+' : '';
                    deltaHtml = `<span class="delta">${sign}${d.toFixed(2)}</span>`;
                }

                if (!isEditable) {
                    return `
                          <div class="ai-setup-corner-field">
                            <span class="label">${label}</span>
                            <span class="value">${curVal}</span>
                          </div>`;
                }

                return `
                      <div class="ai-setup-corner-field">
                        <span class="label">${label}</span>
                        <input class="ai-setup-input"
                               data-param="${colName}"
                               value="${curVal}"
                               />
                        ${deltaHtml}
                      </div>`;
            }

            el.innerHTML = `
                  <div class="ai-setup-car-row">
                    <!-- ... existing Front Row code ... -->
                    <div class="ai-setup-corner">
                      <div class="ai-setup-corner-header">${CAR_SETUP_FIELDS.LF.title}</div>
                      ${fieldBlock('Spring', CAR_SETUP_FIELDS.LF.spring)}
                      ${fieldBlock('Ride H.', CAR_SETUP_FIELDS.LF.ride)}
                      ${fieldBlock('Bump Gap', CAR_SETUP_FIELDS.LF.bumpGap)} 
                      ${fieldBlock('Camber', CAR_SETUP_FIELDS.LF.camber)}
                      ${fieldBlock('Press.', CAR_SETUP_FIELDS.LF.press)}
                    </div>
                    <div class="ai-setup-corner">
                      <div class="ai-setup-corner-header">${CAR_SETUP_FIELDS.RF.title}</div>
                      ${fieldBlock('Spring', CAR_SETUP_FIELDS.RF.spring)}
                      ${fieldBlock('Ride H.', CAR_SETUP_FIELDS.RF.ride)}
                      ${fieldBlock('Bump Gap', CAR_SETUP_FIELDS.RF.bumpGap)} 
                      ${fieldBlock('Camber', CAR_SETUP_FIELDS.RF.camber)}
                      ${fieldBlock('Press.', CAR_SETUP_FIELDS.RF.press)}
                    </div>
                  </div>

                  <div class="ai-setup-car-center">
                    <!-- ... existing Center blocks ... -->
                    <div class="ai-setup-center-block">
                      <div class="ai-setup-center-block-header">Front / Brakes</div>
                      ${fieldBlock('Front ARB', CAR_SETUP_FIELDS.CENTER.frontArb)}
                      ${fieldBlock('Brake Bias', CAR_SETUP_FIELDS.CENTER.brakeBias)}
                    </div>
                    <div class="ai-setup-center-block">
                      <div class="ai-setup-center-block-header">Diff / Fuel</div>
                      ${fieldBlock('Diff Preload', CAR_SETUP_FIELDS.CENTER.diffPreload)}
                      ${fieldBlock('Fuel', CAR_SETUP_FIELDS.CENTER.fuel)}
                    </div>
                    <div class="ai-setup-center-block">
                      <div class="ai-setup-center-block-header">Rear / Aero</div>
                      ${fieldBlock('Rear ARB', CAR_SETUP_FIELDS.CENTER.rearArb)}
                      ${fieldBlock('Rear Wing', CAR_SETUP_FIELDS.CENTER.rearWing)}
                    </div>
                  </div>

                  <div class="ai-setup-car-row">
                    <!-- ... existing Rear Row code ... -->
                    <div class="ai-setup-corner">
                      <div class="ai-setup-corner-header">${CAR_SETUP_FIELDS.LR.title}</div>
                      ${fieldBlock('Spring', CAR_SETUP_FIELDS.LR.spring)}
                      ${fieldBlock('Ride H.', CAR_SETUP_FIELDS.LR.ride)}
                      ${fieldBlock('Bump Gap', CAR_SETUP_FIELDS.LR.bumpGap)} 
                      ${fieldBlock('Camber', CAR_SETUP_FIELDS.LR.camber)}
                      ${fieldBlock('Press.', CAR_SETUP_FIELDS.LR.press)}
                    </div>
                    <div class="ai-setup-corner">
                      <div class="ai-setup-corner-header">${CAR_SETUP_FIELDS.RR.title}</div>
                      ${fieldBlock('Spring', CAR_SETUP_FIELDS.RR.spring)}
                      ${fieldBlock('Ride H.', CAR_SETUP_FIELDS.RR.ride)}
                      ${fieldBlock('Bump Gap', CAR_SETUP_FIELDS.RR.bumpGap)} 
                      ${fieldBlock('Camber', CAR_SETUP_FIELDS.RR.camber)}
                      ${fieldBlock('Press.', CAR_SETUP_FIELDS.RR.press)}
                    </div>
                  </div>

                  <!-- NEW: DAMPERS ROW -->
                  <div style="margin-top:6px; font-weight:600; font-size:0.75rem; color:#888;">Dampers (Click/Comp - Rebound)</div>
                  <div class="ai-setup-car-row">
                    <div class="ai-setup-corner" style="background:#2a2a2a;">
                      <div class="ai-setup-corner-header">Front Dampers</div>
                      ${fieldBlock('LS Comp', CAR_SETUP_FIELDS.DAMPERS.f_lsc)}
                      ${fieldBlock('HS Comp', CAR_SETUP_FIELDS.DAMPERS.f_hsc)}
                      ${fieldBlock('LS Reb', CAR_SETUP_FIELDS.DAMPERS.f_lsr)}
                      ${fieldBlock('HS Reb', CAR_SETUP_FIELDS.DAMPERS.f_hsr)}
                    </div>
                    <div class="ai-setup-corner" style="background:#2a2a2a;">
                      <div class="ai-setup-corner-header">Rear Dampers</div>
                      ${fieldBlock('LS Comp', CAR_SETUP_FIELDS.DAMPERS.r_lsc)}
                      ${fieldBlock('HS Comp', CAR_SETUP_FIELDS.DAMPERS.r_hsc)}
                      ${fieldBlock('LS Reb', CAR_SETUP_FIELDS.DAMPERS.r_lsr)}
                      ${fieldBlock('HS Reb', CAR_SETUP_FIELDS.DAMPERS.r_hsr)}
                    </div>
                  </div>
                `;


            if (isEditable) {
                el.querySelectorAll('.ai-setup-input').forEach(inp => {
                    inp.addEventListener('change', onProposedInputChange);
                });
            }
        }

        // Add this new function to your JavaScript, for example,
        // right after the CAR_SETUP_FIELDS constant definition.

        function getDynamicExplanation(paramName, delta, symptom) {
            const isIncrease = delta > 0;
            const isDecrease = delta < 0;
            let explanation = "";

            switch (paramName) {
                case 'LF_SpringRate':
                case 'RF_SpringRate': {
                    const axle = paramName.includes('LF') ? 'front left' : 'front right';
                    if (isIncrease) {
                        explanation = `Increasing the ${axle} spring rate makes that corner stiffer. This enhances front responsiveness and reduces body roll, aiding turn-in. However, it can decrease mechanical grip by making the tire less compliant, often leading to **increased understeer** mid-corner, especially over bumps.`;
                    } else if (isDecrease) {
                        explanation = `Decreasing the ${axle} spring rate softens that corner. This typically boosts mechanical grip by allowing the tire to follow the surface better, which can help **reduce understeer**. The car might feel less immediate and exhibit more body roll, potentially impacting aerodynamic stability.`;
                    }
                    break;
                }
                case 'LR_SpringRate':
                case 'RR_SpringRate': {
                    const axle = paramName.includes('LR') ? 'rear left' : 'rear right';
                    if (isIncrease) {
                        explanation = `Increasing the ${axle} spring rate stiffens the rear of the car. This can improve rear responsiveness and control squat under acceleration, but generally reduces mechanical grip at the rear. This often results in **increased oversteer**, particularly on corner exit or under braking.`;
                    } else if (isDecrease) {
                        explanation = `Decreasing the ${axle} spring rate softens the rear. This typically increases mechanical grip and improves traction, making the car more stable and less prone to **oversteer**. However, it might lead to more body roll and squat, which could compromise aerodynamic balance.`;
                    }
                    break;
                }
                case 'LF_RideHeight':
                case 'RF_RideHeight': {
                    const axle = paramName.includes('LF') ? 'front left' : 'front right';
                    if (isIncrease) {
                        explanation = `Raising the ${axle} ride height increases ground clearance. This usually reduces front downforce and can lead to **increased understeer**. It can help avoid bottoming out on bumps or curbs but often compromises aerodynamic efficiency.`;
                    } else if (isDecrease) {
                        explanation = `Lowering the ${axle} ride height decreases ground clearance. This generally increases front downforce and lowers the center of gravity, improving stability and overall grip, thus potentially **reducing understeer**. Caution is needed to prevent bottoming out, which can cause sudden grip loss.`;
                    }
                    break;
                }
                case 'LR_RideHeight':
                case 'RR_RideHeight': {
                    const axle = paramName.includes('LR') ? 'rear left' : 'rear right';
                    if (isIncrease) {
                        explanation = `Raising the ${axle} ride height increases ground clearance at the rear. This typically reduces rear downforce, potentially leading to **increased oversteer**, and can make the car feel less stable at high speeds.`;
                    } else if (isDecrease) {
                        explanation = `Lowering the ${axle} ride height increases rear downforce, significantly improving rear grip, traction, and stability, thereby helping to **reduce oversteer**. It also lowers the center of gravity. Ensure sufficient clearance to prevent bottoming out.`;
                    }
                    break;
                }
                case 'LF_Camber':
                case 'RF_Camber':
                case 'LR_Camber':
                case 'RR_Camber': {
                    const axle = paramName.split('_')[0]; // LF, RF, LR, RR
                    const frontRear = paramName.includes('F') ? 'front' : 'rear';
                    if (isIncrease) { // Assuming "increase" means more negative camber (e.g., -2.0 to -2.5)
                        explanation = `Increasing negative camber on the ${axle} wheel angles the top of the tire inward. This optimizes the tire's contact patch during cornering (when the car rolls), improving lateral grip and potentially enhancing cornering speed. However, it can reduce straight-line braking/acceleration performance and accelerate inner tire wear. For the ${frontRear}, this generally improves cornering grip on that end.`;
                    } else if (isDecrease) { // Assuming "decrease" means less negative camber (e.g., -2.5 to -2.0 or closer to zero)
                        explanation = `Decreasing negative camber on the ${axle} wheel makes the tire flatter to the ground in a straight line. This increases the tire's contact patch during straight-line driving and braking, improving stability and braking/acceleration efficiency. This change might slightly reduce lateral grip during hard cornering, potentially causing the ${frontRear} end to lose grip earlier.`;
                    }
                    break;
                }
                case 'LF_StartingPressure':
                case 'RF_StartingPressure':
                case 'LR_StartingPressure':
                case 'RR_StartingPressure': {
                    const axle = paramName.split('_')[0]; // LF, RF, LR, RR
                    if (isIncrease) {
                        explanation = `Increasing the starting tire pressure on the ${axle} wheel stiffens the tire's sidewall, which can sharpen steering response and reduce overheating from excessive tire flex. However, it also reduces the tire's contact patch, which can decrease overall mechanical grip and make the car feel more 'nervous', prone to locking up under braking or spinning under acceleration.`;
                    } else if (isDecrease) {
                        explanation = `Decreasing the starting tire pressure on the ${axle} wheel enlarges the tire's contact patch, generally increasing mechanical grip and improving compliance over bumps. This can lead to better traction and stability. The trade-off might be a softer steering response and increased tire temperatures due to more sidewall flex, potentially leading to faster degradation.`;
                    }
                    break;
                }
                case 'ArbBlades_Front': {
                    if (isIncrease) { // More blades generally mean stiffer
                        explanation = `Stiffening the front anti-roll bar (ARB) reduces body roll at the front axle during cornering. This makes the front more responsive and can improve turn-in, but it also reduces mechanical grip at the front relative to the rear, which typically **increases mid-corner understeer**.`;
                    } else if (isDecrease) {
                        explanation = `Softening the front anti-roll bar (ARB) increases mechanical grip at the front during cornering by allowing more independent suspension movement. This can help **reduce understeer** and improve compliance over bumps, but might lead to increased body roll and a slightly less responsive front end.`;
                    }
                    break;
                }
                case 'RearArbBlades': {
                    if (isIncrease) { // More blades generally mean stiffer
                        explanation = `Stiffening the rear anti-roll bar (ARB) reduces body roll at the rear axle. This makes the rear of the car more responsive and can improve stability at high speed, but it also reduces mechanical grip at the rear relative to the front, which typically **increases mid-corner oversteer** and can make the car more 'snappy' on throttle lift-off.`;
                    } else if (isDecrease) {
                        explanation = `Softening the rear anti-roll bar (ARB) increases mechanical grip at the rear during cornering. This can help **reduce oversteer**, improve traction on corner exit, and make the car feel more planted. The trade-off can be increased body roll at the rear and potentially a less immediate response.`;
                    }
                    break;
                }
                case 'BrakePressureBias': {
                    if (isIncrease) { // More towards the front (higher percentage)
                        explanation = `Increasing brake bias to the front transfers more braking force to the front wheels. This typically enhances stability under heavy braking and reduces the risk of rear wheel lock-up or snap oversteer. However, it can lead to longer braking distances and can cause premature front wheel lock-up if set too high. This generally **promotes understeer under braking**.`;
                    } else if (isDecrease) { // More towards the rear (lower percentage)
                        explanation = `Decreasing brake bias towards the rear distributes more braking force to the rear wheels. This can shorten braking distances by better utilizing all four tires and improve trail braking capability. The risk is increased rear wheel lock-up, leading to instability or **oversteer under braking**, requiring a more delicate touch from the driver.`;
                    }
                    break;
                }
                case 'DiffPreload': {
                    if (isIncrease) {
                        explanation = `Increasing differential preload means the differential locks more aggressively on both acceleration and deceleration. This improves straight-line traction under power and can increase stability under braking. However, it resists wheel speed differences, which can cause significant **understeer on corner entry and mid-corner**, and increase tire scrubbing wear.`;
                    } else if (isDecrease) {
                        explanation = `Decreasing differential preload allows the wheels to spin more independently. This **reduces corner entry and mid-corner understeer**, making the car turn in more easily. The trade-off is often reduced traction on corner exit, as power may not be distributed as effectively to both wheels, potentially leading to wheelspin.`;
                    }
                    break;
                }
                case 'RearWingAngle': {
                    if (isIncrease) {
                        explanation = `Increasing rear wing angle generates more rear downforce. This significantly improves rear grip and high-speed stability, thereby **reducing oversteer** and allowing higher cornering speeds. The penalty is increased aerodynamic drag, which will reduce top speed on straights and increase fuel consumption.`;
                    } else if (isDecrease) {
                        explanation = `Decreasing rear wing angle reduces rear downforce. This lowers aerodynamic drag, improving top speed on straights and reducing fuel consumption. However, it will also reduce rear grip and stability, making the car more prone to **oversteer**, especially in high-speed corners.`;
                    }
                    break;
                }
                case 'FuelLevel_Rear': { // Assuming this parameter refers to the fuel load for a run.
                    if (isIncrease) {
                        explanation = `Adding fuel increases the overall vehicle weight. A heavier car generally means slower lap times due to increased inertia (harder to accelerate, longer to brake), higher tire wear, and more demand on the suspension components. However, it allows for longer stints.`;
                    } else if (isDecrease) {
                        explanation = `Reducing fuel decreases the overall vehicle weight. A lighter car is typically faster, with improved acceleration, braking, reduced tire wear, and lower fuel consumption. The primary limitation is the shorter range before needing to refuel.`;
                    }
                    break;
                }
                // ... existing cases ...

                // --- NEW DAMPER EXPLANATIONS ---
                case 'Front_LSC':
                case 'Rear_LSC':
                    if (isIncrease) {
                        explanation = `Increasing Low Speed Compression (LSC) slows down the suspension compression during driver inputs (braking, turning). This stabilizes the platform, reduces pitch/roll, and sharpens response, but reduces mechanical grip on uneven surfaces.`;
                    } else {
                        explanation = `Decreasing Low Speed Compression (LSC) allows faster weight transfer. This improves compliance and mechanical grip on bumpy tracks but can make the car feel lazy, roll too much, or dive excessively under braking.`;
                    }
                    break;

                case 'Front_LSR':
                case 'Rear_LSR':
                    if (isIncrease) {
                        explanation = `Increasing Low Speed Rebound (LSR) slows the extension of the spring after compression. This helps settle the car after bumps and keeps the platform stable, but too much can cause "jacking down" (suspension stays compressed) and loss of grip.`;
                    } else {
                        explanation = `Decreasing Low Speed Rebound (LSR) allows the wheel to return to the road surface faster after a bump. This improves traction on undulating surfaces but can make the car feel bouncy, floaty, or unstable during weight transfer.`;
                    }
                    break;

                case 'Front_HSC':
                case 'Rear_HSC':
                    if (isIncrease) {
                        explanation = `Increasing High Speed Compression (HSC) helps support the car during sharp impacts like curbs or harsh bumps. It prevents bottoming out but can make the ride harsh and cause the tires to skip or lose contact on sharp edges.`;
                    } else {
                        explanation = `Decreasing High Speed Compression (HSC) allows the suspension to absorb sharp bumps and curbs more easily. This improves grip over curbs but increases the risk of bottoming out the chassis on the ground.`;
                    }
                    break;

                case 'Front_HSR':
                case 'Rear_HSR':
                    if (isIncrease) {
                        explanation = `Increasing High Speed Rebound (HSR) controls the spring energy release after a large compression (big bump/curb). It prevents the car from being launched upwards but can delay the tire returning to the track surface.`;
                    } else {
                        explanation = `Decreasing High Speed Rebound (HSR) allows the tire to reconnect with the track surface quickly after a large bump. This improves grip recovery but can make the car unstable or bouncy over curbs if the spring extends too violently.`;
                    }
                    break;


                // Add more setup parameters and their explanations as needed.
                default:
                    explanation = `The dynamic implications for ${paramName} are complex and depend on specific car characteristics and driving style. Consult expert resources for detailed effects.`;
                    break;
            }
            return explanation;
        }

        // --- UPDATED: Generate Damper Setup Changes based on Velocity Histograms ---
        function getDamperRecommendations(lap) {
            const recs = [];
            if (!lap || !lap.svStats) return recs;

            // -- Tuning Thresholds --
            const LS_BALANCE_TOLERANCE = 0.05; // 5% difference allowed between LS Bump/Reb time
            const HS_ACTIVITY_THRESHOLD = 0.02; // If > 2% of lap is High Speed, check stiffness
            const HS_VELOCITY_LIMIT = 0.150; // 150mm/s. If we exceed this, HS is likely too soft.

            const axles = {
                Front: ['LF', 'RF'],
                Rear: ['LR', 'RR']
            };

            for (const [axle, wheels] of Object.entries(axles)) {
                let stats = {
                    lsBumpRatio: 0, lsRebRatio: 0,
                    hsBumpRatio: 0, hsRebRatio: 0,
                    maxBumpVel: 0, maxRebVel: 0
                };
                let count = 0;

                // Average the stats across the axle (Left + Right)
                wheels.forEach(w => {
                    if (lap.svStats[w]) {
                        const s = lap.svStats[w];
                        stats.lsBumpRatio += s.lsBumpRatio;
                        stats.lsRebRatio += s.lsRebRatio;
                        stats.hsBumpRatio += s.hsBumpRatio;
                        stats.hsRebRatio += s.hsRebRatio;
                        // Take the most extreme velocity seen on the axle
                        stats.maxBumpVel = Math.min(stats.maxBumpVel, s.maxBumpVel);
                        stats.maxRebVel = Math.max(stats.maxRebVel, s.maxRebVel);
                        count++;
                    }
                });

                if (count === 0) continue;
                // Normalize ratios
                stats.lsBumpRatio /= count;
                stats.lsRebRatio /= count;
                stats.hsBumpRatio /= count;
                stats.hsRebRatio /= count;

                // --- 1. LOW SPEED ANALYSIS (Handling Balance) ---
                // Compare time spent in Bump vs Rebound in the 0-40mm/s range.
                // ideally, this is roughly symmetric (50/50 split of the active time).

                const lsTotal = stats.lsBumpRatio + stats.lsRebRatio;
                if (lsTotal > 0) {
                    const lsRebShare = stats.lsRebRatio / lsTotal; // % of LS time spent in Rebound

                    if (lsRebShare > (0.5 + LS_BALANCE_TOLERANCE)) {
                        recs.push({
                            param: `${axle}_LSR`,
                            delta: 1,
                            explanation: `<strong>${axle} LS Rebound Bias:</strong> In the low-speed range (0-40mm/s), the suspension spends ${(lsRebShare * 100).toFixed(0)}% of time extending. It is struggling to settle down. Stiffen <strong>Low Speed Rebound</strong>.`
                        });
                    } else if (lsRebShare < (0.5 - LS_BALANCE_TOLERANCE)) {
                        recs.push({
                            param: `${axle}_LSR`,
                            delta: -1,
                            explanation: `<strong>${axle} LS Bump Bias:</strong> In the low-speed range, the suspension spends mostly time compressing. This implies "packing down". Soften <strong>Low Speed Rebound</strong> to let the wheel recover.`
                        });
                    }
                }

                // --- 2. HIGH SPEED ANALYSIS (Bump Absorption) ---
                // Based on peak velocities. 

                // Check for "Blowing Through" HS Compression
                // If we hit very high bump velocities (<-150mm/s), the damper isn't slowing the wheel enough on curbs.
                if (stats.maxBumpVel < -HS_VELOCITY_LIMIT) {
                    recs.push({
                        param: `${axle}_HSC`,
                        delta: 1,
                        explanation: `<strong>${axle} Bottoming Risk:</strong> Peak bump velocity hit ${(stats.maxBumpVel * 1000).toFixed(0)} mm/s. The damper is too soft over harsh bumps/curbs. Stiffen <strong>High Speed Compression</strong> to protect the chassis.`
                    });
                }

                // Check for "Kick" / HS Rebound
                // If we hit very high rebound velocities (>150mm/s), the spring is firing the car up too hard after a bump.
                if (stats.maxRebVel > HS_VELOCITY_LIMIT) {
                    recs.push({
                        param: `${axle}_HSR`,
                        delta: 1,
                        explanation: `<strong>${axle} Bouncy/Kick:</strong> Peak rebound velocity hit ${(stats.maxRebVel * 1000).toFixed(0)} mm/s. The car is being launched up after bumps. Stiffen <strong>High Speed Rebound</strong> to control the spring energy.`
                    });
                }

                // Check for "Lock out" (Too Stiff High Speed)
                // If HS activity is non-existent on a track that is known to be bumpy (this is a heuristic),
                // or if sigma is very low, we might be too stiff.
                // Here we look for VERY low usage of high speed travel.
                if (stats.hsBumpRatio < 0.005 && stats.maxBumpVel > -0.050) {
                    recs.push({
                        param: `${axle}_HSC`,
                        delta: -1,
                        explanation: `<strong>${axle} HS Too Stiff:</strong> The suspension almost never enters high-speed bump (peak only ${(stats.maxBumpVel * 1000).toFixed(0)} mm/s). If the track is bumpy, you are likely skipping over the surface. Soften <strong>High Speed Compression</strong>.`
                    });
                }
            }

            return recs;
        }


        // Add this function after CAR_SETUP_FIELDS and numericOrNull
        function getAutoRecommendations(symptom) {
            const recs = []; // Now an array of objects: { param, delta, explanation }
            // These are general, small-step recommendations.
            // Real setup changes are highly context-dependent.
            // Magnitudes are arbitrary and should be tuned for the specific car.
            const smallChangeSpring = 0.5; // kg/mm or N/mm, depends on unit
            const smallChangeARB = 1;     // blades or clicks
            const smallChangeRh = 0.001;  // meters or inches (adjust unit for your game/sim)
            const smallChangeCamber = 0.1; // degrees
            const smallChangePressure = 0.5; // psi or bar
            const smallChangeBias = 0.5; // %
            const smallChangeWing = 1; // degrees or steps
            const smallChangeDiff = 1; // % or clicks

            switch (symptom) {
                case 'entry_understeer':
                    // Car pushes wide when turning in
                    recs.push({
                        param: 'LF_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer front springs (LF/RF) increase mechanical grip during turn-in by allowing more suspension compression, helping the car to rotate more easily and reduce initial understeer. This prioritizes mechanical compliance over immediate responsiveness."
                    });
                    recs.push({
                        param: 'RF_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer front springs (LF/RF) increase mechanical grip during turn-in by allowing more suspension compression, helping the car to rotate more easily and reduce initial understeer. This prioritizes mechanical compliance over immediate responsiveness."
                    });
                    recs.push({
                        param: 'ArbBlades_Front', delta: -smallChangeARB,
                        explanation: "A softer front anti-roll bar (ARB) reduces load transfer across the front axle, promoting more independent wheel movement. This increases front mechanical grip, allowing the car to bite harder and improve turn-in, countering understeer. It may slightly increase body roll."
                    });
                    recs.push({
                        param: 'LF_RideHeight', delta: -smallChangeRh,
                        explanation: "Lowering front ride height (LF/RF) typically increases front downforce by optimizing airflow under the car. More front downforce pushes the front tires harder into the track, increasing grip and improving turn-in, thereby reducing understeer. This must be balanced to avoid excessive scraping."
                    });
                    recs.push({
                        param: 'RF_RideHeight', delta: -smallChangeRh,
                        explanation: "Lowering front ride height (LF/RF) typically increases front downforce by optimizing airflow under the car. More front downforce pushes the front tires harder into the track, increasing grip and improving turn-in, thereby reducing understeer. This must be balanced to avoid excessive scraping."
                    });
                    recs.push({
                        param: 'BrakePressureBias', delta: -smallChangeBias,
                        explanation: "Shifting brake bias slightly rearward transfers more braking force to the rear wheels. This can encourage the rear of the car to rotate more under trail-braking, aiding turn-in and reducing entry understeer. Care must be taken to avoid rear lock-up."
                    });
                    recs.push({
                        param: 'DiffPreload', delta: -smallChangeDiff,
                        explanation: "Reducing differential preload allows the rear wheels to turn at more independent speeds during corner entry. This minimizes resistance to rotation, making the car more agile and reducing the tendency for understeer as you turn into a corner."
                    });
                    break;

                case 'mid_understeer':
                    // Car pushes wide through the middle of the corner
                    recs.push({
                        param: 'LF_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer front springs (LF/RF) enhance mechanical grip through the mid-corner by allowing the front tires to better conform to the track surface, improving traction and reducing the car's tendency to push wide."
                    });
                    recs.push({
                        param: 'RF_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer front springs (LF/RF) enhance mechanical grip through the mid-corner by allowing the front tires to better conform to the track surface, improving traction and reducing the car's tendency to push wide."
                    });
                    recs.push({
                        param: 'ArbBlades_Front', delta: -smallChangeARB,
                        explanation: "A softer front ARB reduces front roll stiffness, allowing the outside front tire to maintain better contact patch under lateral load. This increases mid-corner front grip and reduces understeer."
                    });
                    recs.push({
                        param: 'RearArbBlades', delta: smallChangeARB,
                        explanation: "A stiffer rear anti-roll bar (ARB) increases roll stiffness at the rear, causing the inner rear wheel to lift more or have less load. This reduces effective rear grip relative to the front, which can help the car rotate more and reduce mid-corner understeer."
                    });
                    recs.push({
                        param: 'LR_RideHeight', delta: -smallChangeRh,
                        explanation: "Lowering rear ride height (LR/RR), while maintaining front ride height, increases the car's rake angle (front lower than rear). This often increases overall downforce and shifts the aerodynamic balance rearward, boosting rear grip and helping to rotate the car more easily, combating mid-corner understeer."
                    });
                    recs.push({
                        param: 'RR_RideHeight', delta: -smallChangeRh,
                        explanation: "Lowering rear ride height (LR/RR), while maintaining front ride height, increases the car's rake angle (front lower than rear). This often increases overall downforce and shifts the aerodynamic balance rearward, boosting rear grip and helping to rotate the car more easily, combating mid-corner understeer."
                    });
                    recs.push({
                        param: 'RearWingAngle', delta: smallChangeWing,
                        explanation: "Increasing rear wing angle adds more rear aerodynamic downforce. This plants the rear of the car more firmly, enhancing grip and stability. While it primarily reduces oversteer, for a mid-corner understeer scenario, it can allow the driver to carry more speed with greater confidence, effectively giving more overall grip which may then translate to better rotation."
                    });
                    break;

                case 'exit_understeer':
                    // Car pushes wide on corner exit under power
                    recs.push({
                        param: 'LR_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer rear springs (LR/RR) can help control rear squat under acceleration. By reducing excessive weight transfer to the rear, it can maintain a more balanced platform and improve turn-out responsiveness, countering exit understeer."
                    });
                    recs.push({
                        param: 'RR_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer rear springs (LR/RR) can help control rear squat under acceleration. By reducing excessive weight transfer to the rear, it can maintain a more balanced platform and improve turn-out responsiveness, countering exit understeer."
                    });
                    recs.push({
                        param: 'LF_Camber', delta: -smallChangeCamber, // Less negative camber
                        explanation: "Reducing negative camber at the front (LF/RF) increases the tire's contact patch during acceleration when the steering is straightening. This provides more front mechanical grip on exit, helping the car track straight and reducing exit understeer under power."
                    });
                    recs.push({
                        param: 'RF_Camber', delta: -smallChangeCamber, // Less negative camber
                        explanation: "Reducing negative camber at the front (LF/RF) increases the tire's contact patch during acceleration when the steering is straightening. This provides more front mechanical grip on exit, helping the car track straight and reducing exit understeer under power."
                    });
                    recs.push({
                        param: 'RearArbBlades', delta: smallChangeARB,
                        explanation: "A stiffer rear ARB increases load transfer to the outside rear wheel, potentially making the car more eager to rotate on power. This can help overcome exit understeer by making the rear less planted and encouraging rotation."
                    });
                    recs.push({
                        param: 'DiffPreload', delta: smallChangeDiff,
                        explanation: "Increasing differential preload ensures both rear wheels receive power more equally during corner exit. This can improve traction and stability under acceleration, reducing wheelspin and helping to drive the car out of the corner more effectively, countering understeer."
                    });
                    break;

                case 'entry_oversteer':
                    // Rear is loose when turning in, especially under braking
                    recs.push({
                        param: 'LF_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer front springs (LF/RF) reduce front dive under braking and make the front end more responsive. This can stabilize the car's platform, helping to manage weight transfer and reduce excessive rotation from the rear during corner entry, thus reducing oversteer."
                    });
                    recs.push({
                        param: 'RF_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer front springs (LF/RF) reduce front dive under braking and make the front end more responsive. This can stabilize the car's platform, helping to manage weight transfer and reduce excessive rotation from the rear during corner entry, thus reducing oversteer."
                    });
                    recs.push({
                        param: 'LR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) increase mechanical grip at the rear during braking and turn-in. This allows the rear tires to absorb bumps and maintain better contact, making the rear more stable and less prone to oversteer."
                    });
                    recs.push({
                        param: 'RR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) increase mechanical grip at the rear during braking and turn-in. This allows the rear tires to absorb bumps and maintain better contact, making the rear more stable and less prone to oversteer."
                    });
                    recs.push({
                        param: 'RearArbBlades', delta: -smallChangeARB,
                        explanation: "A softer rear anti-roll bar (ARB) reduces load transfer across the rear axle, increasing effective rear mechanical grip. This helps to stabilize the rear of the car during corner entry and under braking, reducing oversteer."
                    });
                    recs.push({
                        param: 'RearWingAngle', delta: smallChangeWing,
                        explanation: "Increasing rear wing angle generates more rear aerodynamic downforce. This presses the rear tires more firmly onto the track, significantly increasing rear grip and stability, especially at higher speeds, which directly combats oversteer during corner entry."
                    });
                    recs.push({
                        param: 'BrakePressureBias', delta: smallChangeBias,
                        explanation: "Shifting brake bias slightly forward transfers more braking force to the front wheels. This reduces the risk of rear wheel lock-up and sudden rear instability during braking and turn-in, making the car more stable and less prone to entry oversteer."
                    });
                    recs.push({
                        param: 'DiffPreload', delta: smallChangeDiff,
                        explanation: "Increasing differential preload can stabilize the rear under braking by ensuring both rear wheels decelerate more in unison. This can reduce sudden rotation and help control entry oversteer, though it might impact mid-corner turn-in."
                    });
                    break;

                case 'mid_oversteer':
                    // Rear is loose through the middle of the corner
                    recs.push({
                        param: 'LF_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer front springs (LF/RF) can help balance the car's roll stiffness distribution. By reducing excessive front grip relative to the rear, it subtly shifts the balance, potentially reducing the tendency for mid-corner oversteer."
                    });
                    recs.push({
                        param: 'RF_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer front springs (LF/RF) can help balance the car's roll stiffness distribution. By reducing excessive front grip relative to the rear, it subtly shifts the balance, potentially reducing the tendency for mid-corner oversteer."
                    });
                    recs.push({
                        param: 'LR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) increase mechanical grip at the rear, allowing the tires to better maintain contact with the road surface through the corner. This directly boosts rear traction and stability, significantly reducing mid-corner oversteer."
                    });
                    recs.push({
                        param: 'RR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) increase mechanical grip at the rear, allowing the tires to better maintain contact with the road surface through the corner. This directly boosts rear traction and stability, significantly reducing mid-corner oversteer."
                    });
                    recs.push({
                        param: 'ArbBlades_Front', delta: smallChangeARB,
                        explanation: "A stiffer front anti-roll bar (ARB) increases front roll stiffness, which can reduce effective front mechanical grip. This shifts the overall grip balance slightly rearward, making the front less dominant and helping to reduce mid-corner oversteer."
                    });
                    recs.push({
                        param: 'RearArbBlades', delta: -smallChangeARB,
                        explanation: "A softer rear ARB reduces rear roll stiffness, allowing the rear tires to maintain better contact with the road under lateral load. This directly increases rear mechanical grip, enhancing stability and significantly reducing mid-corner oversteer."
                    });
                    recs.push({
                        param: 'RearWingAngle', delta: smallChangeWing,
                        explanation: "Increasing rear wing angle adds more rear aerodynamic downforce. This plants the rear of the car more firmly, providing a direct increase in rear grip and stability, which is highly effective in combating mid-corner oversteer, especially in high-speed corners."
                    });
                    recs.push({
                        param: 'LF_Camber', delta: smallChangeCamber, // More negative front camber
                        explanation: "Increasing negative front camber (LF/RF) optimizes the front tire's contact patch during cornering. This improves front lateral grip, allowing the front to bite harder and reducing the tendency for the rear to slide out (mid-corner oversteer)."
                    });
                    recs.push({
                        param: 'RF_Camber', delta: smallChangeCamber, // More negative front camber
                        explanation: "Increasing negative front camber (LF/RF) optimizes the front tire's contact patch during cornering. This improves front lateral grip, allowing the front to bite harder and reducing the tendency for the rear to slide out (mid-corner oversteer)."
                    });
                    break;

                case 'exit_oversteer':
                    // Rear is loose on corner exit under power
                    recs.push({
                        param: 'LR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) improve mechanical grip and traction on corner exit by allowing the rear tires to better absorb the forces of acceleration and maintain contact. This helps the car put power down more effectively and reduces power-on oversteer."
                    });
                    recs.push({
                        param: 'RR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) improve mechanical grip and traction on corner exit by allowing the rear tires to better absorb the forces of acceleration and maintain contact. This helps the car put power down more effectively and reduces power-on oversteer."
                    });
                    recs.push({
                        param: 'RearArbBlades', delta: -smallChangeARB,
                        explanation: "A softer rear anti-roll bar (ARB) increases rear mechanical grip, especially under acceleration, by allowing more independent suspension movement. This makes the rear of the car more stable and less prone to break traction on corner exit, reducing power-on oversteer."
                    });
                    recs.push({
                        param: 'DiffPreload', delta: -smallChangeDiff,
                        explanation: "Reducing differential preload allows for more wheel speed difference between the rear tires. This can reduce the sudden 'snap' oversteer often experienced on power application by making the power delivery smoother and less aggressive to the outside wheel."
                    });
                    recs.push({
                        param: 'RearWingAngle', delta: smallChangeWing,
                        explanation: "Increasing rear wing angle generates more rear aerodynamic downforce. This directly increases rear grip, particularly at higher speeds, which is crucial for stability and traction when accelerating out of high-speed corners, effectively combating exit oversteer."
                    });
                    recs.push({
                        param: 'LR_StartingPressure', delta: smallChangePressure, // Slightly higher to reduce flex, but not too much
                        explanation: "Slightly increasing rear tire pressure (LR/RR) can sometimes improve power delivery by reducing tire flex. However, this is a delicate balance; too much can reduce the contact patch and worsen traction. Start with small adjustments and monitor behavior."
                    });
                    recs.push({
                        param: 'RR_StartingPressure', delta: smallChangePressure,
                        explanation: "Slightly increasing rear tire pressure (LR/RR) can sometimes improve power delivery by reducing tire flex. However, this is a delicate balance; too much can reduce the contact patch and worsen traction. Start with small adjustments and monitor behavior."
                    });
                    break;

                case 'traction':
                    // Poor traction off corners (wheelspin)
                    recs.push({
                        param: 'LR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) improve mechanical grip, allowing the rear tires to compress more and maintain better contact with the track under acceleration. This directly increases traction and reduces wheelspin on corner exit."
                    });
                    recs.push({
                        param: 'RR_SpringRate', delta: -smallChangeSpring,
                        explanation: "Softer rear springs (LR/RR) improve mechanical grip, allowing the rear tires to compress more and maintain better contact with the track under acceleration. This directly increases traction and reduces wheelspin on corner exit."
                    });
                    recs.push({
                        param: 'RearArbBlades', delta: -smallChangeARB,
                        explanation: "A softer rear anti-roll bar (ARB) increases rear mechanical grip and compliance, especially under acceleration. This allows the rear wheels to work more independently, improving power delivery and reducing wheelspin."
                    });
                    recs.push({
                        param: 'LR_RideHeight', delta: -smallChangeRh,
                        explanation: "Lowering rear ride height (LR/RR) increases the car's rake angle (front lower than rear), optimizing underfloor aerodynamics for more overall downforce and a rearward aero balance. This increases rear grip, directly enhancing traction."
                    });
                    recs.push({
                        param: 'RR_RideHeight', delta: -smallChangeRh,
                        explanation: "Lowering rear ride height (LR/RR) increases the car's rake angle (front lower than rear), optimizing underfloor aerodynamics for more overall downforce and a rearward aero balance. This increases rear grip, directly enhancing traction."
                    });
                    recs.push({
                        param: 'DiffPreload', delta: smallChangeDiff,
                        explanation: "Increasing differential preload ensures both rear wheels receive power more equally, especially when one wheel might otherwise lose traction. This can significantly improve straight-line acceleration and overall traction on corner exit by more effectively distributing torque."
                    });
                    recs.push({
                        param: 'RearWingAngle', delta: smallChangeWing,
                        explanation: "Increasing rear wing angle adds more rear aerodynamic downforce. This plants the rear of the car more firmly, providing a direct and significant increase in rear grip and traction, especially in higher speed corners."
                    });
                    break;

                case 'brake_instability':
                    // Car is unstable under braking
                    recs.push({
                        param: 'BrakePressureBias', delta: smallChangeBias,
                        explanation: "Shifting brake bias slightly forward puts more braking force on the front wheels. This helps to stabilize the rear of the car under heavy braking, reducing the likelihood of rear wheel lock-up and sudden instability or oversteer."
                    });
                    recs.push({
                        param: 'LR_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer rear springs (LR/RR) help control the car's pitch and squat under braking. By reducing excessive rear dive, they maintain a more stable platform, making the car less susceptible to instability and twitchiness under braking."
                    });
                    recs.push({
                        param: 'RR_SpringRate', delta: smallChangeSpring,
                        explanation: "Stiffer rear springs (LR/RR) help control the car's pitch and squat under braking. By reducing excessive rear dive, they maintain a more stable platform, making the car less susceptible to instability and twitchiness under braking."
                    });
                    recs.push({
                        param: 'LF_Camber', delta: smallChangeCamber, // More negative front camber
                        explanation: "Increasing negative front camber (LF/RF) can improve the front tire's contact patch during the lateral loads often associated with braking into a corner. This provides better overall front grip for combined braking and turning, enhancing stability."
                    });
                    recs.push({
                        param: 'RF_Camber', delta: smallChangeCamber, // More negative front camber
                        explanation: "Increasing negative front camber (LF/RF) can improve the front tire's contact patch during the lateral loads often associated with braking into a corner. This provides better overall front grip for combined braking and turning, enhancing stability."
                    });
                    recs.push({
                        param: 'RearWingAngle', delta: smallChangeWing,
                        explanation: "Increasing rear wing angle provides more rear downforce. This enhances rear grip, which is crucial for stability under heavy braking, reducing the tendency for the rear to become light or unstable."
                    });
                    break;

                // Add more setup parameters and their explanations as needed.
                default:
                    // No specific recommendations for this symptom, or a default message
                    break;
            }
            return recs;
        }


        function buildCornerDefinitions(refLap) {
            const d = refLap.data.distance;
            const v = refLap.data.speed;
            const brk = refLap.data.brake;
            const steer = refLap.data.steering;

            const CORNERS = [];
            const BRAKE_THRESHOLD = 10;   // %
            const STEER_IN_THRESH = 0.05; // rad
            const MIN_SPEED_DROP = 10;   // km/h

            let i = 0, cornerId = 1;
            while (i < d.length - 1) {
                // find first significant brake
                while (i < d.length && brk[i] < BRAKE_THRESHOLD) i++;
                if (i >= d.length) break;
                const brakeStartIdx = i;

                // find point where steering commits
                while (i < d.length && Math.abs(steer[i]) < STEER_IN_THRESH) i++;
                const turnInIdx = i < d.length ? i : brakeStartIdx;

                // find local min speed after turn‑in
                let minIdx = turnInIdx;
                while (i < d.length && brk[i] > BRAKE_THRESHOLD / 2) {
                    if (v[i] < v[minIdx]) minIdx = i;
                    i++;
                }
                const apexIdx = minIdx;

                // require some real cornering
                if (v[brakeStartIdx] - v[apexIdx] < MIN_SPEED_DROP) continue;

                // advance a bit to “exit” (when throttle > 60% and steering mostly straight)
                while (i < d.length &&
                    (refLap.data.throttle[i] < 60 || Math.abs(steer[i]) > STEER_IN_THRESH / 2)) i++;
                const exitIdx = Math.min(i, d.length - 1);

                CORNERS.push({
                    id: cornerId++,
                    dStart: d[brakeStartIdx],
                    dTurnIn: d[turnInIdx],
                    dApex: d[apexIdx],
                    dEnd: d[exitIdx]
                });
            }

            return CORNERS;
        }


        function computeCornerDrivingMetrics(lap, corner) {
            const d = lap.data.distance;
            const t = lap.data.time;
            const v = lap.data.speed;
            const brk = lap.data.brake;
            const thr = lap.data.throttle;
            const steer = lap.data.steering;
            const abs = lap.data.brakeABSactive || [];

            // helper to find first index where distance >= X
            const idxFromDist = dist =>
                d.findIndex(x => x >= dist);

            const iStart = idxFromDist(corner.dStart);
            const iTurnIn = idxFromDist(corner.dTurnIn);
            const iApex = idxFromDist(corner.dApex);
            const iEnd = idxFromDist(corner.dEnd);

            if (iStart < 0 || iEnd < 0 || iEnd <= iStart) return null;

            // Brake point (first >10% from before corner)
            let brakePointDist = null;
            for (let i = iStart; i <= iEnd; i++) {
                if (brk[i] > 10) { brakePointDist = d[i]; break; }
            }

            // “Brake shape” – simple descriptors
            let brakePeak = 0;
            let brakeTime10to90 = 0;
            let t10 = null, t90 = null;
            for (let i = iStart; i <= iEnd; i++) {
                const b = brk[i];
                if (b > brakePeak) brakePeak = b;
                if (b >= 10 && t10 === null) t10 = t[i];
                if (b >= 90 && t90 === null) t90 = t[i];
            }
            if (t10 !== null && t90 !== null && t90 > t10) {
                brakeTime10to90 = t90 - t10;
            }

            // Turn‑in distance (first steering > threshold)
            const STEER_IN_THRESH = 0.05;
            let turnInDist = null;
            for (let i = iStart; i <= iEnd; i++) {
                if (Math.abs(steer[i]) > STEER_IN_THRESH) { turnInDist = d[i]; break; }
            }

            // Apex min speed
            let minSpeed = Infinity;
            let minSpeedDist = null;
            for (let i = iStart; i <= iEnd; i++) {
                if (v[i] < minSpeed) {
                    minSpeed = v[i];
                    minSpeedDist = d[i];
                }
            }

            // First time to sustained full throttle (e.g. >95% for 0.5s)
            let fullThrDist = null;
            const FULL = 95;
            const HOLD = 0.5;
            for (let i = iApex; i < iEnd; i++) {
                if (thr[i] >= FULL) {
                    let j = i;
                    const tStart = t[i];
                    while (j < iEnd && thr[j] >= FULL && (t[j] - tStart) < HOLD) j++;
                    if (j < iEnd && (t[j] - tStart) >= HOLD) {
                        fullThrDist = d[i];
                        break;
                    }
                }
            }

            // ABS time in corner
            let absTime = 0;
            for (let i = iStart; i < iEnd; i++) {
                if (abs[i] > 0) absTime += (t[i + 1] - t[i]);
            }

            return {
                brakePointDist,
                brakePeak,
                brakeTime10to90,
                turnInDist,
                minSpeed,
                minSpeedDist,
                fullThrDist,
                absTime,
            };
        }



    </script>
    <!-- AI Setup Assistant Modal -->
    <div id="setup-modal"
         style="position:fixed; inset:0; background:rgba(0,0,0,0.6);
            display:none; align-items:center; justify-content:center; z-index:9999;">
        <div class="ai-setup-modal">
            <div class="ai-setup-modal-header">
                <h3>AI Setup Assistant</h3>
                <div style="display:flex; gap:6px; align-items:center;">
                    <button id="ai-setup-fullscreen-toggle"
                            class="ai-setup-close-btn"
                            title="Toggle fullscreen"
                            style="font-size:0.9rem;">
                        ⛶
                    </button>
                    <button id="close-setup-modal" class="ai-setup-close-btn">×</button>
                </div>
            </div>


            <div class="ai-setup-modal-body">
                <!-- Column 1: Baseline Setup (UNCHANGED) -->
                <div class="ai-setup-column">
                    <div class="ai-setup-column-header">
                        <div>
                            <div style="font-weight:600;">Baseline Setup (from training CSV)</div>
                            <div id="ai-setup-baseline-meta" class="ai-setup-meta"></div>
                        </div>
                        <div id="ai-setup-variant-wrapper" style="display:none;">
                            <label style="font-size:0.75rem; color:#ccc;">
                                Setup:
                                <select id="ai-setup-variant-select"
                                        style="margin-left:4px; padding:2px 4px; border-radius:4px; border:1px solid #444; background:#222; color:#eee; font-size:0.75rem;">
                                </select>
                            </label>
                        </div>
                    </div>

                    <div id="ai-setup-car-baseline" class="ai-setup-car-grid">
                        <!-- filled by JS -->
                    </div>
                </div>

                <!-- Column 2: Proposed Changes (INTERACTIVE CAR GRID - UI REMAINS THE SAME) -->
                <div class="ai-setup-column">
                    <div class="ai-setup-column-header">
                        <div>
                            <div style="font-weight:600;">Proposed Changes</div>
                            <div class="ai-setup-meta" style="font-size:0.75rem;">
                                Click a knob/value to adjust; deltas vs baseline are shown in orange.
                            </div>
                        </div>
                    </div>

                    <div id="ai-setup-car-proposed" class="ai-setup-car-grid">
                        <!-- filled by JS -->
                    </div>
                    <!-- IMPORTANT: The ai-setup-controls and setup-result divs are removed from THIS column -->
                </div>

                <!-- NEW Column 3: Driving Symptom and Prediction Result -->
                <div class="ai-setup-column ai-setup-prediction-column">
                    <!-- Added a new class for styling -->
                    <div class="ai-setup-column-header">
                        <div>
                            <div style="font-weight:600;">Prediction & Recommendation</div>
                            <div class="ai-setup-meta" style="font-size:0.75rem;">
                                Analyze how proposed changes affect the car's behavior.
                            </div>
                        </div>
                    </div>

                    <div id="ai-load-meta"
                         style="font-size:0.74rem; color:#aaa; margin-bottom:4px; line-height:1.3;">
                    </div>

                    <button id="ai-load-toggle" type="button">
                        Show braking & cornering load tables
                    </button>

                    <div id="ai-load-details" class="collapsed">
                        <div id="ai-load-braking"
                             style="font-size:0.74rem; color:#ccc; margin-bottom:4px;">
                        </div>
                        <div id="ai-load-cornering"
                             style="font-size:0.74rem; color:#ccc; margin-bottom:4px;">
                        </div>
                    </div>

                    <!-- Relocated and cleaned up controls for Symptom and Run button -->
                    <div class="ai-setup-controls" id="ai-symptom-controls">
                        <!-- Added an ID for easy JS targeting -->
                        <div class="ai-setup-controls-row">
                            <label>
                                Driving Symptom to Address:
                                <select id="ai-symptom">
                                    <option value="entry_understeer">Understeer on entry</option>
                                    <option value="mid_understeer">Mid‑corner understeer</option>
                                    <option value="exit_understeer">Exit understeer</option>
                                    <option value="entry_oversteer">Oversteer on entry</option>
                                    <option value="mid_oversteer">Mid‑corner oversteer</option>
                                    <option value="exit_oversteer">Exit oversteer</option>
                                    <option value="traction">Poor traction / wheelspin</option>
                                    <option value="brake_instability">Unstable under braking</option>
                                </select>
                            </label>
                        </div>
                        <!-- NEW: Auto-Recommend and Reset Proposed Buttons -->
                        <button id="auto-recommend-ai" class="ai-setup-run-btn" style="background-color: #ffc107; color: #333; margin-top:10px;">
                            Auto-Recommend Fixes (Symptom)
                        </button>
                        <button id="auto-recommend-fastest" class="ai-setup-run-btn" style="background-color: #28a745; margin-top:5px;">
                            Auto-Recommend Fastest Setup
                        </button>
                        <button id="reset-proposed-ai" class="ai-setup-run-btn" style="background-color: #6c757d; margin-top:5px;">
                            Reset Proposed
                        </button>
                        <button id="run-setup-ai" class="ai-setup-run-btn" style="margin-top:10px;">
                            Analyze Proposed Changes
                        </button>
                    </div>
                    <!-- Relocated result display -->
                    <div id="setup-result" class="ai-setup-result"></div>
                </div>
            </div> <!-- end .ai-setup-modal-body -->
        </div>   <!-- end .ai-setup-modal -->
    </div>      <!-- end #setup-modal -->
    <!-- Pit Card Modal -->
    <div id="pit-card-modal"
         style="position:fixed; inset:0; background:rgba(0,0,0,0.6);
            display:none; align-items:center; justify-content:center; z-index:9998;">
        <div class="pit-card-content">
            <!-- Wrapper for the actual pit card -->
            <button id="close-pit-card-modal" class="ai-setup-close-btn" style="position: absolute; top: 10px; right: 10px; z-index: 10;">×</button>
            <!-- The actual pit card content starts here -->
            <div class="pit-card" role="region" aria-label="1 hour setup sprint pit card">
                <header class="card-head">
                    <!-- Rapid Telem Logo -->
                    <svg viewBox="0 0 130 40"
                         width="60"
                         height="18"
                         xmlns="http://www.w3.org/2000/svg"
                         class="pit-card-logo">
                        <polyline points="0,28 13,24 26,30 39,20 52,22 65,15 78,18 91,14 104,17"
                                  fill="none"
                                  stroke="var(--primary-color)"
                                  stroke-width="2.5"
                                  stroke-linecap="round"
                                  stroke-linejoin="round" />
                        <path d="M5 24 C 12 14, 33 12, 45 14 L 57 15 C 64 16, 70 19, 74 23 L 72 24 C 68 20, 63 18, 57 19 L 44 20 C 33 17, 18 17, 9 24 Z"
                              fill="none"
                              stroke="var(--accent-color)"
                              stroke-width="1.8"
                              stroke-linecap="round"
                              stroke-linejoin="round" />
                        <circle cx="18" cy="26" r="3" fill="var(--pitcard-bg)" stroke="var(--text-color-light)" stroke-width="1.6" />
                        <circle cx="40" cy="26" r="3" fill="var(--pitcard-bg)" stroke="var(--text-color-light)" stroke-width="1.6" />
                    </svg>
                    <!-- Title with forced line break -->
                    <h1>60‑Minute Setup Sprint<br>Pit Card</h1>
                    <!-- Meta info (Track/Baseline inputs) -->
                    <div class="meta">
                        Track: <input type="text" class="meta-input" id="pit-card-track" placeholder="e.g., Monza" aria-label="Track Name"><br>
                        Baseline: <input type="text" class="meta-input" id="pit-card-baseline" placeholder="e.g., 2:00.123" aria-label="Baseline Time">
                    </div>
                </header>

                <div>
                    <div class="section-title">Preparation (0–5m)</div>
                    <ul class="checklist">
                        <li><label><input type="checkbox"> Import IBT files & confirm laps</label><span class="time-box">0–2m</span></li>
                        <li><label><input type="checkbox"> Note baseline (fuel/tyres)</label><span class="time-box">0–3m</span></li>
                    </ul>
                </div>

                <div>
                    <div class="section-title">Baseline capture (5–15m)</div>
                    <ul class="checklist">
                        <li><label><input type="checkbox"> Select clean laps / Fastest N</label><span class="time-box">5m</span></li>
                        <li><label><input type="checkbox"> Record avg lap & sector times</label><input class="small-input" placeholder="avgLap" aria-label="baseline avg lap"></li>
                    </ul>
                </div>

                <div>
                    <div class="section-title">Test change & run (15–35m)</div>
                    <ul class="checklist">
                        <li><label><input type="checkbox"> Decide 1 focused change (list below)</label></li>
                        <li class="change-reason-stack">
                            <div>Change: <input class="small-input" placeholder="param ± delta" style="width:120px;"></div>
                            <div>Reason: <input class="small-input" placeholder="symptom" style="width:120px;"></div>
                        </li>
                        <li><label><input type="checkbox"> Run 6–10 laps (2 warmup + timed)</label><span class="time-box">~15m</span></li>
                    </ul>
                </div>

                <div>
                    <div class="section-title">Analyze (35–45m)</div>
                    <ul class="checklist">
                        <li><label><input type="checkbox"> Fastest N of test runs</label></li>
                        <li><label><input type="checkbox"> Compare sector deltas & delta chart</label></li>
                        <li><label><input type="checkbox"> Check ABS, throttle/gear, SV histogram</label></li>
                    </ul>
                </div>

                <div>
                    <div class="section-title">Decide & wrap (45–60m)</div>
                    <ul class="checklist">
                        <li><label><input type="checkbox"> Accept / revert / refine</label></li>
                        <li><label><input type="checkbox"> Export CSV & save setup</label></li>
                        <li><label><input type="checkbox"> Add short notes</label></li>
                    </ul>
                </div>

                <div class="section-title">Notes</div>
                <div class="notes" contenteditable placeholder="Driver notes, observed behavior, lap deltas..."></div>

                <div class="footer">
                    <div style="font-size:11px;color:var(--muted)">Keep changes small. Validate with 4–6 laps.</div>
                    <div class="no-print">
                        <button class="btn" onclick="window.print()">Print</button>
                        <button class="btn secondary" onclick="document.querySelector('.notes').focus()">Focus notes</button>
                    </div>
                </div>
            </div><!-- end .pit-card -->
        </div><!-- end .pit-card-content -->
    </div><!-- end #pit-card-modal -->


</body>
</html>



           


                
